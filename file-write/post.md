# Как писать в файлы?

Содержание:
1. Уровни какие проходит запрос записи
2. 
2. Системный вызов/ОС
3. Файловая система
4. Диск
5. А как же рантайм
    - трансляция запросов
    - Рассказать про баг .NET 7
6. Выводы

# Введение

Приветствую. 

TODO: ... Про пет-проект ...

Данные приложения я храню на диске, в файле. Казалось бы, просто вызови `write` и дождись окончания записи.
Но немного исследовав эту тему, я понял, что не все так просто - существует большое количество подводных камней, которые надо учитывать, чтобы быть немного уверенным, что данные точно сохранены.

Для начала представим путь, который проходят данные, перед тем как быть записанными на диск:

TODO: блоки визуализации (Приложение -> ОС -> Файловая система -> Диск).

# Приложение

Зависит от языка какие вызовы нужно сделать
Есть буферризация
Привести примеры различных ЯП
А еще стандартную библиотеку C (как пример)
Ну и мой пример

Тут про fflush, Flush у BufferedStream (C#) и даже когда открывается файл, то внутри есть BufferedStrategy

Как защититься/что делать: зависит от ЯП

---
Все начинается с самого приложения. 
Обычно у нас имеется интерфейс для работы с файлами. Это зависит от ЯП, но примеры:
- `fwrite` - C
- `std::fstream.write` - C++
- `FileStream.Write` - C#
- `FileOutputStream.Write` - Java
- `open().write` - Python
- `File.Write` - GO

и другие.

Это все средства предоставляемые языками программирования, для работы с файлами: запись, чтение и т.д.
Их преимуществом является независимость от платформы, на которой мы работаем. 
Но также и привносит свои недостатки. 
В данном случае, это буферизация.

Судя по документации, то из приведенных выше все ЯП используют либо поддерживают буферизацию:
- C - [setvbuf](https://en.cppreference.com/w/c/io/setvbuf)
- C++ - [filebuf](https://cplusplus.com/reference/fstream/filebuf/)
- C# - [BufferedFileStrategy](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/IO/Strategies/BufferedFileStreamStrategy.cs)
- Java - [Files.newBufferedReader](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newBufferedWriter-java.nio.file.Path-java.nio.charset.Charset-java.nio.file.OpenOption...-)
- Python - [io.BufferedIOBase](https://docs.python.org/3/library/io.html#io.BufferedIOBase)
- GO - [bufio.Reader](https://pkg.go.dev/bufio#Reader)

> Насчет C# - в реализации `FileStream` используется `FileStreamStrategy` класс, который обрабатывает запросы. 
> Например, при создании `FileStream` через `File.Open`, `BufferedFileStrategy` обертывает целевой `OSFileStreamStrategy`.

Вообще, буферизация в пространстве пользователя штука неплохая, так как позволяет повысить производительность. 
Но если не знать этого, то часть данных может быть не записана.
Тут может быть 2 случая:
1. Буферизованный файл создан вручную (GO, Java).
2. Буферизация происходит прозрачно для программиста (C, C++).

Если в первом случае мы точно знаем, что буферы надо сборосить после окончания записи, то второй вариант позволит выстрелить себе в ногу:
- Приложение экстренно закроется (SIGKILL нельзя обработать) и буферы уровня приложения просто не сбросятся.
- Файл после создания будет где-то в памяти и при закрытии буферы сброшены не будут, т.к. просто забудем сделать это.

Единственный выход здесь, на мой взгляд, - сбрасывать буферы после каждого сеанса записи. 
Например, при логировании мы сначала всю пачку строк записываем через `write` и, только когда все были записаны, вызываем `flush`. 

# ОС



Здесь про системные вызовы и буферризацию внутри системных вызовов записи.
Нужно вызывать fsync, или FlushFileBuffers (Windows)

Как защититься: сброс буферов ОС (fsync(), FlushFileBuffers())

FlushFileBuffers: 
- https://learn.microsoft.com/ru-ru/windows/win32/api/fileapi/nf-fileapi-flushfilebuffers
- https://github.com/postgres/postgres/blob/master/src/port/win32fdatasync.c
- https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntflushbuffersfileex

!Баг с fsync() в Postgres

rename может быть не атомарен (куда это приструнить) (`кстати, rename, согласно документации, атомарен - вернемся к этому позже`).
Пример из etcd с созданием нового сегмента атомарного.
Но нужно вызывать flush() на дескриптор директории.

# Файловая система

Данные так-то хранятся хоть на диске, но в файловой системе, которая сложна по устройству (метаданные, битовая карта, чанки данных).

Журналирование - один из основных способов сохранения согласованности. 
Поможет, но есть переупорядочивание (как в модели памяти - атомарность и переупорядочивание) (ссылку на сашу гольдштейна с выстплением про модели памяти).

Разные ФС дают разные гарантии и имеют разные семантики (исследование Not All Filesystems created equal).
Привести примеры переупорядочиваний.

Привести примеры различных файловых систем и их настроек. Возможно найти рейтинг используемых файловых систем.

Как защититься: лог операций свой, чек-суммы, мусор проверять на старте, тюнить параметры ФС.

Кейс: как правильно писать в файл с учетом мусора и т.д. (Files Are Hard вольный пересказ)

Про LVM поискать что нибудь.

# Диск

Данные хранятся на каком-то постоянном хранилище и могут сломаться.
Для хранения могут использоваться HDD, SSD, NVMe, Сетевое хранилище (NFS, облако), Магнитная лента.

Вот тут наши данные и хранятся.
Только если они были повреждены

Атомарность записи в сектор и Powersafe Overwrite

Как защититься: RAID, fsck, бэкапы

Про SSD: https://kcall.co.uk/ssd/index.html

Вроде бы все, но нет. Мы забыли о, пожалуй, главном.

# Среда выполнения

Многие приложения

Почему я заострил внимание - я нашел критичный (в этом контексте) баг .NET 7. Рассказать про найденный баг.

Возможно найти другие баги различных райнтаймов (Java, GO, Python, .NET).

`Поэтому важно ручками проверить, что этих багов нет. Но пожалуй самый радикальный способ - напрямую вызывать системные вызовы`.
Дать пример в C#

# Мой случай

Описать что использую сегментированный лог
Атомарность записи в сектор не волнует
Так как использую рафт, то 

# Заключение

Вроде бы простая задача - записать данные на диск, но слишком много подводных камней. 
Чтобы быть точно уверенным нужно учитывать множество факторов.
