Содержание:
1. ValueTask до и после .NET Core 2.1 - добавление IValueTaskSource
2. Устройство и алгоритм работы IValueTaskSource
3. Делаем полностью своими руками
4. Добавляем ManualResetValueTaskSource
5. Как реализован сокет с помощью него (все делают пример на нем, я не исключение)
6. Бенчмарки?
7. Ссылки

# ValueTask до и после .NET Core 2.1

Обычно `ValueTask` используют ради оптимизации. 
Например, возврат закэшированного результата, или возврата ValueTask.FromCancelled с переданным CancellationToken.

Но время шло, аппетиты возрастали и одним ранним выходом теперь не обойтись.
Поэтому в .NET Core 2.1 был добавлен `IValueTaskSource`.

Теперь `ValueTask` можно создать не только передав готовый результат или `Task`, но 
и упомянутый выше `IValueTaskSource`.

```cs
public ValueTask(IValueTaskSource source, short token);
public ValueTask(Task task);
public ValueTask<T>(T result);
```

Что это такое мы с вами сейчас и узнаем

# Устройство и алгоритм работы IValueTaskSource

Интерфейс `IValueTaskSource` - набор из 3 методов:

```cs
public interface IValueTaskSource<out TResult>
{
    // Получить статус выполнения текущей операции  
    ValueTaskSourceStatus GetStatus(short token);

    // Запланировать продолжение на выполнение по окончании операции
    void OnCompleted(
      Action<object?> continuation,
      object? state,
      short token,
      ValueTaskSourceOnCompletedFlags flags);

    // Получить готовый результат операции
    TResult GetResult(short token);
}
```

`GetStatus` - получает статус выполнения.
Статус представляет собой перечисление `ValueTaskSourceStatus`

```cs
public enum ValueTaskSourceStatus
{
    // В процессе
    Pending,
    // Успешно завершилась
    Succeeded,
    // Завершилась ошибкой (исключением)
    Faulted,
    // Отменена
    Canceled,
}
```

Этот метод вызывается 1 раз, после создания `ValueTask`.
Если операция уже завершилась, то вызывается `GetResult` для получения результата.
Если операция в процессе, то вызывается `OnCompleted` для регистирования продолжения на выполнение.

`OnCompleted` - регистрирует переданное продолжение на выполнение по окончании операции.
Вызывается после `GetStatus`. 

На вход ему подаются:
- `Action<object> continuation` - само продолжение
- `object state` - объект состояния, который передается `continuation`
- `ValueTaskSourceOnCompletedFlags flags` - специальные флаги, указывающие поведение при вызове продолжения

Флаги представляются перечислением `ValueTaskSourceOnCompletedFlags`:
```cs
[Flags]
public enum ValueTaskSourceOnCompletedFlags
{
    // Без указаний
    None = 0,
    // Необходимо использовать текущий SynchronizationContext для продолжения
    UseSchedulingContext = 1,
    // В продолжении нужно использовать текущий ExecutionContext
    FlowExecutionContext = 2,
}
```

Между вызовом `GetStatus` и `OnCompleted` может пройти какое-то время и операция завершится. 
Поэтому во время выполнения `OnCompleted` работа может быть уже закончена. 
В таких случаях, продолжение обычно выполняется тут же.

`GetResult` - получает результат операции. 
Этот метод вызывается 1 раз при завершении работы для получения результата: возвращаемый объект или исключение.

> Он должен быть вызван тогда, когда операция только завершилась.
> Моей ошибкой во время первой реализации было то, что я использовать семафор для ожидания выполнения.
> Но из-за неправильных вызовов случился дедлок: 
>  - Фоновый поток завершил операцию и выставил результат
>  - В этот момент вызвалось продолжение 
>  - Продолжение зашло в `GetResult` и остановилось на семафоре
>  - Фоновый поток не получил обратно управление, т.к. продолжение было вызвано и не выставил семафор

Также во всех методах присутствует `token`. 
Это специальное значения для обнаружения множественных `await`.
Зачем они нужны поговорим далее.

Алгоритм работы может быть 2 вариантов и зависеть от ответа `GetStatus`.
- `Pending` - операция не завершилась, поэтому нужно запланировать дальнейшее выполнение:
   1. `GetStatus`
   2. `OnCompleted`
   3. `GetResult`
- В остальных случаях выполнение уже завершилось:
   1. `GetStatus`
   2. `GetResult`

# Делаем полностью своими руками

Постановка задачи `PcMonitor`
Алгоритм работы с `PcMonitor`

Создание класса.

Реализация GetResult()

Реализация GetStatus()

Реализация OnCompletion()

Добавляем комментарии в вызовы методов для проверки пути вызова

# Добавляем ManualResetValueTaskSource

Реализация по большей части шаблонная.

Многая реализация уже есть в `ManualResetValueTaskSource`

Как выглядит с ним

# Добавляем пулинг + почему нельзя заново await'ить

Наши реализации можно переиспользовать.

Это пулинг

Использую Microsoft.Extensions.ObjectPool

Когда берем (в GetResult) и когда возвращаем

GetResult() 1 раз!! поэтому возвращаем в пул здесь.

Если сделать await заново, то передастся другой токен и мы заметим

# Как реализован сокет с помощью него (все делают пример на нем, я не исключение)

`IValueTaskSource` (как говорят) был добавлен специально для сокетов.
Все делают примеры на нем - я не исключение.

Реализация -  `AwaitableSocketsEventArgs`

Пример на ReceiveAsync.
Используется один буфер, т.к. чтение только 1 потоком возможно.
Строка 307

Строка 953 - если операция не завершилась - передача самого себя

Внутри все доходит до нативной операции и происходит возврат

Внутри `SocketAsyncEventArgs` (базовом классе) есть переменные для каждой возможной операции.
Начало класса

Сделать аналогию с нашей реализацией

# Бенчмарки?

Сравнение памяти ValueTask и Task

# Полезные ссылки

- Мой проект
- Реализация сокета (гитхаб)
- 

