# Как работают дебаггеры

О чем написать:

1. Ядро работы дебагера: `ptrace` + `INT 3`
2. Попробовать написать свой дебаггер
   - Простой интерфейс
   - DWARF формат попробовать распарсить (и дебажиться по строчкам)
   - Фича - откат истории
3. Как работают в управляемых ЯП (байт-код, jit, C#, java, python)
4. Особенности различных платформ
   - Windows
   - FreeBSD
   - М.б. другие платформы
5. Как это работает в VS Code (про этот интерфейс рассказать на примере gdb)
6. Фичи некоторые:
   1. GDB вызывает функции как
   2. Развертка стека
7. Некоторые ответы на вопросы
   1. При attach есть настоящий родитель, а есть приаттачившийся - как получать уведомления (waitpid)?
   2. Цикл при отладке - один другого и наоборот отлаживает (https://habr.com/ru/articles/439882/)?
   3. Профилировщики используют `ptrace`?


# Ядро

Поинты:
- Все вокруг ptrace и int 3
- Сказать что буду на x86 рассказывать + в конце то как на других архитектурах это реализуется (м.б. есть особенности хз)
- ptrace - это системный вызов
- int 3 - это инструкция для генерации прерывания
- брейкпоинт - это по факту прерывание
- он специально сделан однобайтовым + пример где это может выстрелить если не однобайтовый
- PEEK and POKE рассказать
- БП только для инструкций - для строк и т.д. нужны отладочные символы
- Что если к завершенному потомку чужому приаттачиться? Все получат результат или только кто-то один (exit code потомка) 
- `strace` использует `PTRACE_SYSCALL` (найти код)

Весь процесс дебагинга крутится вокруг 2 вещей:
- `ptrace`
- `INT 3`

`ptrace` - это системный вызов, который используется для отслеживания процесса (**p**rocess **trace**). 
Интерфейс следующий:

`long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);`

Можно заметить сходство с другими вызовами по типу `ioctl` или `fcntl` - код запроса (перечисление `__ptrace_request`), идентификатор объекта (`pid`) и вспомогательные данные (`addr`, `data`).

> Понимаю, что на этом вызове много обязанностей и трудно придумать более тонкий вариант, но это как-то контрастирует с философией Unix - `делают что-то одно`. 
> Может я прикапываюсь.

Благодаря этому системному вызову можно:
- `PTRACE_CONT`/`PTRACE_SINGLESTEP` - Получить контроль над выполнением
- Прочитать и изменять:
  - `PTRACE_GETREGS`/`PTRACE_SETREGS` - Регистры
  - `PTRACE_PEEKDATA`/`PTRACE_POKEDATA` - Память и код
  - `PTRACE_PEEKUSER`/`PTRACE_POKEUSER` - TODO: придумать как назвать
  - `PTRACE_SET_THREAD_AREA` - Локальные данные потока (TLS)
- `PTRACE_SET_SYSCALL` - Подменять вызываемые системные вызовы
- `PTRACE_SECCOMP_GET_FILTER` - Получать информацию о [seccomp](https://man.archlinux.org/man/seccomp.2.en)

<spoiler title="PEEK & POKE">

TODO: тут про peek & poke написать

</spoiler>

Для начала рассмотрим общий взгляд на процесс отладки. Грубо говоря, процесс отладки итеративный и каждую итерацию можно представить в виде 3 шагов:

1. Ждем точку останова
2. Выполняем необходимые действия 
3. Продолжаем работы

Рассмотрим каждый шаг.

> Далее буду использовать терминологию из man: `tracer` - отладчик, `tracee` - процесс, который отлаживаем

## Ждем точку останова

Первое - нам необходимо дождаться остановки tracee. 
Пока представим, что она есть и рано или поздно tracee до нее дойдет.

Главный принцип работы `ptrace` можно описать так: tracee получает сигнал и останавливается, а tracer в этот момент получает контроль, что-то делает и продолжает работу tracee.
Для ожидания этого сигнала tracer использует `waitpid`.

TODO: надо ли оставлять?
> Раньше я думал, что этот системный вызов нужен для ожидания завершения дочернего процесса, но, в общем случае, он используется для отслеживания изменения статуса потомка (wait for state changes in child of the calling process, как написано в man'е).

И сам смысл точки останова в следующем:

> tracee останавливается каждый раз, когда *получает сигнал* (любой), а tracer в это время пробуждается и *`WIFSTOPPED`*, вызванный на полученном статусе, возвращает `true`. 

То есть, отслеживаемый процесс получает любой сигнал, в этот момент останавливается и `waitpid` возвращается с соответствующим статусом. 

Ждать остановки tracee требуется обязательно - практически все `ptrace` вызовы, которые изменяют состояние tracee, вернут `ESRCH`, если будут вызваны над работающим процессом. С одной стороны, ограничение - нельзя вставить палку в колеса едущему велосипеду, но, с другой, интересно было бы посмотреть что случиться. Если кратко, то только 5 команд не требуют остановленного состояния, но и они используются для начала и окончания процесса отладки. Об этих командах можно посмотреть в секции Informational and restarting ptrace commands в `man 2 ptrace`.

<spoiler title="Разные статусы остановки">

TODO: описать


тут про то, что 
- всего есть running и stopped состояния, причем заблокирован сисколом = running
- ptrace-stop имеет множество подклассов
- 


</spoiler>

Когда `waitpid` вернулся, то необходимо проверить его статус. Грубо говоря, статус можно разделить 2 случая - останов и конец работы процесса. Определить это можно по упомянутому выше `WIFSTOPPED`. С учетом того, что останавливаться будем множество раз, то код отладчика в общем случае можно представить следующим образом:

```cpp
pid_t pid;
int wstatus;
while (1)
{
    /* 
     * Ждем остановки tracee 
     */
    pid_t ret_pid = waitpid(pid, &wstatus, 0);
    if (!WIFSTOPPED(wstatus))
    {
        /* 
         * Процесс завершил работу
         */
        break;
    }

    /* 
     * Выполняем необходимые действия
     * ...
     */

    /* 
     * И продолжаем работу
     * ...
     */
}
```

## Основные манипуляции

На этом моменте, tracee остановлен, а нам (дебаггеру) вернули управление из `waitpid`. 
Представим, что точка останова сработала и процесс не завершил свою работу. 
Теперь начинается самое интересное - процесс отладки: просмотр и изменение состояния tracee.

Команды, которые призваны получать и изменять состояние tracee, в документации называются информационными (informational). Есть множество аспектов процесса, которыми мы можем управлять и для них есть по 2 команды (`PTRACE_*`) - для чтения и записи. 

Сейчас нас будут интересовать только `PTRACE_PEEKTEXT`/`PTRACE_POKETEXT` и `PTRACE_GETREGS`/`PTRACE_SETREGS`. Первая команда используется для получения и изменения данных и кода процесса, а вторая - для регистров.

> Дополнительно есть `PTRACE_PEEKDATA`/`PTRACE_POKEDATA`.
> Эта команда должна работать с данными процесса (областью памяти), а `PTRACE_PEEKTEXT`/`PTRACE_POKETEXT` - с секцией кода (`.text`).
> Но, как описано в man, у линукса адресное пространство данных и кода единое, поэтому обе команды выполняют одно и то же.

В сигнатуре `ptrace` используется 4 аргумента: первые 2 для идентификации процесса и операции, а вторые 2 - для передачи специфичных для конкретной операции параметров. В частности, передаются 2 указателя. Их семантика отличается от команды к команде, а некоторые команды используют только часть, либо не используют эти параметры вообще, поэтому для каждой команды надо смотреть отдельно.

Для примера, если `rax` равен 0, то записать число 1 (4 байтное число), по адресу из регистра `rbx`. Реализовать это можно следующим образом:

TODO: проверить

```cpp
struct user_regs_struct regs;
ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
if (regs.rax == 0)
{
    void *addr = (void *)regs.rbx;
    long data = ptrace(PTRACE_PEEKTEXT, child_pid, addr, NULL);
    *((int *)&data) = 1;
    ptrace(PTRACE_POKETEXT, child_pid, addr, (void*)data);
}
```

Обратите внимание на то, как записывается число 1.
Загвоздка в том, что команды `PEEKTEXT` и `POKETEXT` работают с машинным словом, грубо говоря, оперируют размером указателя.
У меня 64-битная машина, поэтому его размер 8 байтов, а записываю я 4-х байтное.
Если бы я хотел записать 8 байтное (`long`), то мог бы сделать это проще, без read-modify-write.

```cpp
struct user_regs_struct regs;
ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
if (regs.rax == 0)
{
    void *addr = (void *)regs.rbx;
    long data = 1L;
    ptrace(PTRACE_POKETEXT, child_pid, addr, (void*)data);
}
```

Ну и вообще, вся работа с памятью (чтение и запись) ведется подобным образом - читаем необходимый диапазон памяти по машинному слову и после записываем также по машинному слову.

## Продолжение работы

Когда все необходимые действия выполнили, то надо продолжить работу процесса.
Сделать это можно 2 способами:

- `PTRACE_SINGLESTEP` - Выполнить только 1 инструкцию
- `PTRACE_CONT` - Продолжить выполнение

Логично, что следующая остановка у первой команды будет у начала следующей инструкции, а у второй - при следующем сигнале.

## Изначальный запуск

Последнее, что мы не покрыли - как начинается процесс отладки.
Тут также есть 2 варианта:

- Сами запускаем процесс для отладки
- Присоединяемся к уже работающему процессу

### Самостоятельный запуск

Для самостоятельного запуска есть следующий паттерн:
1. Форкаемся
2. Потомок вызывает `ptrace(PTRACE_TRACEME, 0, NULL, NULL)` и запускает `exec**` с нужной программой
3. Родитель постоянно вызывает `waitpid` с пидом потомка и ждет, пока не сработает очередная точка останова

Т.е. примерно так

```c++
void child_main()
{
    /* 
     * Позволяем родителю отслеживать себя
     */
    ptrace(PTRACE_TRACEME, 0, NULL, NULL);
    /* 
     * Запускаем отлаживаемую программу
     */
    execlp("executable", "arg1");
}

void parent_main(pid_t child)
{
    int wstatus;
    while (1)
    {
        /* 
         * Ждем остановки потомка
         */
        waitpid(child_pid, &wstatus, 0);
        if (!WIFSTOPPED(wstatus))
        {
            /*
             * Потомок завершил работу
             */
            break;
        }
        /*
         * Выполняем необходимые действия над потомком
         */
        perform_actions(child_pid);
        /* 
         * Продолжаем его работу
         */
        ptrace(PTRACE_CONT, child_pid, NULL, NULL);
    }
}

int main()
{
    pid_t child_pid;
    if ((child_pid = fork()) == 0)
    {
        child_main();   
    }
    else
    {
        parent_main(child_pid);
    }
}
```

### Присоединяемся к запущенному процессу

Если какой-то процесс уже запущен и мы хотим его отладить, то для этого используется уже другой вызов - `PTRACE_ATTACH`.


При присоединении к другому процессу через `PTRACE_ATTACH` отлаживаемому процессу посылается `SIGSTOP` - это нужно, чтобы мы могли остановить процесс и поработать с ним.
Системные вызовы могут вернуть `EINTR`, когда они прерываются сигналом.
Поэтому, можно сказать, что `PTRACE_ATTACH` создает этот `errno`.

Пример такой:

```c++

int main()
{
    int wstatus;
    pid_t child_pid = obtain_pid();
    ptrace(PTRACE_ATTACH, child_pid, NULL, NULL);
    while (1)
    {
        waitpid(child_pid, &wstatus, 0);
        if (!WIFSTOPPED(wstatus))
        {
            /*
             * Потомок завершил работу
             */
            break;
        }
        /*
         * Выполняем необходимые действия над потомком
         */
        perform_actions(child_pid);

        /* 
         * Продолжаем его работу
         */
        ptrace(PTRACE_CONT, child_pid, NULL, NULL);
    }
}
```


Если нам НЕ нужно останавливать процесс после присоединения, то для этого используется `PTRACE_SEIZE`.
В этом случае, нам становится доступна еще одна команда - `PTRACE_INTERRUPT`. 
Как понятно из имени, он нужен для прерывания потока.
В man'е описано 4 варианта развития событий при выполнении этой команды: 
- При выполняющемся системном вызове этот вызов вернет `EINTR`
- Уже остановленный, но при применении `PTRACE_LISTEN`
- При конкурентном событии остановки
- Все остальные случаи
  
TODO: может добавить этот пример?
Пример для `PTRACE_SEIZE` оставляю на читателя.

## Собирая детали вместе

На этом моменте, в голове уже имеется общая картина, того как работают отладчики: процесс останавливается сигналом, мы его препарируем и продолжаем его работу.

Давайте сделаем свой небольшой пример использования.
Я придумал такой: приложение для складывания 2 чисел.
Ему через аргументы передаются эти 2 числа, он их складывает и печатает ответ.
Наша задача заключается в том, чтобы поменять одно из слагаемых таким образом, чтобы сумма осталась корректной, но одно из слагаемых (я возьму правое) поменялось.
Грубо говоря, прямо перед выводом результата присоединиться и изменить значение переменой слагаемой.
Звучит просто, давайте напишем.

Вначале бизнес-логика. 
Здесь все просто:

- Через argc/argv передаются аргументы
- С помощью `atol` парсим второй и третий аргументы (первый - название программы)
- Складываем 
- Выводим с помощью `printf`

Тут даже особо думать не надо. 
Можно набросать так:

```c++
int main(int argc, const char **argv)
{
    if (argc != 3)
    {
        return 1;
    }

    int left = atol(argv[1]);
    int right = atol(argv[2]);
    int sum = left + right;
    printf("%ld + %ld = %ld\n", left, right, sum);
    return 0;
}
```

Теперь надо подумать над тем, как сделать так, чтобы `right` изменился между суммой и вызовом `printf`.
Вспомним, что потомок замораживается, когда получает сигнал, причем любой.
Это сделать можно вызовом `raise` - просто передаем ему нужный сигнал и все.
Я использую `SIGCHLD`, т.к. по умолчанию он игнорируется и процесс не упадет, если его (сигнал) не обработать.
Как-то так:

```c++
int sum = left + right;
raise(SIGCHLD);
printf("%ld + %ld = %ld\n", left, right, sum);
```

Но не тут-то было.
Проблема в данном случае - определить где значение эта переменная хранится.
Я запускаю этот код на Linux, на нем используется System V ABI.
То есть, я знаю в каких регистрах должны хранится аргументы для `printf`, но опять проблема - в процессе вызова самого `raise` эти регистры затрутся аргументами для внутренних функций.
Короче говоря, это проблема.


Я не придумал ничего лучше, чем переписать все на ассемблере и сделать следующие ходы:

- Переменные `left`, `right` и `sum` теперь хранятся на стеке
- Так как этим стеком управляю я, то знаю на каком смещении от `rbp` какая переменная хранится
- Сам адрес `rbp` я сохраняю во внешнем файле, который читает отладчик

Честно говоря, это моя первая программа на ассемблере, поэтому ее качество оставляет желать лучшего:

<spoiler title="Код tracee на ассемблере">

Я использовал ассемблер GAS и синтаксис AT&T

```assembler
TODO: код
```

</spoiler>

Также имеется и отладчик.
Он делает то, что нужно - дожидается остановки tracee, читает файл с адресом и изменяет переменную.
Тут ассемблер уже не нужен.

<spoiler title="Код tracer">

```c++
TODO: код
```

</spoiler>

Да, это все было сложно и муторно - сколько всего пришлось сделать, чтобы просто поменять значение переменной.
Но есть хорошие новости - этот процесс можно очень легко упростить.
Помните, что мы останавливаемся на каждом сигнале. 
Вот была бы такая вещь, которая просто создаст сигнал и все.

Хорошая новость - она есть!

<spoiler title="Другие попытки этой реализации">

- через SIGFPE и деление
- простой вызов `raise`

</spoiler>

## int 0x3

`int 0x3` - это инструкция, которая создает нужный нам сигнал:

- `int` - это ассемблерная инструкция, генерирующая программное прерывание. Она принимает на вход аргумент
- `0x3` - номер прерывания для точки останова

Сейчас я говорю про архитектуру x86.
Она определяет [таблицу (вектор) прерываний](https://wiki.osdev.org/Interrupt_Vector_Table#:~:text=On%20the%20x86%20architecture%2C%20the,older%20software%20(e.g.%20MS-DOS%20programs)).

Когда процесс доходит до этой инструкции, то генерируется программное прерывание, которое приводит к получению `SIGTRAP`.
И вот в момент его получения мы можем получить контроль над процессом.

Давайте перепишем предыдущий код, но теперь уже с этой инструкцией.

<spoiler title="Код tracee на ассемблере">

```assembler
TODO: код
```

Заметьте, что в начале регистрируется обработчик `SIGTRAP`.
Я преследовал такую логику, чтобы этот сигнал не влиял на работу без отладчика. 
Грубо говоря, если нет отладчика (нашего), то все работает, но если запуск под ним, то логика меняется как хотим.



</spoiler>

Код tracer'а изменится соответственно

<spoiler title="Код tracer'а">

```c++
TODO: код
```

</spoiler>

<spoiler title="SIGTRAP особенный">

Тут рассказать про то, что некоторые сигналы игнорировать нельзя и если это сделать, то по умолчанию они станут в SIG_DFL

Табличку построить, что и когда происходит (hard, soft / int3, raise)

man 7 signals -> BUGS -> Сигналы которые перечислены будут доставляться всегда, если вызваны hardware (грубо говоря), SIGTRAP там тоже есть

Показать список сигналов, которые просто сбросят SIG_IGN/block (взять из force_sig)

Запись в interrupt descriptor table для int3 - https://github.com/torvalds/linux/blob/ec9eeb89e60d86fcc0243f47c2383399ce0de8f8/arch/x86/kernel/traps.c#L735

Сам обработчик, который выставляет SIG_IGN в SIG_DFL - https://github.com/torvalds/linux/blob/master/kernel/signal.c#L1326

</spoiler>

В общем, можно сказать что все готово - брейкпоинты реализуются через `int 0x3` инструкцию, можно заканчивать.
Но есть последний момент, который надо обсудить - где и как эту инструкцию вставлять.

Сейчас я написал все на ассемблере и у меня был полный контроль над исходным кодом.
Но 1) почти все пишут на более высокоуровневых ЯП и машинные инструкции там использовать нельзя, 2) не всегда есть доступ к исходному коду.
То есть просто так вставить `int 0x3` и вызвать нужное прерывание в готовом бинарнике мы не можем.
Как быть в этой ситуации?

Ответ прост - затереть инструкции.

## Как ставятся точки останова

В реализации точек останова, грубо говоря, 2 основных алгоритма: ее выставление и момент захода в нее.

Выставление точки останова:

1. Получаем адрес нужной нам инструкции
2. Пишем поверх нее инструкцию `int 0x3` (запоминаем что затерли!)

Заход в точку останова:

1. Точка останова срабатывает
2. Tracer подготавливает окружение:
   1. Получает управление
   2. Восстанавливает затертую инструкцию
   3. Переходит к предыдущей инструкции
3. Tracer выполняет необходимые манипуляции
4. Tracer продолжает выполнение tracee

Для tracee это все происходит прозрачно - кроме сигнала практически нет внешних эффектов.

Кто-то может спрость "как так? секция `.text` недоступна для записи!".
Да, но только для пользовательского пространства, а в случае с `ptrace` - 1) часть ядра, 2) может выполняться только если выполняется с полученными привилегиями.
Короче говоря, с помощью `ptrace` можно изменять и секцию `.text`.
Вы могли заметить команду `PTRACE_POKETEXT` - как можно догадаться это она изменяет код программы (то что по переданному адресу находится).

Но и тут не все, есть еще один важный момент.
Не забываем, что `int 0x3` - это всего лишь инструкция ассемблера, а ассемблер != машинные инструкции, то есть отображение не всегда однозначное.
И тут мы приходим к последнему аспекту.

## Однобайтная инструкция `int 0x3`

Может показаться что `int 0x3` - 2 байтная инструкция (команда + аргумент), но на практике она занимает *1 байт* - `0xCC`.

TODO: проверить
> Можно использовать и 2 байтную инструкцию - `0xCD 0x03`. Она тоже сработает.

Почему это важно?
Достаточно рассмотреть такой частный случай: проверка аргументов в начале функции.

На C это можно реализовать так:

```c++
/* 
 * Пользователь обновил свой интервал бронирования номера - нам нужно уведомить об этом других
 */
void notify_user_rest_interval(long start, long end)
{
    if (start == end)
    {
        /* 
         * Однодневный интервал пропускаем для оптимизации
         */
        return;
    }

    /* 
     * Уведомляем по телеге
     */
    notify_telegram();
}
```

После компиляции, мы можем получить такой ассемблерный код (справа машинный код):

```assembler
notify_user_rest_interval:
    cmpq %rdi, %rsi         # 48 39 FE
    jnz pass                # 75 01
    ret                     # C3
pass:
    call notify_telegram    # e8 00 00 00 00                   
```

Теперь представим, что `int 0x3` занимает 2 байта и мы хотим поставить точку останова прямо на `return`/`ret`.
То есть отловить все моменты, когда вызов "не совсем оптимальный".
Что произойдет?
Заметим, что `ret` - однобайтная и если ее перетереть нашим 2-х байтным `int 0x3`, то это затронет следущую инструкцию - `call`.
TODO: как правильно назвать первый байт инструкции
Учитывая что первый байт инструкции - ее `opcode` (тип команды), то будет 

Если обобщить, то 2-х байтный код для точки останова для 1 байтной команды может переписать следущую инструкцию и сделать ее невалидной, что приведет к проблемам при переходах (семейство инструкций `jmp`, `call` и т.п.).
Поэтому 1 байт для инструкции точки останова всегда затронет, только необходимую инструкцию и не повлияет на последующую функциональность.

TODO: по другому оформить
Замечания:
- Хотел адаптировать пример из Eli, но стр. 14 [AMD Reference](https://tc.gtisc.gatech.edu/cs6265/2016/refs/amd64-vol3-inst.pdf) указывает, что 1-байтных инструкций для INC/DEC больше нет (только режим совместимости)


Но для наглядность посмотрим, что будет при 2 байтной инструкции.

```assembler
    notify_user_rest_interval:
    cmpq %rdi, %rsi         # 48 39 FE
    jnz pass                # 75 01
    int $3                  # CD
pass:
    addl (%rax), %eax       # 03 00 
    addb %al, (%rax)        # 00 00  
    n/a                     # 00
```

Здесь важно заметить, что для `call` я ранее передавал нули, так как реальный адрес появится только во время выполнения.
Поэтому для примера я также использую нули.

И уже тут можно заметить, что:

1. Вызов функции `notify_telegram` исчез
2. Добавились новые инструкции, которые изменяют содержимое регистров (наше состояние), причем скорее всего мусором, так как используется `rax` - регистр для результата функции (не инициализирован)
3. В конце вообще появилась некорректная инструкция `00` - обозначил n/a


В данном случае, мы хотябы словим `SIGILL` за счет последней некорректной инструкции и ничего плохого не сделаем.
Но с учетом того, что адрес будет случайным (спасибо ASLR), то на месте мной указанных появятся случайные инструкции и тогда будь что будет.

---

Вот теперь, можно сказать, что тему ядра отладчиков покрыли.
Суммируя:

1. Вся магия заключена в комбинации системного вызова `ptrace` и инструкции `int 0x3`
2. Отладчик просто ждет пока потомок не остановится при возникновении очередного сигнала
3. Для создания этого сигнала используется `int 0x3`, которая создает `SIGTRAP` сигнал
4. Точка останова - это `int 0x3` записанная поверх исходных инструкций и, когда до нее доходим, восстанавливаем исходные инструкции и ступаем на 1 инструкцию назад

Надеюсь, объяснил понятно.
Но это только вершина айсберга - я хочу копнуть немного глубже.

# Детали работы отладчиков

Ранее мы работали только с инструкциями, но обычно мы работаем с исходным кодом.
Мост, соединяющий эти 2 мира - отладочные символы.

## Отладочные символы

Скорее всего, вы и так уже знаете что такое отладочные символы.
Это специальные символы (symbols), которые добавляют некоторую полезную информацию, относительно исходного кода.
Например, переменные и их типы, разметка структур, отображение инструкций на строки исходного кода и т.д.

Существует множество форматов. Я чаще всего слышал про DWARF (в контексте *nix) и PE-COFF (в контексте Windows):

TODO: написать что-нибудь про них
- DWARF - Debugging With Arbitrary Record Formats
- PE-COFF - Portable Executable COFF)

TODO: Про BPF - https://habr.com/ru/articles/514736/ 

Кроме них я нашел и другие:

TODO: полезно - https://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf

TODO: все тезисы проверить

### STABS

[STABS](https://sourceware.org/gdb/current/onlinedocs/stabs.html) (Symbol TABle Strings) - один из первых форматов отладочных символов (1980-е). Название исходит из того, что все данные для отладки хранились в виде простых строк в таблице символов объектного файла (тогда еще `a.out` - не ELF).

Изначально создавался для pdx - дебаггера Pascal. Сейчас поддерживается и для других языков.

Вся отладочная информация хранится в специальных таблицах символов - stab. Для разной информации имеются разные директивы ассемблера:

- `.stabs` - строковая информация: функции, структуры, строки исходного кода, глобальные переменные (используется чаще всего)
- `.stabn` - числовая информация (скорее та, для которой не нужны строки): общее количество символов, адрес `catch` для GNU C++ (`N_CATCH`)
- `.stabd` - то же, что и `stabn`, но значение - текущая строка (явно не указывается значение): (примеров не нашел)

TODO: где использовался/кто поддерживает

### OMF

[OMF](https://refspecs.linuxfoundation.org/elf/TIS1.1.pdf)(\[Relocatable\] Object Module Format) - это на самом деле формат объектных файлов, а не отладочной информации. 
Но поддержка отладочной информации в нем явная - отдельные, "well-known" записи.


Объектный файл представляется в виде последовательности записей, каждая из которых состоит из 4 "полей":

|               | Тип                                     | Длина                                       | Данные                                             | Чек-сумма                      |
| ------------- | --------------------------------------- | ------------------------------------------- | -------------------------------------------------- | ------------------------------ |
| Размер (байт) | 1                                       | 2                                           | N                                                  | 1                              |
| Описание      | Определяет какие данные содержит запись | Длина оставшейся части (Данные и Чек-сумма) | Сама полезная нагрузка. Содержимое зависит от Типа | Чек-сумма всех остальных полей |

Как можно заметить, поле тип определяет содержимое записи.
В TIS определили 28 типов записи. Например, запись PUBDEF (PUBlic DEFinitions) определяет список экспортируемых (глобальных) символов.
Но пока сфокусируемся на отладке.

Для отладки можно использовать следующие записи:

- LINNUM - Отображение строк исходного кода, на адреса машинных инструкций
- LINSYM - Отображение функций на строки исходного кода (вместе с LINNUM позволяет понять адрес начала функции)
- PUBDEF, LPUBDEF - Функции и переменные - глобальные и локальные (в зависимости от префикса L). Можно сказать, что разница в том указывается ли `static` или нет
- COMDEF, LCOMDEF - Общие (communal) переменные - неинициализированные статические или те, что могут соответствовать инициализированным, но в другой единице компиляции

> У PUBDEF и COMDEF есть свои братья LPUBDEF и LCOMDEF соответственно. Первые экспортируют свои символы, а вторые имеют видимость только в пределах своего модуля.

Перечисленные записи указываются в TIS как актуальные. Но в расширениях были определены и другие (в документе помечены как устаревшие):

- DEBSYM - Дополнительная отладочная информация
- TYPDEF - Информация о типе
- LOCSYM - Информация о локальных символах
- BLKDEF - Информация о блоке программы, которая содержит свою видимость, локальные переменные

Это довольно старый формат: последняя версия V5.0 была издана Intel в 1985. За все время существования многие компании создали свои ответвления/надстройки: в документе (ссылка сверху) дана спецификация для OMF, созданная из компиляции 6 различных источников.
После 5 версии выкладывались и другие версии, но они были специфичны для разлиных платформ, например, IBM в 1993 выложил свою [спецификацию IBM-OMF](http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/pc/os2/OS2_OMF_and_LX_Object_Formats_Revision_8_199406.pdf).

P.S. Не думаю, что этот формат мертв. Как минимум, автор [этой статьи](https://habr.com/ru/articles/576770/) приложил усилия и перевел свою систему программирования на PL/1-KT с 16 на 64 бит.

<spoiler title="Сегментная организация 8086">

TODO: здесь про far указатели - https://en.wikipedia.org/wiki/Far_pointer

</spoiler>

### CTF

[CTF](https://www.sourceware.org/binutils/docs/ctf-spec.html) (Compact C Type Format) - это формат отладочной информации, который содержит 
информации преимущественно об используемых типах (как можно догадаться из названия).

Изначально он разработан для Solaris, но позже был добавлен и в другие ОС. Например,:

- Linux  - в 2012 портировали libdtrace ([первый коммит](https://github.com/oracle/libdtrace-ctf/commit/248dc18174b23fec1a6a932263b3a2b5ce5adbcc))
- FreeBSD - в нем CTF это [модуль ядра](https://docs.freebsd.org/en/books/handbook/dtrace/#dtrace-implementation), без которого не будет его поддержки

Изначально, CTF проектировался как компактный и простой формат.
Компактность достигается за счет:

- Тесного "содружества" с ELF форматом - CTF использует уже готовые таблицы символов, предоставляемые ELF файлом. В частности, переиспользует таблицу строк
- Использования сжатия с помощью zlib

Проста же достигается за счет того, что в симолах отладки есть только информация о типах, без какой-либо дополнительной информации.
Учитывая, что CTF разрабатывался для C, то и типы CTF эквивалентны типам C.
На данный момент, имеются следующие типы:

```cpp
/* https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=include/ctf.h;h=4414cb0ebed95f9049ec84f9089ef8f149f21eda;hb=32778522c7d8777803c88684b8e428ee729f0b22#l408 */
#define CTF_K_UNKNOWN   0       /* Unknown type (used for padding and
                                   unrepresentable types).  */
#define CTF_K_INTEGER   1       /* Variant data is CTF_INT_DATA (see below).  */
#define CTF_K_FLOAT     2       /* Variant data is CTF_FP_DATA (see below).  */
#define CTF_K_POINTER   3       /* ctt_type is referenced type.  */
#define CTF_K_ARRAY     4       /* Variant data is single ctf_array_t.  */
#define CTF_K_FUNCTION  5       /* ctt_type is return type, variant data is
                                   list of argument types (unsigned short's for v1,
                                   uint32_t's for v2).  */
#define CTF_K_STRUCT    6       /* Variant data is list of ctf_member_t's.  */
#define CTF_K_UNION     7       /* Variant data is list of ctf_member_t's.  */
#define CTF_K_ENUM      8       /* Variant data is list of ctf_enum_t's.  */
#define CTF_K_FORWARD   9       /* No additional data; ctt_name is tag.  */
#define CTF_K_TYPEDEF   10      /* ctt_type is referenced type.  */
#define CTF_K_VOLATILE  11      /* ctt_type is base type.  */
#define CTF_K_CONST     12      /* ctt_type is base type.  */
#define CTF_K_RESTRICT  13      /* ctt_type is base type.  */
#define CTF_K_SLICE     14      /* Variant data is a ctf_slice_t.  */
```

Как можно заметить, поддерживается 14 типов. Но если представить тип нельзя (TODO: пример когда нельзя), то используется специальный тип 0.
Например, в gcc имеется поддержка CTF, которая реализована хуком в [`dwarf2ctf.c`](https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/dwarf2ctf.cc;h=00b876e2fe2cb901ca6e8e5c8c01e78f0d812723;hb=36774cec1f8d224e202dd3ca2012dae79d4e8ba9#l921), - если DIE нельзя отобразить в тип CTF, то используется `CTF_K_UNKNOWN`.

> В документации используется `type of some kind`, т.е. правильнее говорить не `type`, а `kind` т.к. именно он используется для конкретизации.
> Это можно заметить и в этих константах - все начинаются как `CTF_K_xxx`.
> Но я использую слово "тип" - не нашел более подходящего перевода.

### BTF
TODO: не забыть связь с CTF (или как он там)
[BTF](https://docs.kernel.org/bpf/btf.html) (BPF Type Format) - это формат метаданных, разработанный специально для BPF программ.
Сегодня, на замену BPF пришел eBPF, но я буду использовать BPF - так короче.
Изначально он поддерживал только информацию о типах (что отражается в самом названии), но после была добавлена поддержка функций, данных исходного кода (строки), переменных и др.

Сам по себе BPF это последовательно 64-битных инструкций, которые JIT-компилируются ядром.
Но для разработки этот ассемблер не очень удобен, поэтому разработали libbpf и формат ELF специально для BPF.
libbpf читает этот ELF файл, выполняет необходимые манипуляции и сам уже вызывает необходимые системные вызовы.
А для создания этого объектника можно использовать понятные нам языки по типу C или Rust.

Отладка возможна благодаря отладочным секциям, которые содержат нужную информацию.

- `.BTF` - Различная полезная информация - типы, переменные, квалификаторы, функции и т.д.
- `.BTF.ext` - Данные, необходимые загрузчику для манипуляций перед загрузкой в ядро.
- `.BTF_ids` - Содержит BTF ID - идентификаторы, которые использует ядро.

Как можно понять, именно в секции `.BTF` содержится вся необходимая для нас информация.
Она состоит из 2 частей: таблица строк (string table) и массив отладочной информации, далее МОИ
(в документации говорится `type data`, но мне кажется "массив отладочной информации" более говорящее название).
Таблица строк - это просто массив C-style строк, к которой обращается каждый элемент МОИ.

Каждый элемент МОИ имеет общую структуру, но далее каждый конкретный тип расширяет эту структуру, добавляет свои специфичные данные.
Под типом имеется ввиду не только `type`, но разные синтаксические конструкции и другая информация.
В исходном коде, это называют `KIND`, но другого перевода я не нашел.

На данный момент, поддерживаются следующие типы.

```cpp
/* https://github.com/torvalds/linux/blob/1722389b0d863056d78287a120a1d6cadb8d4f7b/include/uapi/linux/btf.h#L59 */
enum {
	BTF_KIND_UNKN		= 0,	/* Unknown	*/
	BTF_KIND_INT		= 1,	/* Integer	*/
	BTF_KIND_PTR		= 2,	/* Pointer	*/
	BTF_KIND_ARRAY		= 3,	/* Array	*/
	BTF_KIND_STRUCT		= 4,	/* Struct	*/
	BTF_KIND_UNION		= 5,	/* Union	*/
	BTF_KIND_ENUM		= 6,	/* Enumeration up to 32-bit values */
	BTF_KIND_FWD		= 7,	/* Forward	*/
	BTF_KIND_TYPEDEF	= 8,	/* Typedef	*/
	BTF_KIND_VOLATILE	= 9,	/* Volatile	*/
	BTF_KIND_CONST		= 10,	/* Const	*/
	BTF_KIND_RESTRICT	= 11,	/* Restrict	*/
	BTF_KIND_FUNC		= 12,	/* Function	*/
	BTF_KIND_FUNC_PROTO	= 13,	/* Function Proto	*/
	BTF_KIND_VAR		= 14,	/* Variable	*/
	BTF_KIND_DATASEC	= 15,	/* Section	*/
	BTF_KIND_FLOAT		= 16,	/* Floating point	*/
	BTF_KIND_DECL_TAG	= 17,	/* Decl Tag */
	BTF_KIND_TYPE_TAG	= 18,	/* Type Tag */
	BTF_KIND_ENUM64		= 19,	/* Enumeration up to 64-bit values */

	NR_BTF_KINDS,
	BTF_KIND_MAX		= NR_BTF_KINDS - 1,
};
```

Можно заметить, что все элементы перечисления похожи на типы CTF, но поддерживается гораздо больший диапазон типов.
Причина в том, что этот формат изначально разрабатывался именно для C и за основу был взят CTF.
BTF был добавлен в [этом патче](https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=69b693f0aefa0ed521e8bd02260523b5ae446ad7)
и вот отрывок из него:

> Hence, it basically focus on the C programming language which the modern BPF is primary using.
> ...
> BTF has its root from CTF (Compact C-Type format).

### VMS

[VMS]() - это формат отладочной информации, созданный для ОС OpenVMS

*Информации я нашел оооооооооооооочень мало. Можно сказать, все что у меня было - исходники из gcc. Поэтому далее будет описание, сделанное по реверс инжинирингу этих исходников. Они кстатит тут, в [dwarf2ctf.cc]().*

TODO: добавить ссылку

Заметки:
- `.text` - секция кода
- VMS Epoch и Unix epoch - различаются
- FIT - file info table
- LIT - line info table: file (его индекс), line number (сам номер) -> label + PC (???)
- Метки (label) могут генерироваться автоматически, но макс. длина - 30 символов
- gcc по умолчанию использует 32 битную архитектуру (PTR_SIZE = 4)
- Для отладки регистрируются свои хуки (gcc_debug_hooks)
- Метками помечаются (vmsdbgout.cc:250, gcc):
  - Начало(??)/Конец TEXT
  - Начало, пролог, эпилог, конец функции
  - Начало, конец блока
  - LINE CODE (???)
  Есть и другие метки, они в макросах начинаются с ASM_OUTPUT...

С этого момента копаюсь в binutils-gdb

- В vms-alpha.c (gdb) есть TODO 14 летней давности

---

Дальше из документа https://www.digiater.nl/openvms/freeware/v50/debug/alpha_dstrecrds.sdl

SDL - Specifiction and Description Language

DST хранит информацию о:
- модули
- функции
- лексические блоки
- метки
- символы и зависимости между ними
- строках исходного кода
- типы данных (даже сложные)

DST предназначен для использования DEBUG и TRACEBACK утилитами и только для компилируемых яп (не интерпретируемых)

В DST есть 2 типа записей:
- TBT - TODO
- DBT

После работы линковщика для создания исполняемого приложения могут появиться еще 2 секции:

- Global Symbol Table (GST) - все глобальные символы пользовательской программы. Используется, если в DST нет нужной информации (в документации last resort) 
- Debug Module Table (DMT) - вспомогательная таблица для DST, помогающая выполнить инициализацию быстрее, т.е. выступает в роли индекса.

Найти DST:
TOP -> IMAGE HEADER -> IHD$W_SYMDBGOFF -> IHS -> (IHS$L_DSTVBN, IHS$L_DSTBLKS) - положение и размер
 
DMT - запись на каждый модуль в DST.
Используется для инициализации:

- RST - RunTime Symbol Table
- Program SAT - Program Static Address Table

Структура DST:

- Состоит из последовательностей DST записей
- Каждая запись имеет заголовок из 2 байт - длина и тип. Содержимое определяется типом.
  
Записи DST - из этой последовательности и состоит весь DST:
- Module Begin DST - запись всегда перед Module DST
  - Название модуля
  - ЯП
- Всякие разные таблицы (symbol information)
- Module End DST - запись всегда после Module DST
  - Просто помечает конец

В конце абсолютно всех модулей (Module Begin/End) - Fixup DST записи - для релокации адресов

Каждая запись 512 байт. Если последняя не влазит - заполняется 0.

DMT - отмечает начало каждого Module Begin DST для каждого модуля

Есть и вложенность. Ее много:
- Routine Begin/End
- Block Begin/End

Даже записи (структуры) - это Begin/End:
- Record Begin
- Data x1
- Data x2 ...
- Record End

Есть отдельная поддержка Variant из паскаля - Variant Set Begin/End

Ada: Package Begin/End

Prolog: Proglog List Record

C++: template declaration

Представление переменных:

- Называются Data Symbols
- Есть множество представлений, но все дают 3 детали: название, адрес, тип
  - Standard Data DST - простейшая форма, описывающая простые, скалярные типы данных - int, float ...
  - Descriptor Format DST - используется, когда данные описываются с помощью VAX Standard Descriptor (??? TODO)
  - Separate Type Specification DST - определение составных типов данных (структур)
  - Специализированные DST - например, типы перечисления из Bliss (TODO: ссылка на пример)
- Дополнительная информация по блокам видимости и т.д. - неявная, получается из окружения (вложенные DST записи)
- Название - Counted ASCII string (???)
- Адрес - 5 байтов: 1 байт - тип, 4 байта - значение или адрес. Если не вмещается - указывает на область памяти, которая значение содержит
- Тип - предтавляется семейством Type Specification DST (все дальнейшие название имеют суффикс Type Specification):
  - Atomic - для скалярных типов (int, float, ...)
  - Descriptor - для стандартных типов VAX
  - Ada Descriptor - типы, которые описываются ADA'вским "расширенным дескриптором" (extended descriptor)
  - Indirect - используется, когда целевой тип расположен в другой DST записи
  - Cross-Module Indirect - как Indirect, но используется, когда тип определен в другом модуле
  - Typed Pointer - типизированный указатель
  - Pointer - не типизированный указатель (`void*`)
  - Picture - используется для типа picture в COBOL и PL/I
  - Array - массив
  - Ada array - ADA'вский массив (разница в том, что используется тот же "расширенный дескриптор")
  - Set - тип Set из Pascal
  - Subrange - описывает диапазон значений порядкового типа данных (числа, перечисления)
  - File - тип File из Pascal, PL/I
  - Area - тип area из PL/I
  - Offset - тип offset из PL/I
  - Novel Length - используется для указания дочерних типов, которые идентичны своим родителям, но имеют другую длину. В качестве примера указаны PACKED records из Pascal (TODO: ссылка на это)
  - Dynamic Novel Length - тоже самое что и Novel Length, но длина указывается другим способом
  - Self-Relative Label - "self-relative" label из PL/I (TODO: что это, ссылка)
  - Task - объекты типа task из ADA
  - Constrained Record - используется для указания того, что этот тип "ограничен в смысле ADA" (constrained in the ADA sense) - структура, в которой дискриминанты (определяют тип variant) имеют известное, константное значение
  - Might-Be-Constrained Record - используется для формальных параметров (передаваемый аргумент), которые НЕ constrained record, но известно, что реально передаваемое значение может быть constrained record
  - Scan Tree - тип Tree data из Scan (TODO: ссылка на это)
  - Scan Treeeptr - указатель типа Scan Tree (особый случай typed pointer)
  - Incomplete - используется, когда Type Specification (реализация) находится в пакете ADA. Используется как заглушка
  - Bliss block - тип BLOCK из Bliss

  
Поддерживаемые языки (есть свой код):

- Macro
- Macro64
- Fortran
- Bliss
- Cobol
- Basic
- PL/I
- Pascal
- C
- RPG
- Ada
- Scan
- Dibol
- Modula
- Pillar
- C++
- Amacro

Также есть специальная констнта для неизвестного языка.
В этом случае, поддерживаются все языко-независимые записи, а также делаются некоторые предположения-ограничения:

- Можно использовать общие (vanilla-flavored) выражения (expressions)
- Идентификаторы допускают латинские символы, цифры, '$' и '_'
- Для доступа к членам структур используются точки (в документации говорится record component selection) - A.B.C

Поддержка функций:
- Routine Begin/End
- Хранят - название функции, диапазон занимаемых адресов, адрес начала
- Предполагается, что адрес начала также и точка входа
- Если функция не определена (только сигнатура), то для нее отдельная запись Unallocated Routine DST
- Для inline функций - Inline Instance DST
- Для вложенных блоков - Block Begin/End DST (BEGIN/END - Bliss/PL/I, параграфы и секции в COBOL)
- Для пролога и эпилога функций - Prolog/Epilog DST


Представление структур (составных типов):
- Record Begin/End DST
- Каждый член структуры - Data Object DST
- Если есть вложенные структуры, то НЕобязательно, чтобы их DST записи были вложены друг в друга. То есть DST вложенных структур могут хранится на одном уровне с родительскими.
- Отдельно описывается поддержка Variant типа в Pascal - отдельные Variant Begin/End DST с Varint Value DST, определяющими сами варианты типа.

Другие замечания:
- В отличие от других форматов здесь нет отдельной таблицы строк - все строки включаются в записи (хранятся в них)
- Большое количество хаков для разных яп, в частности Bliss

Отображение исходного кода на инструкции:
- Line Number PC-Correlation DST record
- отображение строк кода на PC
- В записи хранятся инструкции, которые необходимо выполнить, чтобы получить готовую таблицу инструкций
- Можно сказать, что это виртуальная машина, в которой есть глобальные переменные: текущие строка, стейтмент, PC и т.д.
- Некоторые команды:
  - Delta-PC - вычисляем отображение текущей строки на адрес инструкции
  - DST$K_SET_PC_W - выставить значение PC в указанное
  - DST$K_SET_STMTNUM - выставляет значение номера текущего стейтмента в указанное

- Имеются специальные Source File Correlation DST записи - позволяют DEBUG отображать исходный код в время отладки. Они тоже содержат в себе команды, которые надо выполнить для получения результирующей таблицы.
- Переменные:
  - LINE_NUM - номер текущей строки
  - SRC_FILE - id текущего файла исходника
  - SRC_REC - номер записи, для поддержки RMS - Record Management Services (набор вспомогательных системных сервисов)
- Некоторые команды:
  - DECLARE - создает соотношение между номером строки и адресом инструкции.
  - DST$K_SRC_DECLFILE - определяет новый файл с исходниками для которого будем создавать соотношения.
  - DST$K_SRC_SETLNUM - выставляет значение LINE_NUM в указанное значение.
  
Таким образом, чтобы получить таблицу соответсвия исходного кода и инструкций, необходимо выполнить программу "своей виртуальной машины".


---

### CodeView

CodeView - это формат отладочной информации используемый и одноименный отладчик на Windows. Этот формат используется в экосистеме - компиляторы Visual C++/C#/VB.NET, Visual Studio debugger, WinDbg. Многим известен тем, что хранится в PDB файлах.

Его спецификация никогда не публиковалась, но [в 2015 году решили подсобить LLVM](https://lists.llvm.org/pipermail/cfe-dev/2015-October/045780.html) и дали первую часть - информация о типах. Далее, создали [репозиторий](https://github.com/microsoft/microsoft-pdb), но он заархивирован год назад, а последние изменения в нем были 8 лет назад.

TODO: добавить ссылку на найденный pdf из open watcom

Дальше буду говорить про формат, а не отладчик.

CodeView использует 2 секции:

- `.debug$T` - секция с типами
- `.debug$S` - секция с символами (все остальное, что не типы)

<spoiler title="Отдельная секция типов">

https://youtu.be/5twzd06NqGU?si=rr6cZW7Tw1pnsUGY&t=590

тут про DAG типов, удаление дубликатов и т.д.

</spoiler>

В `.debug$T` хранятся типы - как примитивные (int, char, double), так и пользовательские (typedef, struct TODO: уточнить).
Информация о типах хранится в виде ацикличного ориентированного графа (DAG):

- Узлы - сами типы
- Ребра - отношение включения типа (использует/ссылается)

У каждого типа есть свой индекс. Если нужно сослаться на какой-то тип, то используется он.
Причем, для наиболее используемых, встроенных типов зарезервированы индексы до 4096 (0x1000), а остальной диапазон под сложные вещи (функции, массивы, пользовательские структуры)

Главная проблема здесь - это циклы. Например, можно сразу определить структуру, у которой поле - ссылка на саму себя.
Эта проблема решается тем, что используется forward declaration.

TODO: визуализация этого графа из слайда https://www.llvm.org/devmtg/2016-11/Slides/Kleckner-CodeViewInLLVM.pdf

> Для создания этих графов используется интересный алгоритм.
> Как он устроен можно посмотреть здесь: TODO: ссылка на видео

<!-- Дальше из книги -->

Каждая таблица - поток записей с переменной длиной.

Поддерживается 2 формата объектных файлов: OMF и COFF. В каждом разное наименование переменных:

- COFF (секции):
  - Типы - .debug$T
  - Символы - .debug$S
- OMF (записи LEDATA)
  - Типы - $$TYPES
  - Символы - $$SYMBOLS
  
Таблица символов - описывает символы.
Таблица типов - типы для символов.

Т.е. таблица символов указывает на таблицу типов, а таблица типов может указывать на саму себя (имеется ввиду на записи указывать).

Для оптимизации производительности используется выравнивание записей.
Если это используется, то в начале таблицы добавляется заголовок `0x00000001`.

Тут также используется абстракция вложенности: модуль -> функция -> блоки -> переменные.
Для оптимизации поиска, записи, которые начинают область (scope) имеют ссылки на своих родителей (чтобы не читать все записи).

Все записи из таблицы типов имеют свои индексы.
Они должны быть строго положительными (больше 0).
0 - особое значение "no type".

Также имеется разделение:

- Частовстречаемые (примитивные) типы имеют индекс меньше 4096 (0x1000)
- Для остальных - остальной диапазон.

Назначение индексов должно быть последовательным, а пропуски запрещены. То есть, индексы идут 0x1000, 0x1001, 0x1002 ... а 0x1000, 0x1003, 0x1004 запрещено.



<spoiler title="Индексы простых типов">

TODO: тут показать SimpleTypeKind - llvm/include/llvm/DebugInfo/CodeView/TypeIndex.h

посмотреть еще может где-то написано где-что зарезервированно (секция 5 должна быть)

</spoiler>

Формат символов:

- Каждая запись имеет общий префикс из 2 записей по 2 бата: длина и тип.
- Далее идут данные, специфичные для конкретной записи.
- Все символы имеют индексы, причем разделены на 5 диапазонов (примеры приведены):
    1. Символы, формат которых не меняется в зависимости от окружения: символы регистров, символы пользовательских типов и т.д.
       - Флаги компиляции
       - Константы и перечисления
       - Название объектных файлов
       - Пользовательские типы
    2. Символы для архитектур с сегментированным режимом адресации 16:16
       - Переменные, хранящиеся на стеке
       - Не экспортируемые символы
       - Глобальные и static функции
       - Области видимости (начало и конец блоков)
    3. Символы для архитектур с сегментированным режимом адресации 16:32 (примеры те же)
    4. Символы, специфичные для MIPS архитектуры или компилятора
       - Глобальные и static функции
    5. Для CodeView оптимизации
       - Глобальные хэш таблицы для функций и переменных

Формат типов:
- У каждой записи есть 2 байтовый префикс - длина.
- Остальная часть - последовательность из "type string" - 2 полей: left (2 байта) и сами данные (зависят от leaf).
- Все leaf разделены на 4 диапазона:
    1. Записи, на которые могут ссылаться из таблицы символов
       - LF_MODIFIER - модификатор типа (const, volatile, unaligned ...)
       - LF_POINTER - типизированный указатель
       - LF_CLASS - класс
       - LF_STRUCTURE - структура
       - LF_PROCEDURE - функции
    2. Записи, на которые НЕ могут ссылаться из таблицы символов, но могут из других записей
        - LF_ARGLIST - аргументы функции
        - LF_DEFARG - значение функции по умолчанию
        - LF_FIELDLIST - список из полей структуры/класса/объединения/перечисления
        - LF_BITFIELD - битовое поле
    3. Используется для создания сложных структур
        - LF_BCLASS - базовый класс
        - LF_MEMBER - поле класса
        - LF_METHOD - функция класса (как перегруженная, так и нет)
        - LF_NESTTYPE - вложенный тип
        - LF_FRIENDCLS - дружественный (friend) класс
    4. Используется для хранения числовых значений. 
       Здесь применили интересный подход: если при обходе записей мы знаем, что дальше должно быть значение, то мы смотрим на следующие 2 байта:
        - Если эти 2 байта меньше 0x8000 - то это нужное нам значение (константа)
        - В противном случае, мы интепретируем это число как leaf:
          - LF_CHAR - 1 байт
          - LF_SHORT - 2 байта
          - LF_LONG - 4 байта
          - LF_REAL32 - 4 байтное с плавающей точкой

Предопределенные примитивные типы имеют индексы меньше 4096, т.е. 0x0FFF и меньше. Вот эти 12 бит используются как битовая маска:

| 11              | 10 - 8 | 7 - 4 | 3               | 2 - 0  |
| --------------- | ------ | ----- | --------------- | ------ |
| Зарезервировано | Режим  | Тип   | Зарезервировано | Размер |

Режим - это режим адресации:
    - Near pointer
    - Far pointer
    - Huge pointer

TODO: добавить ссылку на то, что это

Тип - один из примитивных типов:
    - Целочисленное знаковое
    - Целочисленные беззнаковое
    - Bool
    - С плавающей точкой
    - Комплексное
    - Особый (special)

Размер - интерпретируется в зависимости от поля Тип:
    - Целочисленные и bool - размер в байтах
    - С плавающей точкой - битность (32, 64, 80, 128, 48)
    - Special - это перечисление:
      - Абсолютный символ
      - Сегмент
      - Void
      - Валюта

Для получения таблицы строк исходного кода используется отдельная таблица.

Информация в ней хранится также иерархично: модуль -> файл -> сегменты.
И так для каждого объектного модуля.
Можно представить так:
- Модуль 1
  - Файл 1
    - Сегмент 1
    - Сегмент 2
  - Файл 2
    - Сегмент 1
    - Сегмент 2

Сама информация о корреляции хранится в записи сегмента.
Она имеет такой формат:

| Seg | cPair | offset    | linenumber |
| --- | ----- | --------- | ---------- |
| 2   | 2     | 4 * cPair | 2 * cPair  |

Поля:

- Seg - индекс сегмента
- cPair - количество строк исходного кода (размеры следующих массивов)
- offset - массив адресов начала каждой инструкции (смещение от начала сегмента)
- linenumber - массив номеров строк исходного кода

offset и linenumber - параллельные массивы.

Теперь осталось понять, как это все объединить.

Отладочная информация хранится в исполняемых файлах.

Есть 2 поддерживаемых (точнее описанных) формата исполняемых файлов: OMF и PE. Различие только в том, в каком месте отладочная информация записывается. Но общая разметка не зависит от формата.

Хранение отладочной информации реализовано следующим образом.

Отладочная информация сгруппирована по подсекциям - subsection.
У каждой такой подсекции есть свой индекс - идентификатор, и каждый идентификатор имеет префикс `sst` (SubSection Type).
Например, есть подсекции:

- sstModule - общая информация об объектном модуле: название, количество сегментов и информация о них
- sstTypes - хранит информацию о типах, это и есть `.debug$T`
- sstSymbols - хранит информацию о символах, это и есть `.debug$S` (но есть также и sstPublicSym и sstPublic - они тоже хранят символы, но уже публичные, для линковщика)
- sstSrcModule - информация о строках исходного кода (для соотношения строк и инструкций), таблица исходного кода (TODO: другое название??).

Для каждого модуля имеется свой набор таких подсекций. Но организованы они не иерархично, то есть не sstModule хранит в себе записи sstTypes/sstSymbols, а дальше идет следующий sstModule.

Все записи хранятся в одном большом массиве. Но если посмотреть на заголовки каждой подсекции, то мы заметим, что они не хранят информацию о том, к какому модулю они принадлежат.
Получается одна большая куча.

Информация о принадлежности подсекций к модулям хранится отдельно в специальной подсекции - Directory.
Она хранит массив directory entry - записей, в которых для каждой подсекции хранится ее тип, номер модуля и начало (относительное смещение).

Стоит отменить, что никаких ограничений по расположению подсекций в верхнеуровневом массиве или массиве directory entry - нет. То есть их можно располагать в любом порядке, например, первая будет sstTypes(1), дальше sstSrcModule(5), после sstSymbols(2) - в скобках номер модуля.

В спецификации указывается только *предпочтительный* способ организации - вначале идут sstModule, после для каждого модуля набор подсекций, которые относятся к нему, а в конце подсекции которые ни к кому не относятся.

---

### ADATA

ADATA - это формат отладочной информации, изобретенный специально для HLASM (High Level Assembler), ассемблема IBM.
Этот ассемблер имеет некоторые конструкции, специфичные для высокоуровневых языков, например, поддержка переменных, в качестве операндов могут быть выражения (не нужны отдельные инструкции для их вычислений), различные строковые операции (конкатенация, подстрока, длина) и т.д.

Отладочная информация хранится в виде

Этот формат отладки поддерживает 2 фичи: отображение исходного кода на инструкции и работа с символами.

Вся отладочная информация хранится в отдельном файле - SYSADATA.
Он создается во время компиляции.

Состоит этот файл из последовательности записей.
Каждая запись имеет 12 байтный заголовок:

|               | Lanuage Code | Record Type | Architecture Level | Flag | Edition | Reserved |
| ------------- | ------------ | ----------- | ------------------ | ---- | ------- | -------- |
| Размер, байты | 4            | 2           | 4                  | 1    | 4       | 1        |

Поля:

- Language Code - код исходного языка, пока константа = 16
- Record Type - тип записи
- Architecture Level - уровень архитектуры, в этом случае - версия загловка
- Flag - различные флаги свойств: имеется ли продолжение, endianess ...
- Edition - версия самой записи (содержимого)
- Reserved - зарезервированная область

Есть множество типов записей, но нам будут интересны следующие:

- Source Analysis Record
- Machine Instruction Record
- Symbol Record
- DC/DS Record

Для создания таблицы исходного кода используются Source Analysis Record и Machine Instruction Record.
Здесь стоит вспомнить, что формат создан для "высокоуровневого" ассемблера.
Один из аспектов высокоуровневости - поддержка макросов, они могут создавать более 1 инструкции, поэтому необходимо знать соответствие исходного кода и ассемблера.

Source Analysis Record позволяет нам сопоставить исходный код с инструкциями. Эта запись позволяет сопоставлять 1 строку исходного кода с инструкциями.

Здесь стоит вспомнить, что формат создан для "высокоуровневого" ассемблера.
Один из аспектов высокоуровневости - поддержка макросов, они могут создавать более 1 инструкции, поэтому необходимо знать соответствие исходного кода и ассемблера.

Поэтому, эта запись, во-первых, имеет смысл, во-вторых, имеет множество подтипов:

- Комментарий - описывает строку комментария
- Инструкция - описывает строку, которая 1 на 1 отображается в инструкцию
- Стейтмент - описывает строку, которая может отобразиться на несколько ассемблерных инструкций. Это можно назвать стейтментом, а пример - условые инструкции, например, условное копирование
- Вызов макроса - вызов макроса
- Определение макроса - описывает реализацию макроса

Эта запись генерируется для каждой строки в каждом файле исходников.
Формат записи одинаковый независимо от типа строки, поэтому некоторые поля могут не использоваться.

Сам адрес инструкции хранится в поле Location Counter - IBM-специфичный аналог PC.

Также есть Machine Instruction Record - запись, которая содержит сгенерированный машинный код. Она идет после Source Analysis Record, если инструкции были сгенерированы.

Таким образом, нам необходимо просто прочитать все Source Analysis записи и получить из них пары строка файла - Location Counter.

> Также стоит отметить, что обе записи в себе содержат копию исходного кода или ассемблерных инструкций, поэтому они самодостаточны, т.е. можно воссоздать весь исходник с помощью файла отладочной информации

Другая запись - Symbol Record.
Она хранит в себе информацию о символе.

Еще один аспект "высокоуровневости" - переменные.
Для их создания используется отдельный стейтмент - DS, Define Storage.
Переменная тоже является символом, поэтому будет влючена в эту запись.

Но HLASM - безтиповой. Это общее с ассемблером, поэтому записей для информации нет.

Все эти записи хранятся в файле SYSADATA, который генерируется во время компиляции.
В документации он называется Associated Data File.
Записи в файле организованы следующим образом.

- `Compilation Unit Start`
- Вспомогательные записи
- Основные записи
- `Compilation Unit End`

Compilation Unit Start/End - это записи обозначающие границы единицы компиляции. Вся информация по каждому CU хранится внутри них.

В начале имеется несколько вспомогательных записей. Они хранят некоторые метаданные, например, Options Record - показывает с какими флагами была запущена компиляция.

Дальше идут уже записи для отладки.
Source Analysis, Machine Instruction и Symbol записи хранятся здесь.

> В примерах, все записи были в порядке следования стейтментов исходного кода, но в документации я не нашел должен ли быть такой порядок.
> Как минимум, есть очерки, что после Source Analysis должен идти Machine Instruction

---

### IEEE-695

IEEE-695 - это формат объектного модуля, разработанный для встраиваемых систем (MUFOM - Microprocessor Universal for Object Modules).

Эта спецификация проприетарная и платная.
[Официально](https://www.stdlink.com/standards/ieee-695-1990.html) - 86$ (примерно 7500 рублей).

Я ее не покупал и в интернете в открытом доступе не нашел.
Но, так как это спецификация, то есть множество реализаций - документация для них есть в свободном доступе.

Например, [эта реализация](https://github.com/z88dk/techdocs/blob/master/miscellaneous/ieee_695_v4.1_object_file_format.pdf) от Microtec и HP.
Я буду считать ее рефернсной, так как именно они (компании) положили основу формату и создали пропозал в IEEE.
Дальше будет описание именно их реализации.

Отладочная информация хранится в отдельной части модуля - Debug Information Part.

Вся информация хранится в записях.

Информация о типах хранится в записи TY.
Формат этой записи

| Маркер    | Индекс типа   | Маркер    | Индекс названия | Код          |
| --------- | ------------- | --------- | --------------- | ------------ |
| 0xF2      | число         | 0xCE      | число           | число        |
| Константа | Не меньше 256 | Константа | Не меньше 32    | Перечисление |

- Есть 2 поля маркер - это константы. Если первый указывает на тип самой записи, то зачем 2-ой маркер - не знаю.

- Индес типа - это индекс этого типа в глобальной таблице типов.
    В этой таблице хранятся все типы, которые используются в программе.

- Индекс названия - это индекс NN записи.
    NN запись - это грубо говоря пара из числа (глобального индекса) и строки (названия).
    Ее используют не только для названий типов, например, для переменных или номеров строк.

- Код - это маркер самого типа, дискриминатор.

Есть несколько кодов типов (определяются ASCII символами):

- '!' - неизвестный тип
- 'A' - массив
- 'a' - массив из FORTRAN (он в column-major порядке)
- 'Z' - массив (TODO: разница?? что значит with 0 lower bound)
- 'N' - перечисление
- 'E' - простое перечисление
- 'O' - small указатели
- 'P' - large указатели
- 'R' - диапазон (range)
- 'S' - структура
- 'G' - структура с битовыми полями
- 'U' - объединение (union)
- 'X' - внешняя процедура (объявление)
- 'V', 'v' - void
- 'c', 'd' - комплексное и двойное комплексное
- 'f' - название файла (Pascal)
- 'g' - битовое поле
- 'n' - квалификатор (const, volatile)
- 's' - множество (set)
- 'x' - процедура с зависимостями компилятора

Дальнейшие поля записи зависят от кода типа.
Например, для структуры ('S') и для объединения ('U') дальше идет массив из тройки полей:

- Название поля - хранится простой строкой
- Индекс типа - индекс в глобальной таблице типов
- Размер типа - размер в байтах, причем для пользовательских типов можно указывать размер в битах (т.е. не кратный байтам).

Таким образом, структура/объединение - это просто массив таких троек.

TODO: ссылка функция парсинга - binutils/ieee.c:parse_ieee_ty

Информация о структуре программы хранится в отдельной части объектного файла - Debug Information Part.

Она содержит в себе блоки.
Каждый блок - это информация по какой-то логической части исходной программы,
например, определение глобальной функции.

Блоки определяют область (начало и конец), которая может содержать другие записи/блоки.
Границы размечаются `BB$` и `BE$` - Block Begin и End, а `$` - номер типа:

- 1 - типы в локальной видимости
- 2 - типы в глобальной видимости
- 3 - модуль
- 4 - глобальная функция (подпрограмма)
- 5 - строка исходного кода
- 6 - локальная функция (подпрограмма)
- 10 - дебаг информация для ассемблера
- 11 - TODO: ???
- 20 - информация для библиотеки

> Дальше буду говорить *BB$*, вместо *блок типа $* - так короче, да и в
> документах и коде используется такой подход.

Для включения блоков есть правила.
Например, BB3 может содержать в себе BB4 (модуль определяет глобальную функцию), но наоборот - нет, что вполне логично.

Для получения информации о типах используются BB1 и BB2 блоки.
Они содержат TY и NN записи, описанные ранее.

Для получения таблицы строк используется блок BB5 - File name for source line numbers.

Вот так выглядит заголовок блока BB5:

| Маркер начала | Размер блока в байтах | Название файла | Штамп     | Маркер NN | Номер файла | ID файла |
| ------------- | --------------------- | -------------- | --------- | --------- | ----------- |
| BB5           | int                   | string         | Timestamp | NN        | int         | string   |

Заметки:

- Размер блока в байтах может быть 0 - значит неизвестен размер
- Название файла - абсолютный путь
- Штамп содержит в себе дату и время компиляции: год, месяц, число, час, минута, секунда
- ID файла в коде везде пустая строка

> Последние 3 поля образуют 1 запись NN. В стандарте MRI/HP отмечается, что такая запись
> должна быть единственной на каждый файл исходного кода, но не могу сказать, есть
> ли в самом стандарте IEEE такое ограничение.

Дальше идет множество записей о строке исходного кода. Каждая логическая запись
состоит из 2 отдельных записей: ATN и ASN.

ATN - id строки -> номер строки в файле

| Маркер ATN | Индекс символа | Тип символа | Дескриптор атрибутов | Номер строки | Номер столбца |
| ---------- | -------------- | ----------- | -------------------- | ------------ | ------------- |
| 0xF1CE     | int            | 0           | 7                    | int          | 0             |

Замечания:

- Указанные конкретные значения взял из кода. Они специфичны для ATN номеров строк.
- Дескриптор атрибутов можно интерпретировать как подтип ATN - он определяет
  сколько будет дальше полей и каков их смысл. Для номеров строк используется
  значение 7, но есть и другие, например, 3 - статическая переменная.
- Номер столбца 0, т.к. в коде нет возможности получить номер столбца, только номер строки.

ASN - id строки -> адрес инструкции

| Маркер ASN | Индекс строки | Адрес инструкции |
| ---------- | ------------- | ---------------- |
| 0xE2CE     | int           | int              |

Для воссоздания таблицы символов нужно прочитать все записи из BB5 для каждого
файла.

TODO: в конце ссылки на другие источники и на сам пропозал (найти ссылку)

---

- IMB 360 object format
- FPO
- MISC
- PDB


> TODO: тут про разницу между -g и -ggdb (что делают, когда разница заметна)

[ ] Форматы символов (обзор)
[ ] Общие поля для отладочных символов (строки, исходный код, типы и т.д.)
[ ] Небольшой обзор DWARF

TODO: создать граф форматов - кто от кого отпачковался и т.д.


## Шагаем по коду

- По инструкциям
- По исходному коду (step in, step out, step over) - как каждый можно реализовать

## Исследуем gdb

- Обзор архитектуры
- Как step in/out/over реализованы
- Замечание по поводу отступов (не соблюдаются)
- Детали реализации интересные

# Особенности управляемых языков

Тут про C#, java, javascript, python и другие яп.
Как в них работает отладка, какие особенности, м.б. покопаться в исходниках

# Другие платформы

Windows, FreeBSD, ColibriOS (???)

# Среды разработки

VS Code, CodeBlocks
Как различные IDE взаимодействуют с отладчиками - м.б. есть общий протокол работы с ними


TODO: jit реализован через ptrace ?
