# Как работают дебаггеры

О чем написать:

1. Ядро работы дебагера: `ptrace` + `INT 3`
2. Попробовать написать свой дебаггер
   - Простой интерфейс
   - DWARF формат попробовать распарсить (и дебажиться по строчкам)
   - Фича - откат истории
3. Как работают в управляемых ЯП (байт-код, jit, C#, java, python)
4. Особенности различных платформ
   - Windows
   - FreeBSD
   - М.б. другие платформы
5. Как это работает в VS Code (про этот интерфейс рассказать на примере gdb)
6. Фичи некоторые:
   1. GDB вызывает функции как
   2. Развертка стека
7. Некоторые ответы на вопросы
   1. При attach есть настоящий родитель, а есть приаттачившийся - как получать уведомления (waitpid)?
   2. Цикл при отладке - один другого и наоборот отлаживает (https://habr.com/ru/articles/439882/)?
   3. Профилировщики используют `ptrace`?


# Ядро

Поинты:
- Все вокруг ptrace и int 3
- Сказать что буду на x86 рассказывать + в конце то как на других архитектурах это реализуется (м.б. есть особенности хз)
- ptrace - это системный вызов
- int 3 - это инструкция для генерации прерывания
- брейкпоинт - это по факту прерывание
- он специально сделан однобайтовым + пример где это может выстрелить если не однобайтовый
- PEEK and POKE рассказать
- БП только для инструкций - для строк и т.д. нужны отладочные символы
- Что если к завершенному потомку чужому приаттачиться? Все получат результат или только кто-то один (exit code потомка) 
- `strace` использует `PTRACE_SYSCALL` (найти код)

Весь процесс дебагинга крутится вокруг 2 вещей:
- `ptrace`
- `INT 3`

`ptrace` - это системный вызов, который используется для отслеживания процесса (**p**rocess **trace**). 
Интерфейс следующий:

`long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);`

Можно заметить сходство с другими вызовами по типу `ioctl` или `fcntl` - код запроса (перечисление `__ptrace_request`), идентификатор объекта (`pid`) и вспомогательные данные (`addr`, `data`).

> Понимаю, что на этом вызове много обязанностей и трудно придумать более тонкий вариант, но это как-то контрастирует с философией Unix - `делают что-то одно`. 
> Может я прикапываюсь.

Благодаря этому системному вызову можно:
- `PTRACE_CONT`/`PTRACE_SINGLESTEP` - Получить контроль над выполнением
- Прочитать и изменять:
  - `PTRACE_GETREGS`/`PTRACE_SETREGS` - Регистры
  - `PTRACE_PEEKDATA`/`PTRACE_POKEDATA` - Память и код
  - `PTRACE_PEEKUSER`/`PTRACE_POKEUSER` - TODO: придумать как назвать
  - `PTRACE_SET_THREAD_AREA` - Локальные данные потока (TLS)
- `PTRACE_SET_SYSCALL` - Подменять вызываемые системные вызовы
- `PTRACE_SECCOMP_GET_FILTER` - Получать информацию о [seccomp](https://man.archlinux.org/man/seccomp.2.en)

<spoiler title="PEEK & POKE">

TODO: тут про peek & poke написать

</spoiler>

Для начала рассмотрим общий взгляд на процесс отладки. Грубо говоря, процесс отладки итеративный и каждую итерацию можно представить в виде 3 шагов:

1. Ждем точку останова
2. Выполняем необходимые действия 
3. Продолжаем работы

Рассмотрим каждый шаг.

> Далее буду использовать терминологию из man: `tracer` - отладчик, `tracee` - процесс, который отлаживаем

## Ждем точку останова

Первое - нам необходимо дождаться остановки tracee. 
Пока представим, что она есть и рано или поздно tracee до нее дойдет.

Главный принцип работы `ptrace` можно описать так: tracee получает сигнал и останавливается, а tracer в этот момент получает контроль, что-то делает и продолжает работу tracee.
Для ожидания этого сигнала tracer использует `waitpid`.

TODO: надо ли оставлять?
> Раньше я думал, что этот системный вызов нужен для ожидания завершения дочернего процесса, но, в общем случае, он используется для отслеживания изменения статуса потомка (wait for state changes in child of the calling process, как написано в man'е).

И сам смысл точки останова в следующем:

> tracee останавливается каждый раз, когда *получает сигнал* (любой), а tracer в это время пробуждается и *`WIFSTOPPED`*, вызванный на полученном статусе, возвращает `true`. 

То есть, отслеживаемый процесс получает любой сигнал, в этот момент останавливается и `waitpid` возвращается с соответствующим статусом. 

Ждать остановки tracee требуется обязательно - практически все `ptrace` вызовы, которые изменяют состояние tracee, вернут `ESRCH`, если будут вызваны над работающим процессом. С одной стороны, ограничение - нельзя вставить палку в колеса едущему велосипеду, но, с другой, интересно было бы посмотреть что случиться. Если кратко, то только 5 команд не требуют остановленного состояния, но и они используются для начала и окончания процесса отладки. Об этих командах можно посмотреть в секции Informational and restarting ptrace commands в `man 2 ptrace`.

<spoiler title="Разные статусы остановки">

TODO: описать


тут про то, что 
- всего есть running и stopped состояния, причем заблокирован сисколом = running
- ptrace-stop имеет множество подклассов
- 


</spoiler>

Когда `waitpid` вернулся, то необходимо проверить его статус. Грубо говоря, статус можно разделить 2 случая - останов и конец работы процесса. Определить это можно по упомянутому выше `WIFSTOPPED`. С учетом того, что останавливаться будем множество раз, то код отладчика в общем случае можно представить следующим образом:

```cpp
pid_t pid;
int wstatus;
while (1)
{
    /* 
     * Ждем остановки tracee 
     */
    pid_t ret_pid = waitpid(pid, &wstatus, 0);
    if (!WIFSTOPPED(wstatus))
    {
        /* 
         * Процесс завершил работу
         */
        break;
    }

    /* 
     * Выполняем необходимые действия
     * ...
     */

    /* 
     * И продолжаем работу
     * ...
     */
}
```

## Основные манипуляции

На этом моменте, tracee остановлен, а нам (дебаггеру) вернули управление из `waitpid`. 
Представим, что точка останова сработала и процесс не завершил свою работу. 
Теперь начинается самое интересное - процесс отладки: просмотр и изменение состояния tracee.

Команды, которые призваны получать и изменять состояние tracee, в документации называются информационными (informational). Есть множество аспектов процесса, которыми мы можем управлять и для них есть по 2 команды (`PTRACE_*`) - для чтения и записи. 

Сейчас нас будут интересовать только `PTRACE_PEEKTEXT`/`PTRACE_POKETEXT` и `PTRACE_GETREGS`/`PTRACE_SETREGS`. Первая команда используется для получения и изменения данных и кода процесса, а вторая - для регистров.

> Дополнительно есть `PTRACE_PEEKDATA`/`PTRACE_POKEDATA`.
> Эта команда должна работать с данными процесса (областью памяти), а `PTRACE_PEEKTEXT`/`PTRACE_POKETEXT` - с секцией кода (`.text`).
> Но, как описано в man, у линукса адресное пространство данных и кода единое, поэтому обе команды выполняют одно и то же.

В сигнатуре `ptrace` используется 4 аргумента: первые 2 для идентификации процесса и операции, а вторые 2 - для передачи специфичных для конкретной операции параметров. В частности, передаются 2 указателя. Их семантика отличается от команды к команде, а некоторые команды используют только часть, либо не используют эти параметры вообще, поэтому для каждой команды надо смотреть отдельно.

Для примера, если `rax` равен 0, то записать число 1 (4 байтное число), по адресу из регистра `rbx`. Реализовать это можно следующим образом:

TODO: проверить

```cpp
struct user_regs_struct regs;
ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
if (regs.rax == 0)
{
    void *addr = (void *)regs.rbx;
    long data = ptrace(PTRACE_PEEKTEXT, child_pid, addr, NULL);
    *((int *)&data) = 1;
    ptrace(PTRACE_POKETEXT, child_pid, addr, (void*)data);
}
```

Обратите внимание на то, как записывается число 1.
Загвоздка в том, что команды `PEEKTEXT` и `POKETEXT` работают с машинным словом, грубо говоря, оперируют размером указателя.
У меня 64-битная машина, поэтому его размер 8 байтов, а записываю я 4-х байтное.
Если бы я хотел записать 8 байтное (`long`), то мог бы сделать это проще, без read-modify-write.

```cpp
struct user_regs_struct regs;
ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
if (regs.rax == 0)
{
    void *addr = (void *)regs.rbx;
    long data = 1L;
    ptrace(PTRACE_POKETEXT, child_pid, addr, (void*)data);
}
```

Ну и вообще, вся работа с памятью (чтение и запись) ведется подобным образом - читаем необходимый диапазон памяти по машинному слову и после записываем также по машинному слову.

## Продолжение работы

Когда все необходимые действия выполнили, то надо продолжить работу процесса.
Сделать это можно 2 способами:

- `PTRACE_SINGLESTEP` - Выполнить только 1 инструкцию
- `PTRACE_CONT` - Продолжить выполнение

Логично, что следующая остановка у первой команды будет у начала следующей инструкции, а у второй - при следующем сигнале.

## Изначальный запуск

Последнее, что мы не покрыли - как начинается процесс отладки.
Тут также есть 2 варианта:

- Сами запускаем процесс для отладки
- Присоединяемся к уже работающему процессу

### Самостоятельный запуск

Для самостоятельного запуска есть следующий паттерн:
1. Форкаемся
2. Потомок вызывает `ptrace(PTRACE_TRACEME, 0, NULL, NULL)` и запускает `exec**` с нужной программой
3. Родитель постоянно вызывает `waitpid` с пидом потомка и ждет, пока не сработает очередная точка останова

Т.е. примерно так

```c++
void child_main()
{
    /* 
     * Позволяем родителю отслеживать себя
     */
    ptrace(PTRACE_TRACEME, 0, NULL, NULL);
    /* 
     * Запускаем отлаживаемую программу
     */
    execlp("executable", "arg1");
}

void parent_main(pid_t child)
{
    int wstatus;
    while (1)
    {
        /* 
         * Ждем остановки потомка
         */
        waitpid(child_pid, &wstatus, 0);
        if (!WIFSTOPPED(wstatus))
        {
            /*
             * Потомок завершил работу
             */
            break;
        }
        /*
         * Выполняем необходимые действия над потомком
         */
        perform_actions(child_pid);
        /* 
         * Продолжаем его работу
         */
        ptrace(PTRACE_CONT, child_pid, NULL, NULL);
    }
}

int main()
{
    pid_t child_pid;
    if ((child_pid = fork()) == 0)
    {
        child_main();   
    }
    else
    {
        parent_main(child_pid);
    }
}
```

### Присоединяемся к запущенному процессу

Если какой-то процесс уже запущен и мы хотим его отладить, то для этого используется уже другой вызов - `PTRACE_ATTACH`.


При присоединении к другому процессу через `PTRACE_ATTACH` отлаживаемому процессу посылается `SIGSTOP` - это нужно, чтобы мы могли остановить процесс и поработать с ним.
Системные вызовы могут вернуть `EINTR`, когда они прерываются сигналом.
Поэтому, можно сказать, что `PTRACE_ATTACH` создает этот `errno`.

Пример такой:

```c++

int main()
{
    int wstatus;
    pid_t child_pid = obtain_pid();
    ptrace(PTRACE_ATTACH, child_pid, NULL, NULL);
    while (1)
    {
        waitpid(child_pid, &wstatus, 0);
        if (!WIFSTOPPED(wstatus))
        {
            /*
             * Потомок завершил работу
             */
            break;
        }
        /*
         * Выполняем необходимые действия над потомком
         */
        perform_actions(child_pid);

        /* 
         * Продолжаем его работу
         */
        ptrace(PTRACE_CONT, child_pid, NULL, NULL);
    }
}
```


Если нам НЕ нужно останавливать процесс после присоединения, то для этого используется `PTRACE_SEIZE`.
В этом случае, нам становится доступна еще одна команда - `PTRACE_INTERRUPT`. 
Как понятно из имени, он нужен для прерывания потока.
В man'е описано 4 варианта развития событий при выполнении этой команды: 
- При выполняющемся системном вызове этот вызов вернет `EINTR`
- Уже остановленный, но при применении `PTRACE_LISTEN`
- При конкурентном событии остановки
- Все остальные случаи
  
TODO: может добавить этот пример?
Пример для `PTRACE_SEIZE` оставляю на читателя.

## Собирая детали вместе

На этом моменте, в голове уже имеется общая картина, того как работают отладчики: процесс останавливается сигналом, мы его препарируем и продолжаем его работу.

Давайте сделаем свой небольшой пример использования.
Я придумал такой: приложение для складывания 2 чисел.
Ему через аргументы передаются эти 2 числа, он их складывает и печатает ответ.
Наша задача заключается в том, чтобы поменять одно из слагаемых таким образом, чтобы сумма осталась корректной, но одно из слагаемых (я возьму правое) поменялось.
Грубо говоря, прямо перед выводом результата присоединиться и изменить значение переменой слагаемой.
Звучит просто, давайте напишем.

Вначале бизнес-логика. 
Здесь все просто:

- Через argc/argv передаются аргументы
- С помощью `atol` парсим второй и третий аргументы (первый - название программы)
- Складываем 
- Выводим с помощью `printf`

Тут даже особо думать не надо. 
Можно набросать так:

```c++
int main(int argc, const char **argv)
{
    if (argc != 3)
    {
        return 1;
    }

    int left = atol(argv[1]);
    int right = atol(argv[2]);
    int sum = left + right;
    printf("%ld + %ld = %ld\n", left, right, sum);
    return 0;
}
```

Теперь надо подумать над тем, как сделать так, чтобы `right` изменился между суммой и вызовом `printf`.
Вспомним, что потомок замораживается, когда получает сигнал, причем любой.
Это сделать можно вызовом `raise` - просто передаем ему нужный сигнал и все.
Я использую `SIGCHLD`, т.к. по умолчанию он игнорируется и процесс не упадет, если его (сигнал) не обработать.
Как-то так:

```c++
int sum = left + right;
raise(SIGCHLD);
printf("%ld + %ld = %ld\n", left, right, sum);
```

Но не тут-то было.
Проблема в данном случае - определить где значение эта переменная хранится.
Я запускаю этот код на Linux, на нем используется System V ABI.
То есть, я знаю в каких регистрах должны хранится аргументы для `printf`, но опять проблема - в процессе вызова самого `raise` эти регистры затрутся аргументами для внутренних функций.
Короче говоря, это проблема.


Я не придумал ничего лучше, чем переписать все на ассемблере и сделать следующие ходы:

- Переменные `left`, `right` и `sum` теперь хранятся на стеке
- Так как этим стеком управляю я, то знаю на каком смещении от `rbp` какая переменная хранится
- Сам адрес `rbp` я сохраняю во внешнем файле, который читает отладчик

Честно говоря, это моя первая программа на ассемблере, поэтому ее качество оставляет желать лучшего:

<spoiler title="Код tracee на ассемблере">

Я использовал ассемблер GAS и синтаксис AT&T

```assembler
TODO: код
```

</spoiler>

Также имеется и отладчик.
Он делает то, что нужно - дожидается остановки tracee, читает файл с адресом и изменяет переменную.
Тут ассемблер уже не нужен.

<spoiler title="Код tracer">

```c++
TODO: код
```

</spoiler>

Да, это все было сложно и муторно - сколько всего пришлось сделать, чтобы просто поменять значение переменной.
Но есть хорошие новости - этот процесс можно очень легко упростить.
Помните, что мы останавливаемся на каждом сигнале. 
Вот была бы такая вещь, которая просто создаст сигнал и все.

Хорошая новость - она есть!

<spoiler title="Другие попытки этой реализации">

- через SIGFPE и деление
- простой вызов `raise`

</spoiler>

## int 0x3

`int 0x3` - это инструкция, которая создает нужный нам сигнал:

- `int` - это ассемблерная инструкция, генерирующая программное прерывание. Она принимает на вход аргумент
- `0x3` - номер прерывания для точки останова

Сейчас я говорю про архитектуру x86.
Она определяет [таблицу (вектор) прерываний](https://wiki.osdev.org/Interrupt_Vector_Table#:~:text=On%20the%20x86%20architecture%2C%20the,older%20software%20(e.g.%20MS-DOS%20programs)).

Когда процесс доходит до этой инструкции, то генерируется программное прерывание, которое приводит к получению `SIGTRAP`.
И вот в момент его получения мы можем получить контроль над процессом.

Давайте перепишем предыдущий код, но теперь уже с этой инструкцией.

<spoiler title="Код tracee на ассемблере">

```assembler
TODO: код
```

Заметьте, что в начале регистрируется обработчик `SIGTRAP`.
Я преследовал такую логику, чтобы этот сигнал не влиял на работу без отладчика. 
Грубо говоря, если нет отладчика (нашего), то все работает, но если запуск под ним, то логика меняется как хотим.



</spoiler>

Код tracer'а изменится соответственно

<spoiler title="Код tracer'а">

```c++
TODO: код
```

</spoiler>

<spoiler title="SIGTRAP особенный">

Тут рассказать про то, что некоторые сигналы игнорировать нельзя и если это сделать, то по умолчанию они станут в SIG_DFL

Табличку построить, что и когда происходит (hard, soft / int3, raise)

man 7 signals -> BUGS -> Сигналы которые перечислены будут доставляться всегда, если вызваны hardware (грубо говоря), SIGTRAP там тоже есть

Показать список сигналов, которые просто сбросят SIG_IGN/block (взять из force_sig)

Запись в interrupt descriptor table для int3 - https://github.com/torvalds/linux/blob/ec9eeb89e60d86fcc0243f47c2383399ce0de8f8/arch/x86/kernel/traps.c#L735

Сам обработчик, который выставляет SIG_IGN в SIG_DFL - https://github.com/torvalds/linux/blob/master/kernel/signal.c#L1326

</spoiler>

В общем, можно сказать что все готово - брейкпоинты реализуются через `int 0x3` инструкцию, можно заканчивать.
Но есть последний момент, который надо обсудить - где и как эту инструкцию вставлять.

Сейчас я написал все на ассемблере и у меня был полный контроль над исходным кодом.
Но 1) почти все пишут на более высокоуровневых ЯП и машинные инструкции там использовать нельзя, 2) не всегда есть доступ к исходному коду.
То есть просто так вставить `int 0x3` и вызвать нужное прерывание в готовом бинарнике мы не можем.
Как быть в этой ситуации?

Ответ прост - затереть инструкции.

## Как ставятся точки останова

В реализации точек останова, грубо говоря, 2 основных алгоритма: ее выставление и момент захода в нее.

Выставление точки останова:

1. Получаем адрес нужной нам инструкции
2. Пишем поверх нее инструкцию `int 0x3` (запоминаем что затерли!)

Заход в точку останова:

1. Точка останова срабатывает
2. Tracer подготавливает окружение:
   1. Получает управление
   2. Восстанавливает затертую инструкцию
   3. Переходит к предыдущей инструкции
3. Tracer выполняет необходимые манипуляции
4. Tracer продолжает выполнение tracee

Для tracee это все происходит прозрачно - кроме сигнала практически нет внешних эффектов.

Кто-то может спрость "как так? секция `.text` недоступна для записи!".
Да, но только для пользовательского пространства, а в случае с `ptrace` - 1) часть ядра, 2) может выполняться только если выполняется с полученными привилегиями.
Короче говоря, с помощью `ptrace` можно изменять и секцию `.text`.
Вы могли заметить команду `PTRACE_POKETEXT` - как можно догадаться это она изменяет код программы (то что по переданному адресу находится).

Но и тут не все, есть еще один важный момент.
Не забываем, что `int 0x3` - это всего лишь инструкция ассемблера, а ассемблер != машинные инструкции, то есть отображение не всегда однозначное.
И тут мы приходим к последнему аспекту.

## Однобайтная инструкция `int 0x3`

Может показаться что `int 0x3` - 2 байтная инструкция (команда + аргумент), но на практике она занимает *1 байт* - `0xCC`.

TODO: проверить
> Можно использовать и 2 байтную инструкцию - `0xCD 0x03`. Она тоже сработает.

Почему это важно?
Достаточно рассмотреть такой частный случай: проверка аргументов в начале функции.

На C это можно реализовать так:

```c++
/* 
 * Пользователь обновил свой интервал бронирования номера - нам нужно уведомить об этом других
 */
void notify_user_rest_interval(long start, long end)
{
    if (start == end)
    {
        /* 
         * Однодневный интервал пропускаем для оптимизации
         */
        return;
    }

    /* 
     * Уведомляем по телеге
     */
    notify_telegram();
}
```

После компиляции, мы можем получить такой ассемблерный код (справа машинный код):

```assembler
notify_user_rest_interval:
    cmpq %rdi, %rsi         # 48 39 FE
    jnz pass                # 75 01
    ret                     # C3
pass:
    call notify_telegram    # e8 00 00 00 00                   
```

Теперь представим, что `int 0x3` занимает 2 байта и мы хотим поставить точку останова прямо на `return`/`ret`.
То есть отловить все моменты, когда вызов "не совсем оптимальный".
Что произойдет?
Заметим, что `ret` - однобайтная и если ее перетереть нашим 2-х байтным `int 0x3`, то это затронет следущую инструкцию - `call`.
TODO: как правильно назвать первый байт инструкции
Учитывая что первый байт инструкции - ее `opcode` (тип команды), то будет 

Если обобщить, то 2-х байтный код для точки останова для 1 байтной команды может переписать следущую инструкцию и сделать ее невалидной, что приведет к проблемам при переходах (семейство инструкций `jmp`, `call` и т.п.).
Поэтому 1 байт для инструкции точки останова всегда затронет, только необходимую инструкцию и не повлияет на последующую функциональность.

TODO: по другому оформить
Замечания:
- Хотел адаптировать пример из Eli, но стр. 14 [AMD Reference](https://tc.gtisc.gatech.edu/cs6265/2016/refs/amd64-vol3-inst.pdf) указывает, что 1-байтных инструкций для INC/DEC больше нет (только режим совместимости)


Но для наглядность посмотрим, что будет при 2 байтной инструкции.

```assembler
    notify_user_rest_interval:
    cmpq %rdi, %rsi         # 48 39 FE
    jnz pass                # 75 01
    int $3                  # CD
pass:
    addl (%rax), %eax       # 03 00 
    addb %al, (%rax)        # 00 00  
    n/a                     # 00
```

Здесь важно заметить, что для `call` я ранее передавал нули, так как реальный адрес появится только во время выполнения.
Поэтому для примера я также использую нули.

И уже тут можно заметить, что:

1. Вызов функции `notify_telegram` исчез
2. Добавились новые инструкции, которые изменяют содержимое регистров (наше состояние), причем скорее всего мусором, так как используется `rax` - регистр для результата функции (не инициализирован)
3. В конце вообще появилась некорректная инструкция `00` - обозначил n/a


В данном случае, мы хотябы словим `SIGILL` за счет последней некорректной инструкции и ничего плохого не сделаем.
Но с учетом того, что адрес будет случайным (спасибо ASLR), то на месте мной указанных появятся случайные инструкции и тогда будь что будет.

---

Вот теперь, можно сказать, что тему ядра отладчиков покрыли.
Суммируя:

1. Вся магия заключена в комбинации системного вызова `ptrace` и инструкции `int 0x3`
2. Отладчик просто ждет пока потомок не остановится при возникновении очередного сигнала
3. Для создания этого сигнала используется `int 0x3`, которая создает `SIGTRAP` сигнал
4. Точка останова - это `int 0x3` записанная поверх исходных инструкций и, когда до нее доходим, восстанавливаем исходные инструкции и ступаем на 1 инструкцию назад

Надеюсь, объяснил понятно.
Но это только вершина айсберга - я хочу копнуть немного глубже.

# Детали работы отладчиков

Ранее мы работали только с инструкциями, но обычно мы работаем с исходным кодом.
Мост, соединяющий эти 2 мира - отладочные символы.

## Отладочные символы

Скорее всего, вы и так уже знаете что такое отладочные символы.
Это специальные символы (symbols), которые добавляют некоторую полезную информацию, относительно исходного кода.
Например, переменные и их типы, разметка структур, отображение инструкций на строки исходного кода и т.д.

Существует множество форматов. Я чаще всего слышал про DWARF (в контексте *nix) и PE-COFF (в контексте Windows):

TODO: написать что-нибудь про них
- DWARF - Debugging With Arbitrary Record Formats
- PE-COFF - Portable Executable COFF)

TODO: Про BPF - https://habr.com/ru/articles/514736/ 

Кроме них я нашел и другие:

TODO: полезно - https://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf

TODO: все тезисы проверить

### STABS

[STABS](https://sourceware.org/gdb/current/onlinedocs/stabs.html) (Symbol TABle Strings) - один из первых форматов отладочных символов (1980-е). Название исходит из того, что все данные для отладки хранились в виде простых строк в таблице символов объектного файла (тогда еще `a.out` - не ELF).

Изначально создавался для pdx - дебаггера Pascal. Сейчас поддерживается и для других языков.

Вся отладочная информация хранится в специальных таблицах символов - stab. Для разной информации имеются разные директивы ассемблера:

- `.stabs` - строковая информация: функции, структуры, строки исходного кода, глобальные переменные (используется чаще всего)
- `.stabn` - числовая информация (скорее та, для которой не нужны строки): общее количество символов, адрес `catch` для GNU C++ (`N_CATCH`)
- `.stabd` - то же, что и `stabn`, но значение - текущая строка (явно не указывается значение): (примеров не нашел)

TODO: где использовался/кто поддерживает

### OMF

[OMF](https://refspecs.linuxfoundation.org/elf/TIS1.1.pdf)(\[Relocatable\] Object Module Format) - это на самом деле формат объектных файлов, а не отладочной информации. 
Но поддержка отладочной информации в нем явная - отдельные, "well-known" записи.


Объектный файл представляется в виде последовательности записей, каждая из которых состоит из 4 "полей":

|               | Тип                                     | Длина                                       | Данные                                             | Чек-сумма                      |
| ------------- | --------------------------------------- | ------------------------------------------- | -------------------------------------------------- | ------------------------------ |
| Размер (байт) | 1                                       | 2                                           | N                                                  | 1                              |
| Описание      | Определяет какие данные содержит запись | Длина оставшейся части (Данные и Чек-сумма) | Сама полезная нагрузка. Содержимое зависит от Типа | Чек-сумма всех остальных полей |

Как можно заметить, поле тип определяет содержимое записи.
В TIS определили 28 типов записи. Например, запись PUBDEF (PUBlic DEFinitions) определяет список экспортируемых (глобальных) символов.
Но пока сфокусируемся на отладке.

Для отладки можно использовать следующие записи:

- LINNUM - Отображение строк исходного кода, на адреса машинных инструкций
- LINSYM - Отображение функций на строки исходного кода (вместе с LINNUM позволяет понять адрес начала функции)
- PUBDEF, LPUBDEF - Функции и переменные - глобальные и локальные (в зависимости от префикса L). Можно сказать, что разница в том указывается ли `static` или нет
- COMDEF, LCOMDEF - Общие (communal) переменные - неинициализированные статические или те, что могут соответствовать инициализированным, но в другой единице компиляции

> У PUBDEF и COMDEF есть свои братья LPUBDEF и LCOMDEF соответственно. Первые экспортируют свои символы, а вторые имеют видимость только в пределах своего модуля.

Перечисленные записи указываются в TIS как актуальные. Но в расширениях были определены и другие (в документе помечены как устаревшие):

- DEBSYM - Дополнительная отладочная информация
- TYPDEF - Информация о типе
- LOCSYM - Информация о локальных символах
- BLKDEF - Информация о блоке программы, которая содержит свою видимость, локальные переменные

Это довольно старый формат: последняя версия V5.0 была издана Intel в 1985. За все время существования многие компании создали свои ответвления/надстройки: в документе (ссылка сверху) дана спецификация для OMF, созданная из компиляции 6 различных источников.
После 5 версии выкладывались и другие версии, но они были специфичны для разлиных платформ, например, IBM в 1993 выложил свою [спецификацию IBM-OMF](http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/pc/os2/OS2_OMF_and_LX_Object_Formats_Revision_8_199406.pdf).

P.S. Не думаю, что этот формат мертв. Как минимум, автор [этой статьи](https://habr.com/ru/articles/576770/) приложил усилия и перевел свою систему программирования на PL/1-KT с 16 на 64 бит.

<spoiler title="Сегментная организация 8086">

TODO: здесь про far указатели - https://en.wikipedia.org/wiki/Far_pointer

</spoiler>

### CTF

[CTF](https://www.sourceware.org/binutils/docs/ctf-spec.html) (Compact C Type Format) - это формат отладочной информации, который содержит 
информации преимущественно об используемых типах (как можно догадаться из названия).

Изначально он разработан для Solaris, но позже был добавлен и в другие ОС. Например,:

- Linux  - в 2012 портировали libdtrace ([первый коммит](https://github.com/oracle/libdtrace-ctf/commit/248dc18174b23fec1a6a932263b3a2b5ce5adbcc))
- FreeBSD - в нем CTF это [модуль ядра](https://docs.freebsd.org/en/books/handbook/dtrace/#dtrace-implementation), без которого не будет его поддержки

Изначально, CTF проектировался как компактный и простой формат.
Компактность достигается за счет:

- Тесного "содружества" с ELF форматом - CTF использует уже готовые таблицы символов, предоставляемые ELF файлом. В частности, переиспользует таблицу строк
- Использования сжатия с помощью zlib

Проста же достигается за счет того, что в симолах отладки есть только информация о типах, без какой-либо дополнительной информации.
Учитывая, что CTF разрабатывался для C, то и типы CTF эквивалентны типам C.
На данный момент, имеются следующие типы:

```cpp
/* https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=include/ctf.h;h=4414cb0ebed95f9049ec84f9089ef8f149f21eda;hb=32778522c7d8777803c88684b8e428ee729f0b22#l408 */
#define CTF_K_UNKNOWN   0       /* Unknown type (used for padding and
                                   unrepresentable types).  */
#define CTF_K_INTEGER   1       /* Variant data is CTF_INT_DATA (see below).  */
#define CTF_K_FLOAT     2       /* Variant data is CTF_FP_DATA (see below).  */
#define CTF_K_POINTER   3       /* ctt_type is referenced type.  */
#define CTF_K_ARRAY     4       /* Variant data is single ctf_array_t.  */
#define CTF_K_FUNCTION  5       /* ctt_type is return type, variant data is
                                   list of argument types (unsigned short's for v1,
                                   uint32_t's for v2).  */
#define CTF_K_STRUCT    6       /* Variant data is list of ctf_member_t's.  */
#define CTF_K_UNION     7       /* Variant data is list of ctf_member_t's.  */
#define CTF_K_ENUM      8       /* Variant data is list of ctf_enum_t's.  */
#define CTF_K_FORWARD   9       /* No additional data; ctt_name is tag.  */
#define CTF_K_TYPEDEF   10      /* ctt_type is referenced type.  */
#define CTF_K_VOLATILE  11      /* ctt_type is base type.  */
#define CTF_K_CONST     12      /* ctt_type is base type.  */
#define CTF_K_RESTRICT  13      /* ctt_type is base type.  */
#define CTF_K_SLICE     14      /* Variant data is a ctf_slice_t.  */
```

Как можно заметить, поддерживается 14 типов. Но если представить тип нельзя (TODO: пример когда нельзя), то используется специальный тип 0.
Например, в gcc имеется поддержка CTF, которая реализована хуком в [`dwarf2ctf.c`](https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/dwarf2ctf.cc;h=00b876e2fe2cb901ca6e8e5c8c01e78f0d812723;hb=36774cec1f8d224e202dd3ca2012dae79d4e8ba9#l921), - если DIE нельзя отобразить в тип CTF, то используется `CTF_K_UNKNOWN`.

> В документации используется `type of some kind`, т.е. правильнее говорить не `type`, а `kind` т.к. именно он используется для конкретизации.
> Это можно заметить и в этих константах - все начинаются как `CTF_K_xxx`.
> Но я использую слово "тип" - не нашел более подходящего перевода.

### BTF
TODO: не забыть связь с CTF (или как он там)
[BTF](https://docs.kernel.org/bpf/btf.html) (BPF Type Format) - это формат метаданных, разработанный специально для BPF программ.
Сегодня, на замену BPF пришел eBPF, но я буду использовать BPF - так короче.
Изначально он поддерживал только информацию о типах (что отражается в самом названии), но после была добавлена поддержка функций, данных исходного кода (строки), переменных и др.

Сам по себе BPF это последовательно 64-битных инструкций, которые JIT-компилируются ядром.
Но для разработки этот ассемблер не очень удобен, поэтому разработали libbpf и формат ELF специально для BPF.
libbpf читает этот ELF файл, выполняет необходимые манипуляции и сам уже вызывает необходимые системные вызовы.
А для создания этого объектника можно использовать понятные нам языки по типу C или Rust.

Отладка возможна благодаря отладочным секциям, которые содержат нужную информацию.

- `.BTF` - Различная полезная информация - типы, переменные, квалификаторы, функции и т.д.
- `.BTF.ext` - Данные, необходимые загрузчику для манипуляций перед загрузкой в ядро.
- `.BTF_ids` - Содержит BTF ID - идентификаторы, которые использует ядро.

Как можно понять, именно в секции `.BTF` содержится вся необходимая для нас информация.
Она состоит из 2 частей: таблица строк (string table) и массив отладочной информации, далее МОИ
(в документации говорится `type data`, но мне кажется "массив отладочной информации" более говорящее название).
Таблица строк - это просто массив C-style строк, к которой обращается каждый элемент МОИ.

Каждый элемент МОИ имеет общую структуру, но далее каждый конкретный тип расширяет эту структуру, добавляет свои специфичные данные.
Под типом имеется ввиду не только `type`, но разные синтаксические конструкции и другая информация.
В исходном коде, это называют `KIND`, но другого перевода я не нашел.

На данный момент, поддерживаются следующие типы.

```cpp
/* https://github.com/torvalds/linux/blob/1722389b0d863056d78287a120a1d6cadb8d4f7b/include/uapi/linux/btf.h#L59 */
enum {
	BTF_KIND_UNKN		= 0,	/* Unknown	*/
	BTF_KIND_INT		= 1,	/* Integer	*/
	BTF_KIND_PTR		= 2,	/* Pointer	*/
	BTF_KIND_ARRAY		= 3,	/* Array	*/
	BTF_KIND_STRUCT		= 4,	/* Struct	*/
	BTF_KIND_UNION		= 5,	/* Union	*/
	BTF_KIND_ENUM		= 6,	/* Enumeration up to 32-bit values */
	BTF_KIND_FWD		= 7,	/* Forward	*/
	BTF_KIND_TYPEDEF	= 8,	/* Typedef	*/
	BTF_KIND_VOLATILE	= 9,	/* Volatile	*/
	BTF_KIND_CONST		= 10,	/* Const	*/
	BTF_KIND_RESTRICT	= 11,	/* Restrict	*/
	BTF_KIND_FUNC		= 12,	/* Function	*/
	BTF_KIND_FUNC_PROTO	= 13,	/* Function Proto	*/
	BTF_KIND_VAR		= 14,	/* Variable	*/
	BTF_KIND_DATASEC	= 15,	/* Section	*/
	BTF_KIND_FLOAT		= 16,	/* Floating point	*/
	BTF_KIND_DECL_TAG	= 17,	/* Decl Tag */
	BTF_KIND_TYPE_TAG	= 18,	/* Type Tag */
	BTF_KIND_ENUM64		= 19,	/* Enumeration up to 64-bit values */

	NR_BTF_KINDS,
	BTF_KIND_MAX		= NR_BTF_KINDS - 1,
};
```

Можно заметить, что все элементы перечисления похожи на типы CTF, но поддерживается гораздо больший диапазон типов.
Причина в том, что этот формат изначально разрабатывался именно для C и за основу был взят CTF.
BTF был добавлен в [этом патче](https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=69b693f0aefa0ed521e8bd02260523b5ae446ad7)
и вот отрывок из него:

> Hence, it basically focus on the C programming language which the modern BPF is primary using.
> ...
> BTF has its root from CTF (Compact C-Type format).

### VMS

[VMS]() - это формат отладочной информации, созданный для ОС OpenVMS

*Информации я нашел оооооооооооооочень мало. Можно сказать, все что у меня было - исходники из gcc. Поэтому далее будет описание, сделанное по реверс инжинирингу этих исходников. Они кстатит тут, в [dwarf2ctf.cc]().*

TODO: добавить ссылку

Заметки:
- `.text` - секция кода
- VMS Epoch и Unix epoch - различаются
- FIT - file info table
- LIT - line info table: file (его индекс), line number (сам номер) -> label + PC (???)
- Метки (label) могут генерироваться автоматически, но макс. длина - 30 символов
- gcc по умолчанию использует 32 битную архитектуру (PTR_SIZE = 4)
- Для отладки регистрируются свои хуки (gcc_debug_hooks)
- Метками помечаются (vmsdbgout.cc:250, gcc):
  - Начало(??)/Конец TEXT
  - Начало, пролог, эпилог, конец функции
  - Начало, конец блока
  - LINE CODE (???)
  Есть и другие метки, они в макросах начинаются с ASM_OUTPUT...

С этого момента копаюсь в binutils-gdb

- В vms-alpha.c (gdb) есть TODO 14 летней давности

---

Дальше из документа https://www.digiater.nl/openvms/freeware/v50/debug/alpha_dstrecrds.sdl

SDL - Specifiction and Description Language

DST хранит информацию о:
- модули
- функции
- лексические блоки
- метки
- символы и зависимости между ними
- строках исходного кода
- типы данных (даже сложные)

DST предназначен для использования DEBUG и TRACEBACK утилитами и только для компилируемых яп (не интерпретируемых)

В DST есть 2 типа записей:
- TBT - TODO
- DBT

После работы линковщика для создания исполняемого приложения могут появиться еще 2 секции:

- Global Symbol Table (GST) - все глобальные символы пользовательской программы. Используется, если в DST нет нужной информации (в документации last resort) 
- Debug Module Table (DMT) - вспомогательная таблица для DST, помогающая выполнить инициализацию быстрее, т.е. выступает в роли индекса.

Найти DST:
TOP -> IMAGE HEADER -> IHD$W_SYMDBGOFF -> IHS -> (IHS$L_DSTVBN, IHS$L_DSTBLKS) - положение и размер
 
DMT - запись на каждый модуль в DST.
Используется для инициализации:

- RST - RunTime Symbol Table
- Program SAT - Program Static Address Table

Структура DST:

- Состоит из последовательностей DST записей
- Каждая запись имеет заголовок из 2 байт - длина и тип. Содержимое определяется типом.
  
Записи DST - из этой последовательности и состоит весь DST:
- Module Begin DST - запись всегда перед Module DST
  - Название модуля
  - ЯП
- Всякие разные таблицы (symbol information)
- Module End DST - запись всегда после Module DST
  - Просто помечает конец

В конце абсолютно всех модулей (Module Begin/End) - Fixup DST записи - для релокации адресов

Каждая запись 512 байт. Если последняя не влазит - заполняется 0.

DMT - отмечает начало каждого Module Begin DST для каждого модуля

Есть и вложенность. Ее много:
- Routine Begin/End
- Block Begin/End

Даже записи (структуры) - это Begin/End:
- Record Begin
- Data x1
- Data x2 ...
- Record End

Есть отдельная поддержка Variant из паскаля - Variant Set Begin/End

Ada: Package Begin/End

Prolog: Proglog List Record

C++: template declaration

Представление переменных:

- Называются Data Symbols
- Есть множество представлений, но все дают 3 детали: название, адрес, тип
  - Standard Data DST - простейшая форма, описывающая простые, скалярные типы данных - int, float ...
  - Descriptor Format DST - используется, когда данные описываются с помощью VAX Standard Descriptor (??? TODO)
  - Separate Type Specification DST - определение составных типов данных (структур)
  - Специализированные DST - например, типы перечисления из Bliss (TODO: ссылка на пример)
- Дополнительная информация по блокам видимости и т.д. - неявная, получается из окружения (вложенные DST записи)
- Название - Counted ASCII string (???)
- Адрес - 5 байтов: 1 байт - тип, 4 байта - значение или адрес. Если не вмещается - указывает на область памяти, которая значение содержит
- Тип - предтавляется семейством Type Specification DST (все дальнейшие название имеют суффикс Type Specification):
  - Atomic - для скалярных типов (int, float, ...)
  - Descriptor - для стандартных типов VAX
  - Ada Descriptor - типы, которые описываются ADA'вским "расширенным дескриптором" (extended descriptor)
  - Indirect - используется, когда целевой тип расположен в другой DST записи
  - Cross-Module Indirect - как Indirect, но используется, когда тип определен в другом модуле
  - Typed Pointer - типизированный указатель
  - Pointer - не типизированный указатель (`void*`)
  - Picture - используется для типа picture в COBOL и PL/I
  - Array - массив
  - Ada array - ADA'вский массив (разница в том, что используется тот же "расширенный дескриптор")
  - Set - тип Set из Pascal
  - Subrange - описывает диапазон значений порядкового типа данных (числа, перечисления)
  - File - тип File из Pascal, PL/I
  - Area - тип area из PL/I
  - Offset - тип offset из PL/I
  - Novel Length - используется для указания дочерних типов, которые идентичны своим родителям, но имеют другую длину. В качестве примера указаны PACKED records из Pascal (TODO: ссылка на это)
  - Dynamic Novel Length - тоже самое что и Novel Length, но длина указывается другим способом
  - Self-Relative Label - "self-relative" label из PL/I (TODO: что это, ссылка)
  - Task - объекты типа task из ADA
  - Constrained Record - используется для указания того, что этот тип "ограничен в смысле ADA" (constrained in the ADA sense) - структура, в которой дискриминанты (определяют тип variant) имеют известное, константное значение
  - Might-Be-Constrained Record - используется для формальных параметров (передаваемый аргумент), которые НЕ constrained record, но известно, что реально передаваемое значение может быть constrained record
  - Scan Tree - тип Tree data из Scan (TODO: ссылка на это)
  - Scan Treeeptr - указатель типа Scan Tree (особый случай typed pointer)
  - Incomplete - используется, когда Type Specification (реализация) находится в пакете ADA. Используется как заглушка
  - Bliss block - тип BLOCK из Bliss

  
Поддерживаемые языки (есть свой код):

- Macro
- Macro64
- Fortran
- Bliss
- Cobol
- Basic
- PL/I
- Pascal
- C
- RPG
- Ada
- Scan
- Dibol
- Modula
- Pillar
- C++
- Amacro

Также есть специальная констнта для неизвестного языка.
В этом случае, поддерживаются все языко-независимые записи, а также делаются некоторые предположения-ограничения:

- Можно использовать общие (vanilla-flavored) выражения (expressions)
- Идентификаторы допускают латинские символы, цифры, '$' и '_'
- Для доступа к членам структур используются точки (в документации говорится record component selection) - A.B.C

Поддержка функций:
- Routine Begin/End
- Хранят - название функции, диапазон занимаемых адресов, адрес начала
- Предполагается, что адрес начала также и точка входа
- Если функция не определена (только сигнатура), то для нее отдельная запись Unallocated Routine DST
- Для inline функций - Inline Instance DST
- Для вложенных блоков - Block Begin/End DST (BEGIN/END - Bliss/PL/I, параграфы и секции в COBOL)


Представление структур (составных типов):
- Record Begin/End DST
- Каждый член структуры - Data Object DST
- Если есть вложенные структуры, то НЕобязательно, чтобы их DST записи были вложены друг в друга. То есть DST вложенных структур могут хранится на одном уровне с родительскими.
- Отдельно описывается поддержка Variant типа в Pascal - отдельные Variant Begin/End DST с Varint Value DST, определяющими сами варианты типа.

Другие замечания:
- В отличие от других форматов здесь нет отдельной таблицы строк - все строки включаются в записи (хранятся в них)
- Большое количество хаков для разных яп, в частности Bliss

Отображение исходного кода на инструкции:
- Line Number PC-Correlation DST record
- отображение строк кода на PC
- В записи хранятся инструкции, которые необходимо выполнить, чтобы получить готовую таблицу инструкций
- Можно сказать, что это виртуальная машина, в которой есть глобальные переменные: текущие строка, стейтмент, PC и т.д.
- Некоторые команды:
  - Delta-PC - вычисляем отображение текущей строки на адрес инструкции
  - DST$K_SET_PC_W - выставить значение PC в указанное
  - DST$K_SET_STMTNUM - выставляет значение номера текущего стейтмента в указанное

- Имеются специальные Source File Correlation DST записи - позволяют DEBUG отображать исходный код в время отладки. Они тоже содержат в себе команды, которые надо выполнить для получения результирующей таблицы.
- Переменные:
  - LINE_NUM - номер текущей строки
  - SRC_FILE - id текущего файла исходника
  - SRC_REC - номер записи, для поддержки RMS - Record Management Services (набор вспомогательных системных сервисов)
- Некоторые команды:
  - DECLARE - создает соотношение между номером строки и адресом инструкции.
  - DST$K_SRC_DECLFILE - определяет новый файл с исходниками для которого будем создавать соотношения.
  - DST$K_SRC_SETLNUM - выставляет значение LINE_NUM в указанное значение.
  
Таким образом, чтобы получить таблицу соответсвия исходного кода и инструкций, необходимо выполнить программу "своей виртуальной машины".


---

- CodeView (CV4)
- HLASM
- IEEE-695
- IMB 360 object format


> TODO: тут про разницу между -g и -ggdb (что делают, когда разница заметна)

[ ] Форматы символов (обзор)
[ ] Общие поля для отладочных символов (строки, исходный код, типы и т.д.)
[ ] Небольшой обзор DWARF

TODO: создать граф форматов - кто от кого отпачковался и т.д.


## Шагаем по коду

- По инструкциям
- По исходному коду (step in, step out, step over) - как каждый можно реализовать

## Исследуем gdb

- Обзор архитектуры
- Как step in/out/over реализованы
- Замечание по поводу отступов (не соблюдаются)
- Детали реализации интересные

# Особенности управляемых языков

Тут про C#, java, javascript, python и другие яп.
Как в них работает отладка, какие особенности, м.б. покопаться в исходниках

# Другие платформы

Windows, FreeBSD, ColibriOS (???)

# Среды разработки

VS Code, CodeBlocks
Как различные IDE взаимодействуют с отладчиками - м.б. есть общий протокол работы с ними


TODO: jit реализован через ptrace ?
