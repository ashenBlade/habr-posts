# Как работают дебаггеры

О чем написать:

1. Ядро работы дебагера: `ptrace` + `INT 3`
2. Попробовать написать свой дебаггер
   - Простой интерфейс
   - DWARF формат попробовать распарсить (и дебажиться по строчкам)
   - Фича - откат истории
3. Как работают в управляемых ЯП (байт-код, jit, C#, java, python)
4. Особенности различных платформ
   - Windows
   - FreeBSD
   - М.б. другие платформы
5. Как это работает в VS Code (про этот интерфейс рассказать на примере gdb)
6. Фичи некоторые:
   1. GDB вызывает функции как
   2. Развертка стека
7. Некоторые ответы на вопросы
   1. При attach есть настоящий родитель, а есть приаттачившийся - как получать уведомления (waitpid)?
   2. Цикл при отладке - один другого и наоборот отлаживает (https://habr.com/ru/articles/439882/)?
   3. Профилировщики используют `ptrace`?


# Ядро

Поинты:
- Все вокруг ptrace и int 3
- Сказать что буду на x86 рассказывать + в конце то как на других архитектурах это реализуется (м.б. есть особенности хз)
- ptrace - это системный вызов
- int 3 - это инструкция для генерации прерывания
- брейкпоинт - это по факту прерывание
- он специально сделан однобайтовым + пример где это может выстрелить если не однобайтовый
- PEEK and POKE рассказать
- БП только для инструкций - для строк и т.д. нужны отладочные символы
- Что если к завершенному потомку чужому приаттачиться? Все получат результат или только кто-то один (exit code потомка) 
- `strace` использует `PTRACE_SYSCALL` (найти код)

Весь процесс дебагинга крутится вокруг 2 вещей:
- `ptrace`
- `INT 3`

`ptrace` - это системный вызов, который используется для отслеживания процесса (**p**rocess **trace**). 
Интерфейс следующий:

`long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);`

Можно заметить сходство с другими вызовами по типу `ioctl` или `fcntl` - код запроса (перечисление `__ptrace_request`), идентификатор объекта (`pid`) и вспомогательные данные (`addr`, `data`).

> Понимаю, что на этом вызове много обязанностей и трудно придумать более тонкий вариант, но это как-то контрастирует с философией Unix - `делают что-то одно`. 
> Может я прикапываюсь.

Благодаря этому системному вызову можно:
- `PTRACE_CONT`/`PTRACE_SINGLESTEP` - Получить контроль над выполнением
- Прочитать и изменять:
  - `PTRACE_GETREGS`/`PTRACE_SETREGS` - Регистры
  - `PTRACE_PEEKDATA`/`PTRACE_POKEDATA` - Память и код
  - `PTRACE_PEEKUSER`/`PTRACE_POKEUSER` - TODO: придумать как назвать
  - `PTRACE_SET_THREAD_AREA` - Локальные данные потока (TLS)
- `PTRACE_SET_SYSCALL` - Подменять вызываемые системные вызовы
- `PTRACE_SECCOMP_GET_FILTER` - Получать информацию о [seccomp](https://man.archlinux.org/man/seccomp.2.en)

<spoiler title="PEEK & POKE">

TODO: тут про peek & poke написать

</spoiler>

Для начала рассмотрим общий взгляд на процесс отладки. Грубо говоря, процесс отладки итеративный и каждую итерацию можно представить в виде 3 шагов:

1. Ждем точку останова
2. Выполняем необходимые действия 
3. Продолжаем работы

Рассмотрим каждый шаг.

> Далее буду использовать терминологию из man: `tracer` - отладчик, `tracee` - процесс, который отлаживаем

## Ждем точку останова

Первое - нам необходимо дождаться остановки tracee. 
Пока представим, что она есть и рано или поздно tracee до нее дойдет.

Главный принцип работы `ptrace` можно описать так: tracee получает сигнал и останавливается, а tracer в этот момент получает контроль, что-то делает и продолжает работу tracee.
Для ожидания этого сигнала tracer использует `waitpid`.

TODO: надо ли оставлять?
> Раньше я думал, что этот системный вызов нужен для ожидания завершения дочернего процесса, но, в общем случае, он используется для отслеживания изменения статуса потомка (wait for state changes in child of the calling process, как написано в man'е).

И сам смысл точки останова в следующем:

> tracee останавливается каждый раз, когда *получает сигнал* (любой), а tracer в это время пробуждается и *`WIFSTOPPED`*, вызванный на полученном статусе, возвращает `true`. 

То есть, отслеживаемый процесс получает любой сигнал, в этот момент останавливается и `waitpid` возвращается с соответствующим статусом. 

Ждать остановки tracee требуется обязательно - практически все `ptrace` вызовы, которые изменяют состояние tracee, вернут `ESRCH`, если будут вызваны над работающим процессом. С одной стороны, ограничение - нельзя вставить палку в колеса едущему велосипеду, но, с другой, интересно было бы посмотреть что случиться. Если кратко, то только 5 команд не требуют остановленного состояния, но и они используются для начала и окончания процесса отладки. Об этих командах можно посмотреть в секции Informational and restarting ptrace commands в `man 2 ptrace`.

<spoiler title="Разные статусы остановки">

TODO: описать


тут про то, что 
- всего есть running и stopped состояния, причем заблокирован сисколом = running
- ptrace-stop имеет множество подклассов
- 


</spoiler>

Когда `waitpid` вернулся, то необходимо проверить его статус. Грубо говоря, статус можно разделить 2 случая - останов и конец работы процесса. Определить это можно по упомянутому выше `WIFSTOPPED`. С учетом того, что останавливаться будем множество раз, то код отладчика в общем случае можно представить следующим образом:

```cpp
pid_t pid;
int wstatus;
while (1)
{
    /* 
     * Ждем остановки tracee 
     */
    pid_t ret_pid = waitpid(pid, &wstatus, 0);
    if (!WIFSTOPPED(wstatus))
    {
        /* 
         * Процесс завершил работу
         */
        break;
    }

    /* 
     * Выполняем необходимые действия
     * ...
     */

    /* 
     * И продолжаем работу
     * ...
     */
}
```

## Основные манипуляции

На этом моменте, tracee остановлен, а нам (дебаггеру) вернули управление из `waitpid`. 
Представим, что точка останова сработала и процесс не завершил свою работу. 
Теперь начинается самое интересное - процесс отладки: просмотр и изменение состояния tracee.

Команды, которые призваны получать и изменять состояние tracee, в документации называются информационными (informational). Есть множество аспектов процесса, которыми мы можем управлять и для них есть по 2 команды (`PTRACE_*`) - для чтения и записи. 

Сейчас нас будут интересовать только `PTRACE_PEEKTEXT`/`PTRACE_POKETEXT` и `PTRACE_GETREGS`/`PTRACE_SETREGS`. Первая команда используется для получения и изменения данных и кода процесса, а вторая - для регистров.

> Дополнительно есть `PTRACE_PEEKDATA`/`PTRACE_POKEDATA`.
> Эта команда должна работать с данными процесса (областью памяти), а `PTRACE_PEEKTEXT`/`PTRACE_POKETEXT` - с секцией кода (`.text`).
> Но, как описано в man, у линукса адресное пространство данных и кода единое, поэтому обе команды выполняют одно и то же.

В сигнатуре `ptrace` используется 4 аргумента: первые 2 для идентификации процесса и операции, а вторые 2 - для передачи специфичных для конкретной операции параметров. В частности, передаются 2 указателя. Их семантика отличается от команды к команде, а некоторые команды используют только часть, либо не используют эти параметры вообще, поэтому для каждой команды надо смотреть отдельно.

Для примера, если `rax` равен 0, то записать число 1 (4 байтное число), по адресу из регистра `rbx`. Реализовать это можно следующим образом:

TODO: проверить

```cpp
struct user_regs_struct regs;
ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
if (regs.rax == 0)
{
    void *addr = (void *)regs.rbx;
    long data = ptrace(PTRACE_PEEKTEXT, child_pid, addr, NULL);
    *((int *)&data) = 1;
    ptrace(PTRACE_POKETEXT, child_pid, addr, (void*)data);
}
```

Обратите внимание на то, как записывается число 1.
Загвоздка в том, что команды `PEEKTEXT` и `POKETEXT` работают с машинным словом, грубо говоря, оперируют размером указателя.
У меня 64-битная машина, поэтому его размер 8 байтов, а записываю я 4-х байтное.
Если бы я хотел записать 8 байтное (`long`), то мог бы сделать это проще, без read-modify-write.

```cpp
struct user_regs_struct regs;
ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
if (regs.rax == 0)
{
    void *addr = (void *)regs.rbx;
    long data = 1L;
    ptrace(PTRACE_POKETEXT, child_pid, addr, (void*)data);
}
```

Ну и вообще, вся работа с памятью (чтение и запись) ведется подобным образом - читаем необходимый диапазон памяти по машинному слову и после записываем также по машинному слову.

## Продолжение работы

Когда все необходимые действия выполнили, то надо продолжить работу процесса.
Сделать это можно 2 способами:

- `PTRACE_SINGLESTEP` - Выполнить только 1 инструкцию
- `PTRACE_CONT` - Продолжить выполнение

Логично, что следующая остановка у первой команды будет у начала следующей инструкции, а у второй - при следующем сигнале.

## Изначальный запуск

Последнее, что мы не покрыли - как начинается процесс отладки.
Тут также есть 2 варианта:

- Сами запускаем процесс для отладки
- Присоединяемся к уже работающему процессу

### Самостоятельный запуск

Для самостоятельного запуска есть следующий паттерн:
1. Форкаемся
2. Потомок вызывает `ptrace(PTRACE_TRACEME, 0, NULL, NULL)` и запускает `exec**` с нужной программой
3. Родитель постоянно вызывает `waitpid` с пидом потомка и ждет, пока не сработает очередная точка останова

Т.е. примерно так

```c++
void child_main()
{
    /* 
     * Позволяем родителю отслеживать себя
     */
    ptrace(PTRACE_TRACEME, 0, NULL, NULL);
    /* 
     * Запускаем отлаживаемую программу
     */
    execlp("executable", "arg1");
}

void parent_main(pid_t child)
{
    int wstatus;
    while (1)
    {
        /* 
         * Ждем остановки потомка
         */
        waitpid(child_pid, &wstatus, 0);
        if (!WIFSTOPPED(wstatus))
        {
            /*
             * Потомок завершил работу
             */
            break;
        }
        /*
         * Выполняем необходимые действия над потомком
         */
        perform_actions(child_pid);
        /* 
         * Продолжаем его работу
         */
        ptrace(PTRACE_CONT, child_pid, NULL, NULL);
    }
}

int main()
{
    pid_t child_pid;
    if ((child_pid = fork()) == 0)
    {
        child_main();   
    }
    else
    {
        parent_main(child_pid);
    }
}
```

### Присоединяемся к запущенному процессу

Если какой-то процесс уже запущен и мы хотим его отладить, то для этого используется уже другой вызов - `PTRACE_ATTACH`.


При присоединении к другому процессу через `PTRACE_ATTACH` отлаживаемому процессу посылается `SIGSTOP` - это нужно, чтобы мы могли остановить процесс и поработать с ним.
Системные вызовы могут вернуть `EINTR`, когда они прерываются сигналом.
Поэтому, можно сказать, что `PTRACE_ATTACH` создает этот `errno`.

Пример такой:

```c++

int main()
{
    int wstatus;
    pid_t child_pid = obtain_pid();
    ptrace(PTRACE_ATTACH, child_pid, NULL, NULL);
    while (1)
    {
        waitpid(child_pid, &wstatus, 0);
        if (!WIFSTOPPED(wstatus))
        {
            /*
             * Потомок завершил работу
             */
            break;
        }
        /*
         * Выполняем необходимые действия над потомком
         */
        perform_actions(child_pid);

        /* 
         * Продолжаем его работу
         */
        ptrace(PTRACE_CONT, child_pid, NULL, NULL);
    }
}
```


Если нам НЕ нужно останавливать процесс после присоединения, то для этого используется `PTRACE_SEIZE`.
В этом случае, нам становится доступна еще одна команда - `PTRACE_INTERRUPT`. 
Как понятно из имени, он нужен для прерывания потока.
В man'е описано 4 варианта развития событий при выполнении этой команды: 
- При выполняющемся системном вызове этот вызов вернет `EINTR`
- Уже остановленный, но при применении `PTRACE_LISTEN`
- При конкурентном событии остановки
- Все остальные случаи
  
TODO: может добавить этот пример?
Пример для `PTRACE_SEIZE` оставляю на читателя. <----- убрать

## Собирая детали вместе

На этом моменте, в голове уже имеется общая картина, того как работают отладчики: процесс останавливается сигналом, мы его препарируем и продолжаем его работу.

Давайте сделаем свой небольшой пример использования.
Я придумал такой: приложение для складывания 2 чисел.
Ему через аргументы передаются эти 2 числа, он их складывает и печатает ответ.
Наша задача заключается в том, чтобы поменять одно из слагаемых таким образом, чтобы сумма осталась корректной, но одно из слагаемых (я возьму правое) поменялось.
Грубо говоря, прямо перед выводом результата присоединиться и изменить значение переменой слагаемой.
Звучит просто, давайте напишем.

Вначале бизнес-логика. 
Здесь все просто:

- Через argc/argv передаются аргументы
- С помощью `atol` парсим второй и третий аргументы (первый - название программы)
- Складываем 
- Выводим с помощью `printf`

Тут даже особо думать не надо. 
Можно набросать так:

```c++
int main(int argc, const char **argv)
{
    if (argc != 3)
    {
        return 1;
    }

    int left = atol(argv[1]);
    int right = atol(argv[2]);
    int sum = left + right;
    printf("%ld + %ld = %ld\n", left, right, sum);
    return 0;
}
```

Теперь надо подумать над тем, как сделать так, чтобы `right` изменился между суммой и вызовом `printf`.
Вспомним, что потомок замораживается, когда получает сигнал, причем любой.
Это сделать можно вызовом `raise` - просто передаем ему нужный сигнал и все.
Я использую `SIGCHLD`, т.к. по умолчанию он игнорируется и процесс не упадет, если его (сигнал) не обработать.
Как-то так:

```c++
int sum = left + right;
raise(SIGCHLD);
printf("%ld + %ld = %ld\n", left, right, sum);
```

Но не тут-то было.
Проблема в данном случае - определить где значение эта переменная хранится.
Я запускаю этот код на Linux, на нем используется System V ABI.
То есть, я знаю в каких регистрах должны хранится аргументы для `printf`, но опять проблема - в процессе вызова самого `raise` эти регистры затрутся аргументами для внутренних функций.
Короче говоря, это проблема.


Я не придумал ничего лучше, чем переписать все на ассемблере и сделать следующие ходы:

- Переменные `left`, `right` и `sum` теперь хранятся на стеке
- Так как этим стеком управляю я, то знаю на каком смещении от `rbp` какая переменная хранится
- Сам адрес `rbp` я сохраняю во внешнем файле, который читает отладчик

Честно говоря, это моя первая программа на ассемблере, поэтому ее качество оставляет желать лучшего:

<spoiler title="Код tracee на ассемблере">

Я использовал ассемблер GAS и синтаксис AT&T

```assembler
TODO: код
```

</spoiler>

Также имеется и отладчик.
Он делает то, что нужно - дожидается остановки tracee, читает файл с адресом и изменяет переменную.
Тут ассемблер уже не нужен.

<spoiler title="Код tracer">

```c++
TODO: код
```

</spoiler>

Да, это все было сложно и муторно - сколько всего пришлось сделать, чтобы просто поменять значение переменной.
Но есть хорошие новости - этот процесс можно очень легко упростить.
Помните, что мы останавливаемся на каждом сигнале. 
Вот была бы такая вещь, которая просто создаст сигнал и все.

Хорошая новость - она есть!

<spoiler title="Другие попытки этой реализации">

- через SIGFPE и деление
- простой вызов `raise`

</spoiler>

## int 0x3

`int 0x3` - это инструкция, которая создает нужный нам сигнал:

- `int` - это ассемблерная инструкция, генерирующая программное прерывание. Она принимает на вход аргумент
- `0x3` - номер прерывания для точки останова

Сейчас я говорю про архитектуру x86.
Она определяет [таблицу (вектор) прерываний](https://wiki.osdev.org/Interrupt_Vector_Table#:~:text=On%20the%20x86%20architecture%2C%20the,older%20software%20(e.g.%20MS-DOS%20programs)).

Когда процесс доходит до этой инструкции, то генерируется программное прерывание, которое приводит к получению `SIGTRAP`.
И вот в момент его получения мы можем получить контроль над процессом.

Давайте перепишем предыдущий код, но теперь уже с этой инструкцией.

<spoiler title="Код tracee на ассемблере">

```assembler
TODO: код
```

Заметьте, что в начале регистрируется обработчик `SIGTRAP`.
Я преследовал такую логику, чтобы этот сигнал не влиял на работу без отладчика. 
Грубо говоря, если нет отладчика (нашего), то все работает, но если запуск под ним, то логика меняется как хотим.



</spoiler>

Код tracer'а изменится соответственно

<spoiler title="Код tracer'а">

```c++
TODO: код
```

</spoiler>

<spoiler title="SIGTRAP особенный">

Тут рассказать про то, что некоторые сигналы игнорировать нельзя и если это сделать, то по умолчанию они станут в SIG_DFL

Табличку построить, что и когда происходит (hard, soft / int3, raise)

man 7 signals -> BUGS -> Сигналы которые перечислены будут доставляться всегда, если вызваны hardware (грубо говоря), SIGTRAP там тоже есть

Показать список сигналов, которые просто сбросят SIG_IGN/block (взять из force_sig)

Запись в interrupt descriptor table для int3 - https://github.com/torvalds/linux/blob/ec9eeb89e60d86fcc0243f47c2383399ce0de8f8/arch/x86/kernel/traps.c#L735

Сам обработчик, который выставляет SIG_IGN в SIG_DFL - https://github.com/torvalds/linux/blob/master/kernel/signal.c#L1326

</spoiler>

В общем, можно сказать что все готово - брейкпоинты реализуются через `int 0x3` инструкцию, можно заканчивать.
Но есть последний момент, который надо обсудить - где и как эту инструкцию вставлять.

Сейчас я написал все на ассемблере и у меня был полный контроль над исходным кодом.
Но 1) почти все пишут на более высокоуровневых ЯП и машинные инструкции там использовать нельзя, 2) не всегда есть доступ к исходному коду.
То есть просто так вставить `int 0x3` и вызвать нужное прерывание в готовом бинарнике мы не можем.
Как быть в этой ситуации?

Ответ прост - затереть инструкции.

## Как ставятся точки останова

В реализации точек останова, грубо говоря, 2 основных алгоритма: ее выставление и момент захода в нее.

Выставление точки останова:

1. Получаем адрес нужной нам инструкции
2. Пишем поверх нее инструкцию `int 0x3` (запоминаем что затерли!)

Заход в точку останова:

1. Точка останова срабатывает
2. Tracer подготавливает окружение:
   1. Получает управление
   2. Восстанавливает затертую инструкцию
   3. Переходит к предыдущей инструкции
3. Tracer выполняет необходимые манипуляции
4. Tracer продолжает выполнение tracee

Для tracee это все происходит прозрачно - кроме сигнала практически нет внешних эффектов.

Кто-то может спрость "как так? секция `.text` недоступна для записи!".
Да, но только для пользовательского пространства, а в случае с `ptrace` - 1) часть ядра, 2) может выполняться только если выполняется с полученными привилегиями.
Короче говоря, с помощью `ptrace` можно изменять и секцию `.text`.
Вы могли заметить команду `PTRACE_POKETEXT` - как можно догадаться это она изменяет код программы (то что по переданному адресу находится).

Но и тут не все, есть еще один важный момент.
Не забываем, что `int 0x3` - это всего лишь инструкция ассемблера, а ассемблер != машинные инструкции, то есть отображение не всегда однозначное.
И тут мы приходим к последнему аспекту.

## Однобайтная инструкция `int 0x3`

Может показаться что `int 0x3` - 2 байтная инструкция (команда + аргумент), но на практике она занимает *1 байт* - `0xCC`.

TODO: проверить
> Можно использовать и 2 байтную инструкцию - `0xCD 0x03`. Она тоже сработает.

Почему это важно?
Достаточно рассмотреть такой частный случай: проверка аргументов в начале функции.

На C это можно реализовать так:

```c++
/* 
 * Пользователь обновил свой интервал бронирования номера - нам нужно уведомить об этом других
 */
void notify_user_rest_interval(long start, long end)
{
    if (start == end)
    {
        /* 
         * Однодневный интервал пропускаем для оптимизации
         */
        return;
    }

    /* 
     * Уведомляем по телеге
     */
    notify_telegram();
}
```

После компиляции, мы можем получить такой ассемблерный код (справа машинный код):

```assembler
notify_user_rest_interval:
    cmpq %rdi, %rsi         # 48 39 FE
    jnz pass                # 75 01
    ret                     # C3
pass:
    call notify_telegram    # e8 00 00 00 00                   
```

Теперь представим, что `int 0x3` занимает 2 байта и мы хотим поставить точку останова прямо на `return`/`ret`.
То есть отловить все моменты, когда вызов "не совсем оптимальный".
Что произойдет?
Заметим, что `ret` - однобайтная и если ее перетереть нашим 2-х байтным `int 0x3`, то это затронет следущую инструкцию - `call`.
TODO: как правильно назвать первый байт инструкции
Учитывая что первый байт инструкции - ее `opcode` (тип команды), то будет 

Если обобщить, то 2-х байтный код для точки останова для 1 байтной команды может переписать следущую инструкцию и сделать ее невалидной, что приведет к проблемам при переходах (семейство инструкций `jmp`, `call` и т.п.).
Поэтому 1 байт для инструкции точки останова всегда затронет, только необходимую инструкцию и не повлияет на последующую функциональность.

TODO: по другому оформить
Замечания:
- Хотел адаптировать пример из Eli, но стр. 14 [AMD Reference](https://tc.gtisc.gatech.edu/cs6265/2016/refs/amd64-vol3-inst.pdf) указывает, что 1-байтных инструкций для INC/DEC больше нет (только режим совместимости)


Но для наглядность посмотрим, что будет при 2 байтной инструкции.

```assembler
    notify_user_rest_interval:
    cmpq %rdi, %rsi         # 48 39 FE
    jnz pass                # 75 01
    int $3                  # CD
pass:
    addl (%rax), %eax       # 03 00 
    addb %al, (%rax)        # 00 00  
    n/a                     # 00
```

Здесь важно заметить, что для `call` я ранее передавал нули, так как реальный адрес появится только во время выполнения.
Поэтому для примера я также использую нули.

И уже тут можно заметить, что:

1. Вызов функции `notify_telegram` исчез
2. Добавились новые инструкции, которые изменяют содержимое регистров (наше состояние), причем скорее всего мусором, так как используется `rax` - регистр для результата функции (не инициализирован)
3. В конце вообще появилась некорректная инструкция `00` - обозначил n/a


В данном случае, мы хотябы словим `SIGILL` за счет последней некорректной инструкции и ничего плохого не сделаем.
Но с учетом того, что адрес будет случайным (спасибо ASLR), то на месте мной указанных появятся случайные инструкции и тогда будь что будет.

---

Вот теперь, можно сказать, что тему ядра отладчиков покрыли.
Суммируя:

1. Вся магия заключена в комбинации системного вызова `ptrace` и инструкции `int 0x3`
2. Отладчик просто ждет пока потомок не остановится при возникновении очередного сигнала
3. Для создания этого сигнала используется `int 0x3`, которая создает `SIGTRAP` сигнал
4. Точка останова - это `int 0x3` записанная поверх исходных инструкций и, когда до нее доходим, восстанавливаем исходные инструкции и ступаем на 1 инструкцию назад

Надеюсь, объяснил понятно.
Но это только вершина айсберга - я хочу копнуть немного глубже.

TODO: на других архитектурах как дела обстоят

# Детали работы отладчиков

Когда мы встречаем `int 0x3`, то просто останавливаем работу.
Мы знаем где находимся сейчас относительно машинных инструкций, но больше особо ничего - ни о типах (структурах), ни об исходном коде, ни о чем другом не знаем.
Это дополнительная информация, которая в основном полезна во время разработки (еще полезен стэк-трейс при кордампе, но это другая история).
Чтобы эту информацию получить мы должны использовать отладочную информацию - прочитать отладочные символы.
Это и есть тот мост, соединяющий 2 мира - машинный код и исходный код.

## Отладочные символы

Скорее всего, вы и так уже знаете что такое отладочные символы.
Это специальные символы (symbols), которые добавляют некоторую полезную информацию, относительно исходного кода.
Но в ядре своем они нужны, чтобы получить 3 вида информации:

- Типы - встроенные/примитивные, пользовательские, модификаторы, размер
- Символы - переменные (глобальные или локальные), функции
- Исходный код - отображение машинных инструкций на строки исходного кода

Существует множество форматов этих символов. Я чаще всего слышал про DWARF (в контексте *nix) и CodeView (в контексте Windows).
Кроме них я нашел и другие, но в начале опишу DWARF.

### DWARF

[DWARF, Debugging With Arbitrary Record Formats](https://dwarfstd.org/doc/DWARF5.pdf) - формат отладочной информации, широко распространенный в *nix'ах (Linux, FreeBSD и т.д.).
Существует несколько версий и на момент написания статьи последняя версия - 5.
Дальнейшее описание будет для этой версии.

Для хранения отладочной информации используются секции. Название всех секций начинается с префикса `.debug_`. Работать будем с этими таблицами:

- `.debug_info` - общая отладочная информация. Здесь хранится информация о типах и символах
- `.debug_line` - информация для таблицы строк. Из нее создаем таблицу строк для отображения строк исходного кода на машинные инструкции

Кроме них есть еще и:

- `.debug_abbrev` - "схема", хранит информацию об типах атрибутов и DIE. Например, то что `DW_AT_name` в `DW_TAG_subprogram` - это строка
- `.debug_names` - таблица публичных имен (строк), на которую ссылаются некоторые записи (вместо того, чтобы хранить строку непосредственно)
- `.debug_loc` - список мест, в которых может находиться переменная (т.е. может менять свое нахождение в процессе работы). Это может быть полезно, если из-за оптимизаций, код был разорван на несколько частей.
- `.debug_str` - общая таблица строк. В ней хранятся строки, которые не попали в другие секции
- `.debug_macro` - информация о макросах
- `.debug_addr` - таблица адресов различных объектов, которые нуждаются в релокации

Внутри вся информация хранится иерархично, в виде дерева. Каждый узел этого дерева называется DIE, debugging information entry.
DIE хранят в себе самую различную информацию, например, могут представлять из себя выражение, которое нужно вычислить для получения адреса переменной или информацию об объектном модуле.

Для того, чтобы уметь различать DIE используются тэги - первое поле это тэг.
Название каждого тэга начинается с префикса `DW_TAG_`. Например, `DW_TAG_constant` - это константа.

У каждого DIE есть свой список атрибутов (пар ключ-значение). Ключом также явялется перечисление, название которого начинается с `DW_AT_`. Например, `DW_AT_const_value` - константное значение (может быть для константы, а может и для значений enum).

Для каждого типа DIE определены атрибуты, которые могут в нем хранится.

Так, для `DW_TAG_constant` допустимы следующие атрибуты:

- `DW_AT_name` - название константной переменной
- `DW_AT_type` - тип константы
- `DW_AT_endianity` - big-endian или little-endian значение константы
- `DW_AT_const_value` - само значение константы
- `DW_AT_external` - видна ли другим CU
- `DW_AT_declaration` - является ли только объявлением
- `DW_AT_accessibility` - видимость переменной
- `DW_AT_start_scope` - область, в которой переменная становится доступна
- `DW_AT_visibility` - видимость символа (локальная, глобальная ...)

Также стоит упомянуть и о выражениях. В DWARF имеет место быть выражениям, тем которые надо вычислить для получения целевого значения, например, для получения адреса поля структуры. Для их вычисления используется стек (на него кладутся операнды и операторы).
Узлы, которые представляют собой операции, имеют свое перечисление, начинающееся с `DW_OP_`, например, `DW_OP_div` - деление, а `DW_OP_deref` - разыменовывание указателя на вершине стека (значение на вершине интерпретируется как указатель).

Вся программа - это множество compilation unit (CU). Каждый CU хранит в себе специфичные для своего ЯП детали: модуль/неймспейс/импортированные объекты и т.д.
Для представления функций используется DIE - `DW_TAG_subprogram`. В нем нам интересны 3 атрибута:

- `DW_TAG_name` - название функции
- `DW_TAG_low_pc` и `DW_TAG_high_pc` - диапазон инструкций, занимаемых функцией

С помощью них можно понять, где мы сейчас находимся.

Для получения информации о переменных используется DIE `DW_TAG_variable`. В нем нам интересны следующие атрибуты:

- `DW_TAG_name` - название переменной
- `DW_TAG_location` - расположение переменной (выражение)
- `DW_TAG_type` - тип переменной

Для получений результирующей информации - обходим все функции внутри каждого CU и сохраняем себе информацию о функции и обходим все переменные внутри этой функции. Все это - обход дерева.

Таким образом, мы получаем информацию о символах. Теперь перейдем к представлению типов.

DWARF определяет несколько групп типов. Часть из них специфична для конкретных ЯП, например, coarray (массив, который хранится в другом процессе).
Всех их описывать не буду, остановлюсь на 2: базовые и составные.

Базовые, `DW_TAG_base_type` - это примитивные типы, которые уже есть. Например, `int`.
Все такие типы по умолчанию считаются численными - целочисленные или с плавающей точкой. Для того, чтобы их различать используется атрибут `DW_AT_encoding`. Например, значение `DW_DS_singed` - знаковое число, а `DW_DS_float` - с плавающей точкой.

Составные, `DW_TAG_structure_type`, `DW_TAG_class_type` - это составные типы, структуры/классы.
В нем интересны следующие поля:

- `DW_AT_name` - название структуры (если не анонимная)
- `DW_AT_byte_size` - размер в байтах

Для членов структуры используется DIE `DW_TAG_member` (дочерний узел).
В нем нам интересны следующие атрибуты:

- `DW_AT_name` - название поля
- `DW_AT_type` - тип этого поля
- `DW_AT_data_member_location` - выражение для получения адреса этого поля

Теперь должно стать понятно, как получать информацию о типах: обходим все CU и обрабатываем каждый DIE для типа в зависимости от тэга: базовые - просто запоминаем, составные - спускаемся и исследуем внутренности (поля).

> Дополнительно, можно выделить модификаторы (volatile, const и другие). Они работают как декораторы, то есть в себе хранят тип, на который этот модификатор воздействует.
> То есть, это реализуется не атрибутами.

Теперь, перейдем к получению информации об исходном коде - отображении на инструкции. Эта информация хранится в секции `.debug_lines`.

При отладке нам нужна информация по каждой строке - файл, номер строки, номер столбца, сколько занимает, эпилог или пролог и т.д.
Если хранить всю эту информацию в чистом виде, то размер исполняемого файла будет слишком огромным.
Поэтому часто для хранения этой информации используют свои "виртуальные машины". В DWARF также пошли этим путем.

Это программа, которая применяет команды для своей машины состояний. В DWARF это называется line number program.
Вся работа заключается в том, чтобы изменять состояние регистров этой виртуальной машины. Примеры этих регистров: address - PC инструкции, file - индекс названия файла, line - номер текущей строки.

Сама программа состоит из заголовка с метаданными и последовательности команд. Команды могут иметь операнды, но не обязательно.
Примеры команд:

- `DW_LNS_advance_pc` - сместить текущий PC на указанное значение
- `DW_LNS_advance_line` - сместить текущий номер строки на указанное значение
- `DW_LNS_set_file` - выставить указанное название исходного файла

После каждой выполненной команды в таблицу строк добавляется новая запись об исходном коде.
Например, после `DW_LNS_advance_pc` будет новая запись, в которой разница только в 1 поле.

DWARF поддерживает широкий диапазон различных ЯП вместе с их особенностями. Согласно перечислению `DW_LANG` (значения языков) это:

- C
- C++
- Ada
- COBOL
- Fortran
- Pascal
- Modula
- Java
- PLI
- Objective C
- Objective C++
- UPC
- D
- Python
- OpenCL
- Go
- Haskell
- OCaml
- Rust
- Swift
- Julia
- Dylan
- RenderScript
- BLISS

Для некоторых ЯП имеются отдельные значения для разных версий. Так для C это `DW_LANG_C11` и `DW_LANG_C89`.
Сама эта "особенная" информация относится к особенностям языка. Модули в Modula, level-88 condition из COBOL (конструкция похожая на switch/case), выражения with из Pascal или Modula.
Для таких фич существуют отдельные атрибуты. Они не имеют смысла для других ЯП.

TODO: каждый формат - представление типов/символов/строк

### STABS

[STABS](https://sourceware.org/gdb/current/onlinedocs/stabs.html) (Symbol TABle Strings) - один из первых форматов отладочных символов (1980-е). Название исходит из того, что все данные для отладки хранились в виде простых строк в таблице символов объектного файла (тогда еще `a.out` - не ELF).

Изначально создавался для pdx - дебаггера Pascal. Сейчас поддерживается и для других языков.

Вся отладочная информация хранится в специальных таблицах символов - stab. Для разной информации имеются разные директивы ассемблера:

- `.stabs` - строковая информация: функции, структуры, строки исходного кода, глобальные переменные (используется чаще всего)
- `.stabn` - числовая информация (скорее та, для которой не нужны строки): общее количество символов, адрес `catch` для GNU C++ (`N_CATCH`)
- `.stabd` - то же, что и `stabn`, но значение - текущая строка (явно не указывается значение): (примеров не нашел)

TODO: где использовался/кто поддерживает

### OMF

[OMF](https://refspecs.linuxfoundation.org/elf/TIS1.1.pdf)(\[Relocatable\] Object Module Format) - это на самом деле формат объектных файлов, а не отладочной информации.
Но поддержка отладочной информации встроена в него - отдельные, "well-known" записи.

Объектный файл представляется в виде последовательности записей, каждая из которых состоит из 4 "полей":

|               | Тип                                     | Длина                                       | Данные                                             | Чек-сумма                      |
| ------------- | --------------------------------------- | ------------------------------------------- | -------------------------------------------------- | ------------------------------ |
| Размер (байт) | 1                                       | 2                                           | N                                                  | 1                              |
| Описание      | Определяет какие данные содержит запись | Длина оставшейся части (Данные и Чек-сумма) | Сама полезная нагрузка. Содержимое зависит от Типа | Чек-сумма всех остальных полей |

Как можно заметить, поле тип определяет содержимое записи.
В TIS определили 28 типов записи. Например, запись PUBDEF (PUBlic DEFinitions) определяет список экспортируемых (глобальных) символов.
Но пока сфокусируемся на отладке.

Для отладки можно использовать следующие записи:

- LINNUM - Отображение строк исходного кода, на адреса машинных инструкций
- LINSYM - Отображение функций на строки исходного кода (вместе с LINNUM позволяет понять адрес начала функции)
- PUBDEF, LPUBDEF - Функции и переменные - глобальные и локальные (в зависимости от префикса L). Можно сказать, что разница в том указывается ли `static` или нет
- COMDEF, LCOMDEF - Общие (communal) переменные - неинициализированные статические или те, что могут соответствовать инициализированным, но в другой единице компиляции

> У PUBDEF и COMDEF есть свои братья LPUBDEF и LCOMDEF соответственно. Первые экспортируют свои символы, а вторые имеют видимость только в пределах своего модуля.

Перечисленные записи указываются в TIS как актуальные. Но в расширениях были определены и другие (в документе помечены как устаревшие):

- DEBSYM - Дополнительная отладочная информация
- TYPDEF - Информация о типе
- LOCSYM - Информация о локальных символах
- BLKDEF - Информация о блоке программы, которая содержит свою видимость, локальные переменные

Это довольно старый формат: последняя версия V5.0 была издана Intel в 1985. За все время существования многие компании создали свои ответвления/надстройки: в документе (ссылка сверху) дана спецификация для OMF, созданная из компиляции 6 различных источников.
После 5 версии выкладывались и другие версии, но они были специфичны для разлиных платформ, например, IBM в 1993 выложил свою [спецификацию IBM-OMF](http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/pc/os2/OS2_OMF_and_LX_Object_Formats_Revision_8_199406.pdf).

P.S. Не думаю, что этот формат мертв. Как минимум, автор [этой статьи](https://habr.com/ru/articles/576770/) приложил усилия и перевел свою систему программирования на PL/1-KT с 16 на 64 бит.

<spoiler title="Сегментная организация 8086">

TODO: здесь про far указатели - https://en.wikipedia.org/wiki/Far_pointer

</spoiler>

### CTF

[CTF](https://www.sourceware.org/binutils/docs/ctf-spec.html) (Compact C Type Format) - это формат отладочной информации, который содержит 
информации преимущественно об используемых типах (как можно догадаться из названия).

Изначально он разработан для Solaris, но позже был добавлен и в другие ОС. Например,:

- Linux  - в 2012 портировали libdtrace ([первый коммит](https://github.com/oracle/libdtrace-ctf/commit/248dc18174b23fec1a6a932263b3a2b5ce5adbcc))
- FreeBSD - в нем CTF это [модуль ядра](https://docs.freebsd.org/en/books/handbook/dtrace/#dtrace-implementation), без которого не будет его поддержки

Изначально, CTF проектировался как компактный и простой формат.
Компактность достигается за счет:

- Тесного "содружества" с ELF форматом - CTF использует уже готовые таблицы символов, предоставляемые ELF файлом. В частности, переиспользует таблицу строк
- Использования сжатия с помощью zlib

Проста же достигается за счет того, что в симолах отладки есть только информация о типах, без какой-либо дополнительной информации.
Учитывая, что CTF разрабатывался для C, то и типы CTF эквивалентны типам C.
На данный момент, имеются следующие типы:

```cpp
/* https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=include/ctf.h;h=4414cb0ebed95f9049ec84f9089ef8f149f21eda;hb=32778522c7d8777803c88684b8e428ee729f0b22#l408 */
#define CTF_K_UNKNOWN   0       /* Unknown type (used for padding and
                                   unrepresentable types).  */
#define CTF_K_INTEGER   1       /* Variant data is CTF_INT_DATA (see below).  */
#define CTF_K_FLOAT     2       /* Variant data is CTF_FP_DATA (see below).  */
#define CTF_K_POINTER   3       /* ctt_type is referenced type.  */
#define CTF_K_ARRAY     4       /* Variant data is single ctf_array_t.  */
#define CTF_K_FUNCTION  5       /* ctt_type is return type, variant data is
                                   list of argument types (unsigned short's for v1,
                                   uint32_t's for v2).  */
#define CTF_K_STRUCT    6       /* Variant data is list of ctf_member_t's.  */
#define CTF_K_UNION     7       /* Variant data is list of ctf_member_t's.  */
#define CTF_K_ENUM      8       /* Variant data is list of ctf_enum_t's.  */
#define CTF_K_FORWARD   9       /* No additional data; ctt_name is tag.  */
#define CTF_K_TYPEDEF   10      /* ctt_type is referenced type.  */
#define CTF_K_VOLATILE  11      /* ctt_type is base type.  */
#define CTF_K_CONST     12      /* ctt_type is base type.  */
#define CTF_K_RESTRICT  13      /* ctt_type is base type.  */
#define CTF_K_SLICE     14      /* Variant data is a ctf_slice_t.  */
```

Как можно заметить, поддерживается 14 типов. Но если представить тип нельзя (TODO: пример когда нельзя), то используется специальный тип 0.
Например, в gcc имеется поддержка CTF, которая реализована хуком в [`dwarf2ctf.c`](https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/dwarf2ctf.cc;h=00b876e2fe2cb901ca6e8e5c8c01e78f0d812723;hb=36774cec1f8d224e202dd3ca2012dae79d4e8ba9#l921), - если DIE нельзя отобразить в тип CTF, то используется `CTF_K_UNKNOWN`.

> В документации используется `type of some kind`, т.е. правильнее говорить не `type`, а `kind` т.к. именно он используется для конкретизации.
> Это можно заметить и в этих константах - все начинаются как `CTF_K_xxx`.
> Но я использую слово "тип" - не нашел более подходящего перевода.

### BTF
TODO: не забыть связь с CTF (или как он там)
[BTF](https://docs.kernel.org/bpf/btf.html) (BPF Type Format) - это формат метаданных, разработанный специально для BPF программ.
Сегодня, на замену BPF пришел eBPF, но я буду использовать BPF - так короче.
Изначально он поддерживал только информацию о типах (что отражается в самом названии), но после была добавлена поддержка функций, данных исходного кода (строки), переменных и др.

Сам по себе BPF это последовательно 64-битных инструкций, которые JIT-компилируются ядром.
Но для разработки этот ассемблер не очень удобен, поэтому разработали libbpf и формат ELF специально для BPF.
libbpf читает этот ELF файл, выполняет необходимые манипуляции и сам уже вызывает необходимые системные вызовы.
А для создания этого объектника можно использовать понятные нам языки по типу C или Rust.

Отладка возможна благодаря отладочным секциям, которые содержат нужную информацию.

- `.BTF` - Различная полезная информация - типы, переменные, квалификаторы, функции и т.д.
- `.BTF.ext` - Данные, необходимые загрузчику для манипуляций перед загрузкой в ядро.
- `.BTF_ids` - Содержит BTF ID - идентификаторы, которые использует ядро.

Как можно понять, именно в секции `.BTF` содержится вся необходимая для нас информация.
Она состоит из 2 частей: таблица строк (string table) и массив отладочной информации, далее МОИ
(в документации говорится `type data`, но мне кажется "массив отладочной информации" более говорящее название).
Таблица строк - это просто массив C-style строк, к которой обращается каждый элемент МОИ.

Каждый элемент МОИ имеет общую структуру, но далее каждый конкретный тип расширяет эту структуру, добавляет свои специфичные данные.
Под типом имеется ввиду не только `type`, но разные синтаксические конструкции и другая информация.
В исходном коде, это называют `KIND`, но другого перевода я не нашел.

На данный момент, поддерживаются следующие типы.

```cpp
/* https://github.com/torvalds/linux/blob/1722389b0d863056d78287a120a1d6cadb8d4f7b/include/uapi/linux/btf.h#L59 */
enum {
	BTF_KIND_UNKN		= 0,	/* Unknown	*/
	BTF_KIND_INT		= 1,	/* Integer	*/
	BTF_KIND_PTR		= 2,	/* Pointer	*/
	BTF_KIND_ARRAY		= 3,	/* Array	*/
	BTF_KIND_STRUCT		= 4,	/* Struct	*/
	BTF_KIND_UNION		= 5,	/* Union	*/
	BTF_KIND_ENUM		= 6,	/* Enumeration up to 32-bit values */
	BTF_KIND_FWD		= 7,	/* Forward	*/
	BTF_KIND_TYPEDEF	= 8,	/* Typedef	*/
	BTF_KIND_VOLATILE	= 9,	/* Volatile	*/
	BTF_KIND_CONST		= 10,	/* Const	*/
	BTF_KIND_RESTRICT	= 11,	/* Restrict	*/
	BTF_KIND_FUNC		= 12,	/* Function	*/
	BTF_KIND_FUNC_PROTO	= 13,	/* Function Proto	*/
	BTF_KIND_VAR		= 14,	/* Variable	*/
	BTF_KIND_DATASEC	= 15,	/* Section	*/
	BTF_KIND_FLOAT		= 16,	/* Floating point	*/
	BTF_KIND_DECL_TAG	= 17,	/* Decl Tag */
	BTF_KIND_TYPE_TAG	= 18,	/* Type Tag */
	BTF_KIND_ENUM64		= 19,	/* Enumeration up to 64-bit values */

	NR_BTF_KINDS,
	BTF_KIND_MAX		= NR_BTF_KINDS - 1,
};
```

Можно заметить, что все элементы перечисления похожи на типы CTF, но поддерживается гораздо больший диапазон типов.
Причина в том, что этот формат изначально разрабатывался именно для C и за основу был взят CTF.
BTF был добавлен в [этом патче](https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=69b693f0aefa0ed521e8bd02260523b5ae446ad7)
и вот отрывок из него:

> Hence, it basically focus on the C programming language which the modern BPF is primary using.
> ...
> BTF has its root from CTF (Compact C-Type format).

### VMS

[VMS]() - это формат отладочной информации, созданный для ОС OpenVMS

*Информации я нашел оооооооооооооочень мало. Можно сказать, все что у меня было - исходники из gcc. Поэтому далее будет описание, сделанное по реверс инжинирингу этих исходников. Они кстатит тут, в [dwarf2ctf.cc]().*

TODO: добавить ссылку

Заметки:
- `.text` - секция кода
- VMS Epoch и Unix epoch - различаются
- FIT - file info table
- LIT - line info table: file (его индекс), line number (сам номер) -> label + PC (???)
- Метки (label) могут генерироваться автоматически, но макс. длина - 30 символов
- gcc по умолчанию использует 32 битную архитектуру (PTR_SIZE = 4)
- Для отладки регистрируются свои хуки (gcc_debug_hooks)
- Метками помечаются (vmsdbgout.cc:250, gcc):
  - Начало(??)/Конец TEXT
  - Начало, пролог, эпилог, конец функции
  - Начало, конец блока
  - LINE CODE (???)
  Есть и другие метки, они в макросах начинаются с ASM_OUTPUT...

С этого момента копаюсь в binutils-gdb

- В vms-alpha.c (gdb) есть TODO 14 летней давности

---

Дальше из документа https://www.digiater.nl/openvms/freeware/v50/debug/alpha_dstrecrds.sdl

SDL - Specifiction and Description Language

DST хранит информацию о:
- модули
- функции
- лексические блоки
- метки
- символы и зависимости между ними
- строках исходного кода
- типы данных (даже сложные)

DST предназначен для использования DEBUG и TRACEBACK утилитами и только для компилируемых яп (не интерпретируемых)

В DST есть 2 типа записей:
- TBT - TODO
- DBT

После работы линковщика для создания исполняемого приложения могут появиться еще 2 секции:

- Global Symbol Table (GST) - все глобальные символы пользовательской программы. Используется, если в DST нет нужной информации (в документации last resort) 
- Debug Module Table (DMT) - вспомогательная таблица для DST, помогающая выполнить инициализацию быстрее, т.е. выступает в роли индекса.

Найти DST:
TOP -> IMAGE HEADER -> IHD$W_SYMDBGOFF -> IHS -> (IHS$L_DSTVBN, IHS$L_DSTBLKS) - положение и размер
 
DMT - запись на каждый модуль в DST.
Используется для инициализации:

- RST - RunTime Symbol Table
- Program SAT - Program Static Address Table

Структура DST:

- Состоит из последовательностей DST записей
- Каждая запись имеет заголовок из 2 байт - длина и тип. Содержимое определяется типом.
  
Записи DST - из этой последовательности и состоит весь DST:
- Module Begin DST - запись всегда перед Module DST
  - Название модуля
  - ЯП
- Всякие разные таблицы (symbol information)
- Module End DST - запись всегда после Module DST
  - Просто помечает конец

В конце абсолютно всех модулей (Module Begin/End) - Fixup DST записи - для релокации адресов

Каждая запись 512 байт. Если последняя не влазит - заполняется 0.

DMT - отмечает начало каждого Module Begin DST для каждого модуля

Есть и вложенность. Ее много:
- Routine Begin/End
- Block Begin/End

Даже записи (структуры) - это Begin/End:
- Record Begin
- Data x1
- Data x2 ...
- Record End

Есть отдельная поддержка Variant из паскаля - Variant Set Begin/End

Ada: Package Begin/End

Prolog: Proglog List Record

C++: template declaration

Представление переменных:

- Называются Data Symbols
- Есть множество представлений, но все дают 3 детали: название, адрес, тип
  - Standard Data DST - простейшая форма, описывающая простые, скалярные типы данных - int, float ...
  - Descriptor Format DST - используется, когда данные описываются с помощью VAX Standard Descriptor (??? TODO)
  - Separate Type Specification DST - определение составных типов данных (структур)
  - Специализированные DST - например, типы перечисления из Bliss (TODO: ссылка на пример)
- Дополнительная информация по блокам видимости и т.д. - неявная, получается из окружения (вложенные DST записи)
- Название - Counted ASCII string (???)
- Адрес - 5 байтов: 1 байт - тип, 4 байта - значение или адрес. Если не вмещается - указывает на область памяти, которая значение содержит
- Тип - предтавляется семейством Type Specification DST (все дальнейшие название имеют суффикс Type Specification):
  - Atomic - для скалярных типов (int, float, ...)
  - Descriptor - для стандартных типов VAX
  - Ada Descriptor - типы, которые описываются ADA'вским "расширенным дескриптором" (extended descriptor)
  - Indirect - используется, когда целевой тип расположен в другой DST записи
  - Cross-Module Indirect - как Indirect, но используется, когда тип определен в другом модуле
  - Typed Pointer - типизированный указатель
  - Pointer - не типизированный указатель (`void*`)
  - Picture - используется для типа picture в COBOL и PL/I
  - Array - массив
  - Ada array - ADA'вский массив (разница в том, что используется тот же "расширенный дескриптор")
  - Set - тип Set из Pascal
  - Subrange - описывает диапазон значений порядкового типа данных (числа, перечисления)
  - File - тип File из Pascal, PL/I
  - Area - тип area из PL/I
  - Offset - тип offset из PL/I
  - Novel Length - используется для указания дочерних типов, которые идентичны своим родителям, но имеют другую длину. В качестве примера указаны PACKED records из Pascal (TODO: ссылка на это)
  - Dynamic Novel Length - тоже самое что и Novel Length, но длина указывается другим способом
  - Self-Relative Label - "self-relative" label из PL/I (TODO: что это, ссылка)
  - Task - объекты типа task из ADA
  - Constrained Record - используется для указания того, что этот тип "ограничен в смысле ADA" (constrained in the ADA sense) - структура, в которой дискриминанты (определяют тип variant) имеют известное, константное значение
  - Might-Be-Constrained Record - используется для формальных параметров (передаваемый аргумент), которые НЕ constrained record, но известно, что реально передаваемое значение может быть constrained record
  - Scan Tree - тип Tree data из Scan (TODO: ссылка на это)
  - Scan Treeeptr - указатель типа Scan Tree (особый случай typed pointer)
  - Incomplete - используется, когда Type Specification (реализация) находится в пакете ADA. Используется как заглушка
  - Bliss block - тип BLOCK из Bliss

  
Поддерживаемые языки (есть свой код):

- Macro
- Macro64
- Fortran
- Bliss
- Cobol
- Basic
- PL/I
- Pascal
- C
- RPG
- Ada
- Scan
- Dibol
- Modula
- Pillar
- C++
- Amacro

Также есть специальная констнта для неизвестного языка.
В этом случае, поддерживаются все языко-независимые записи, а также делаются некоторые предположения-ограничения:

- Можно использовать общие (vanilla-flavored) выражения (expressions)
- Идентификаторы допускают латинские символы, цифры, '$' и '_'
- Для доступа к членам структур используются точки (в документации говорится record component selection) - A.B.C

Поддержка функций:
- Routine Begin/End
- Хранят - название функции, диапазон занимаемых адресов, адрес начала
- Предполагается, что адрес начала также и точка входа
- Если функция не определена (только сигнатура), то для нее отдельная запись Unallocated Routine DST
- Для inline функций - Inline Instance DST
- Для вложенных блоков - Block Begin/End DST (BEGIN/END - Bliss/PL/I, параграфы и секции в COBOL)
- Для пролога и эпилога функций - Prolog/Epilog DST


Представление структур (составных типов):
- Record Begin/End DST
- Каждый член структуры - Data Object DST
- Если есть вложенные структуры, то НЕобязательно, чтобы их DST записи были вложены друг в друга. То есть DST вложенных структур могут хранится на одном уровне с родительскими.
- Отдельно описывается поддержка Variant типа в Pascal - отдельные Variant Begin/End DST с Varint Value DST, определяющими сами варианты типа.

Другие замечания:
- В отличие от других форматов здесь нет отдельной таблицы строк - все строки включаются в записи (хранятся в них)
- Большое количество хаков для разных яп, в частности Bliss

Отображение исходного кода на инструкции:
- Line Number PC-Correlation DST record
- отображение строк кода на PC
- В записи хранятся инструкции, которые необходимо выполнить, чтобы получить готовую таблицу инструкций
- Можно сказать, что это виртуальная машина, в которой есть глобальные переменные: текущие строка, стейтмент, PC и т.д.
- Некоторые команды:
  - Delta-PC - вычисляем отображение текущей строки на адрес инструкции
  - DST$K_SET_PC_W - выставить значение PC в указанное
  - DST$K_SET_STMTNUM - выставляет значение номера текущего стейтмента в указанное

- Имеются специальные Source File Correlation DST записи - позволяют DEBUG отображать исходный код в время отладки. Они тоже содержат в себе команды, которые надо выполнить для получения результирующей таблицы.
- Переменные:
  - LINE_NUM - номер текущей строки
  - SRC_FILE - id текущего файла исходника
  - SRC_REC - номер записи, для поддержки RMS - Record Management Services (набор вспомогательных системных сервисов)
- Некоторые команды:
  - DECLARE - создает соотношение между номером строки и адресом инструкции.
  - DST$K_SRC_DECLFILE - определяет новый файл с исходниками для которого будем создавать соотношения.
  - DST$K_SRC_SETLNUM - выставляет значение LINE_NUM в указанное значение.
  
Таким образом, чтобы получить таблицу соответсвия исходного кода и инструкций, необходимо выполнить программу "своей виртуальной машины".


---

### CodeView и PDB

> Источников информациии совсем немного. Изначально, эту секцию я писал ориентируясь на [Microsoft Symbol and Type Information](https://openwatcom.org/ftp/devel/docs/CodeView.pdf) (далее MSTI). Но только когда дописал, то понял, что этот документ вышел в 199x году (скорее всего 1993).
> После было несколько попыток поиска актуальной документации. В результате я остановился на исходном коде для LLVM ([код](https://github.com/llvm/llvm-project/tree/0b0874755d4f339ae3ef6a43421405ebe9d645f3/llvm/lib/DebugInfo/CodeView), [заголовочные файлы](https://github.com/llvm/llvm-project/tree/0b0874755d4f339ae3ef6a43421405ebe9d645f3/llvm/include/llvm/DebugInfo/CodeView)).
> Далее будет то, что нашел в исходных кодах LLVM и microsoft-pdb. Иногда будут замечания по поводу MSTI.

PDB, Program DataBase - это файл с отладочными символами. Он используется в Windows.
Обычно, отладочные символы хранятся отдельно от самого бинарного файла.
Этот файл имеет разметку, которая называется MSF (Multi-Stream Format), то есть представляет из себя множество потоков, где каждый поток может быть поделен на несколько страниц (например, если поток большой, то удобно его разделить на несколько отдельных файлов).
Такой формат называют "file system within a file" (поток - это "файл", чанки - это "страница").
Этот формат описан на LLVM ([документация](https://llvm.org/docs/PDB/MsfFile.html)).

CodeView - это формат отладочной информации. В MSTI говорится о том, что он нужен только для символов и типов, но в LLVM он используется и для исходного кода.
Этот формат используется в экосистеме Windows - компиляторы Visual C++/C#/VB.NET, Visual Studio debugger, WinDbg.

> CodeView и PDB файлы тесно связаны. Поэтому отделить одно от другого трудно.

Его спецификация никогда не публиковалась, но [в 2015 году решили подсобить LLVM](https://lists.llvm.org/pipermail/cfe-dev/2015-October/045780.html) и дали первую часть - информация о типах. Далее, создали [репозиторий](https://github.com/microsoft/microsoft-pdb), но он заархивирован год назад, а последние изменения в нем были 8 лет назад. На основании кода в этом репозитории пишут свой код уже в LLVM. Часто перед какой-либо структурой можно заметить комментарий по типу `Corresponds to the CV_... struct`.

Хранить отладочную информацию мы можем в виде встраиваемых симолов и PDB потоков. В обоих случаях, различается только способ доступа к информации, а сама эта информация имеет одинаковый формат.

Если CodeView встраивается, то поддерживаются 2 формата объектных файлов: OMF и COFF. В каждом разное наименование целевых секций (из MSTI):

- COFF (секции):
  - Типы - `.debug$T`
  - Символы - `.debug$S`
- OMF (записи LEDATA)
  - Типы - `$$TYPES`
  - Символы - `$$SYMBOLS`

Для них есть потоки в PDB:

- типы:
  - TPI Stream
  - IPI Stream
- символы:
  - Public Symbol Stream
  - Global Symbol Stream
  - Module Info Stream

Таблица символов - описывает символы. Таблица типов - типы для этих символов. Причем, символы могут ссылаться на типы, а типы на себя же.

В секции типов хранятся как примитивные (int, char, double), так и пользовательские (typedef, struct TODO: уточнить) типы.
Информация о них хранится в виде ацикличного ориентированного графа (DAG):

- Узлы - сами типы
- Ребра - отношение включения типа (использует/ссылается)

У каждого типа есть свой индекс. Если нужно сослаться на какой-то тип, то используется он.
Причем, для наиболее используемых, встроенных типов зарезервированы индексы до 4096 (0x1000), а 0 - особое значение "no type" (используется как `NULL`).
Назначение индексов должно быть последовательным, а пропуски запрещены. То есть, индексы идут `0x1000`, `0x1001`, `0x1002` ... а `0x1000`, `0x1003`, `0x1004` запрещено.

Главная проблема здесь - это циклы. Например, можно сразу определить структуру, у которой поле - ссылка на саму себя.
Эта проблема решается тем, что используется forward declaration.
В [этом видео](https://youtu.be/5twzd06NqGU?si=rr6cZW7Tw1pnsUGY&t=590) более подробно описывается алгоритм работы с типами и описывается этот DAG.

TODO: визуализация этого графа из слайда https://www.llvm.org/devmtg/2016-11/Slides/Kleckner-CodeViewInLLVM.pdf

<spoiler title="Индексы простых типов">

TODO: тут показать SimpleTypeKind - llvm/include/llvm/DebugInfo/CodeView/TypeIndex.h

посмотреть еще может где-то написано где-что зарезервированно (секция 5 должна быть)

</spoiler>

Для оптимизации производительности используется выравнивание записей.
Если это используется, то в начале таблицы добавляется заголовок `0x00000001`.

Для хранения типов используется DAG - это отражается и в том как представляются типы. У нас также есть представление дерева.
Каждый узел этого дерева (структура) хранит в себе поле `leaf` - перечисление `LF_...`. Оно говорит о том, что перед нами за структура.
Возможные значения можно посмотреть [здесь](https://github.com/llvm/llvm-project/blob/18225c783a00bde62f19a177a57de388e20c2bba/llvm/include/llvm/DebugInfo/CodeView/CodeViewTypes.def).

Дальнейшее содержимое зависит от типа узла. Все leaf можно разделить на 4 группы:

1. Записи, на которые могут ссылаться из таблицы символов
   - LF_MODIFIER - модификатор типа (const, volatile, unaligned ...)
   - LF_POINTER - типизированный указатель
   - LF_CLASS - класс
   - LF_STRUCTURE - структура
   - LF_PROCEDURE - функции
2. Записи, на которые НЕ могут ссылаться из таблицы символов, но могут из других записей
    - LF_ARGLIST - аргументы функции
    - LF_DEFARG - значение функции по умолчанию
    - LF_FIELDLIST - список из полей структуры/класса/объединения/перечисления
    - LF_BITFIELD - битовое поле
3. Используется для создания сложных структур
    - LF_BCLASS - базовый класс
    - LF_MEMBER - поле класса
    - LF_METHOD - функция класса (как перегруженная, так и нет)
    - LF_NESTTYPE - вложенный тип
    - LF_FRIENDCLS - дружественный (friend) класс
4. Используется для хранения числовых значений.
   Здесь применили интересный подход: если при обходе записей мы знаем, что дальше должно быть значение, то мы смотрим на следующие 2 байта:
    - Если эти 2 байта меньше 0x8000 - то это нужное нам значение (константа)
    - В противном случае, мы интепретируем это число как leaf:
      - LF_CHAR - 1 байт
      - LF_SHORT - 2 байта
      - LF_LONG - 4 байта
      - LF_REAL32 - 4 байтное с плавающей точкой

Предопределенные примитивные типы имеют индексы меньше 4096, т.е. 0x0FFF и меньше. Их индексы имеют такую маску

| Режим указателя | Тип    |
| --------------- | ------ |
| 3 бита          | 16 бит |

Режим указателя - какой тип указателя представляет:

- Не указатель
- Near pointer
- Far pointer
- Huge pointer

TODO: добавить ссылку на то, что это

Тип - один из примитивных типов:

- Целочисленное знаковое
- Целочисленные беззнаковое
- Bool
- С плавающей точкой
- Комплексное
- Особый (special)

> В MSTI другая разметка примитивного типа. Например, в ней есть поле размер. Оно интерпретируется в зависимости от типа:
>
> - Целочисленные и bool - размер в байтах
> - С плавающей точкой - битность (32, 64, 80, 128, 48)
> - Особые значения:
>   - Абсолютный символ
>   - Сегмент
>   - Void
>   - Валюта

Для представления класса/структуры/интерфейса используется такая запись:

| Индекс   | Кол-во полей | Свойства | Индекс списка | Наследует | V-Table | Размер | Название |
| -------- | ------------ | -------- | ------------- | --------- | ------- | ------ | -------- |
| LF_CLASS | int16        | int16    | int32         | int32     | int32   | int64  | string   |

Поля:

- Индекс - тип записи (маркер). В примере указан LF_CLASS, но может быть LF_STRUCTURE и LF_INTERFACE
- Кол-во полей - сколько полей хранится в классе
- Свойства - битовая маска свойств/характеристик класса. Например, вложенность, имеет конструктор/деструктор или перегруженный оператор
- Индекс списка - индекс списка (LF_FIELDLIST), который описывает каждое поле структуры (то есть эта информация хранится отдельно)
- Наследует - индекс списка, который описывает другие классы, от которых этот класс наследуется
- V-Table - индекс виртуальной таблицы
- Размер - размер класса в байтах
- Название - название этого класса

Под символами имеются ввиду не только символы в понимании ассемблера (метки функций и т.д.), но грубо говоря, все что не типы. Например, имеется символ `S_UNAMESAPCE` - `using namespace` или `S_COMPILE` - флаги компиляции.
Хранения информации происходит также иерархично, а для оптимизации поиска, записи, которые начинают область имеют ссылки на своих родителей (чтобы не читать все записи).

Каждая запись для символа имеет общий заголовок: длина + тип символа (индекс). Дальнейшее содержимое зависит от флага. Индексы можно разделить на 5 групп (примеры приведены):

1. Символы, формат которых не меняется в зависимости от окружения: символы регистров, символы пользовательских типов и т.д.
   - Флаги компиляции
   - Константы и перечисления
   - Название объектных файлов
   - Пользовательские типы
2. Символы для архитектур с сегментированным режимом адресации 16:16
   - Переменные, хранящиеся на стеке
   - Не экспортируемые символы
   - Глобальные и static функции
   - Области видимости (начало и конец блоков)
3. Символы для архитектур с сегментированным режимом адресации 16:32 (примеры те же)
4. Символы, специфичные для MIPS архитектуры или компилятора
   - Глобальные и static функции
5. Для CodeView оптимизации
   - Глобальные хэш таблицы для функций и переменных

Для хранения переменных используется несколько индексов - в зависимости от хранилища (регистр или стек) и битности (16, 32 и т.д.).
Для представления переменной, хранящейся на стеке используется следующая запись:

| Длина | Индекс  | Смещение | Тип   | Название |
| ----- | ------- | -------- | ----- | -------- |
| int32 | S_BPREL | int32    | int32 | string   |

Поля:

- Длина - общая длина записи
- Индекс - индекс/маркер записи, равно `S_BPREL`
- Смещение - смещение относительно регистра BP (EBP/RBP ...), где хранится переменная
- Тип - индекс типа из таблицы типов
- Название - название переменной (в 1 байте - длина строки)

Для получения таблицы строк исходного кода используется отдельная таблица.
Если это PDB, то используется поток DBI - Debug Information. В нем содержится множество подпотоков.

Информация об исходных файлах хранится иерархично: модуль -> файл -> сегменты. И так для каждого объектного модуля. Можно представить так:

- Модуль 1
  - Файл 1
    - Сегмент 1
    - Сегмент 2
  - Файл 2
    - Сегмент 1
    - Сегмент 2

Сама информация об отображении исходного кода на инструкции хранится в `Debug Lines Subsection`. Она состоит из 2 частей:

- Заголовок
- Список `LineBlockFragment`

В заголовке нам интересно только 1 поле - флаги. Один из флагов - наличие информации о столбцах в исходном коде. Таким образом мы можем хранить информацию о нескольких стейтментах в одной строке.

Сама информация по отображению исходного кода на инструкции хранится в `LineBlockFragment` - элементах списка. Каждый такой элемент хранит в себе 3 поля:

1. `NameIndex` - индекс файла, который этот блок описывает
2. `NumLines` - размеры следующих массивов (кол-во строк, которые этот блок хранит в себе)
3. Массив `LineNumberEntry` - отображение строки исходного кода на машинные инструкции
4. Массив `ColumnNumberEntry` - дополнительная информация о столбцах

3 и 4 - это параллельные массивы, причем 4 может отсутствовать - необходимо проверять флаг из заголовка (сказал ранее).

Каждый `LineNumberEntry` - это:

- `Offset` - адрес инструкции
- `Start:24` - номер строки
- `End:7` - размер строки (сколько строк занимает), может отсутствовать
- `IsStatement:1` - это стейтмент или выражение

Последние 3 поля хранятся в виде битовых полей, в общем они занимают 4 бита, а вся запись в общем 8 байт.

---

### ADATA

ADATA - это формат отладочной информации, изобретенный специально для HLASM (High Level Assembler), ассемблема IBM.
Этот ассемблер имеет некоторые конструкции, специфичные для высокоуровневых языков, например, поддержка переменных, в качестве операндов могут быть выражения (не нужны отдельные инструкции для их вычислений), различные строковые операции (конкатенация, подстрока, длина) и т.д.

Отладочная информация хранится в виде

Этот формат отладки поддерживает 2 фичи: отображение исходного кода на инструкции и работа с символами.

Вся отладочная информация хранится в отдельном файле - SYSADATA.
Он создается во время компиляции.

Состоит этот файл из последовательности записей.
Каждая запись имеет 12 байтный заголовок:

|               | Lanuage Code | Record Type | Architecture Level | Flag | Edition | Reserved |
| ------------- | ------------ | ----------- | ------------------ | ---- | ------- | -------- |
| Размер, байты | 4            | 2           | 4                  | 1    | 4       | 1        |

Поля:

- Language Code - код исходного языка, пока константа = 16
- Record Type - тип записи
- Architecture Level - уровень архитектуры, в этом случае - версия загловка
- Flag - различные флаги свойств: имеется ли продолжение, endianess ...
- Edition - версия самой записи (содержимого)
- Reserved - зарезервированная область

Есть множество типов записей, но нам будут интересны следующие:

- Source Analysis Record
- Machine Instruction Record
- Symbol Record
- DC/DS Record

Для создания таблицы исходного кода используются Source Analysis Record и Machine Instruction Record.
Здесь стоит вспомнить, что формат создан для "высокоуровневого" ассемблера.
Один из аспектов высокоуровневости - поддержка макросов, они могут создавать более 1 инструкции, поэтому необходимо знать соответствие исходного кода и ассемблера.

Source Analysis Record позволяет нам сопоставить исходный код с инструкциями. Эта запись позволяет сопоставлять 1 строку исходного кода с инструкциями.

Здесь стоит вспомнить, что формат создан для "высокоуровневого" ассемблера.
Один из аспектов высокоуровневости - поддержка макросов, они могут создавать более 1 инструкции, поэтому необходимо знать соответствие исходного кода и ассемблера.

Поэтому, эта запись, во-первых, имеет смысл, во-вторых, имеет множество подтипов:

- Комментарий - описывает строку комментария
- Инструкция - описывает строку, которая 1 на 1 отображается в инструкцию
- Стейтмент - описывает строку, которая может отобразиться на несколько ассемблерных инструкций. Это можно назвать стейтментом, а пример - условые инструкции, например, условное копирование
- Вызов макроса - вызов макроса
- Определение макроса - описывает реализацию макроса

Эта запись генерируется для каждой строки в каждом файле исходников.
Формат записи одинаковый независимо от типа строки, поэтому некоторые поля могут не использоваться.

Сам адрес инструкции хранится в поле Location Counter - IBM-специфичный аналог PC.

Также есть Machine Instruction Record - запись, которая содержит сгенерированный машинный код. Она идет после Source Analysis Record, если инструкции были сгенерированы.

Таким образом, нам необходимо просто прочитать все Source Analysis записи и получить из них пары строка файла - Location Counter.

> Также стоит отметить, что обе записи в себе содержат копию исходного кода или ассемблерных инструкций, поэтому они самодостаточны, т.е. можно воссоздать весь исходник с помощью файла отладочной информации

Другая запись - Symbol Record.
Она хранит в себе информацию о символе.

Еще один аспект "высокоуровневости" - переменные.
Для их создания используется отдельный стейтмент - DS, Define Storage.
Переменная тоже является символом, поэтому будет влючена в эту запись.

Но HLASM - безтиповой. Это общее с ассемблером, поэтому записей для информации нет.

Все эти записи хранятся в файле SYSADATA, который генерируется во время компиляции.
В документации он называется Associated Data File.
Записи в файле организованы следующим образом.

- `Compilation Unit Start`
- Вспомогательные записи
- Основные записи
- `Compilation Unit End`

Compilation Unit Start/End - это записи обозначающие границы единицы компиляции. Вся информация по каждому CU хранится внутри них.

В начале имеется несколько вспомогательных записей. Они хранят некоторые метаданные, например, Options Record - показывает с какими флагами была запущена компиляция.

Дальше идут уже записи для отладки.
Source Analysis, Machine Instruction и Symbol записи хранятся здесь.

> В примерах, все записи были в порядке следования стейтментов исходного кода, но в документации я не нашел должен ли быть такой порядок.
> Как минимум, есть очерки, что после Source Analysis должен идти Machine Instruction

---

### IEEE-695

IEEE-695 - это формат объектного модуля, разработанный для встраиваемых систем (MUFOM - Microprocessor Universal for Object Modules).

Эта спецификация проприетарная и платная.
[Официально](https://www.stdlink.com/standards/ieee-695-1990.html) - 86$ (примерно 7500 рублей).

Я ее не покупал и в интернете в открытом доступе не нашел.
Но, так как это спецификация, то есть множество реализаций - документация для них есть в свободном доступе.

Например, [эта реализация](https://github.com/z88dk/techdocs/blob/master/miscellaneous/ieee_695_v4.1_object_file_format.pdf) от Microtec и HP.
Я буду считать ее рефернсной, так как именно они (компании) положили основу формату и создали пропозал в IEEE.
Дальше будет описание именно их реализации.

Отладочная информация хранится в отдельной части модуля - Debug Information Part.

Вся информация хранится в записях.

Информация о типах хранится в записи TY.
Формат этой записи

| Маркер    | Индекс типа   | Маркер    | Индекс названия | Код          |
| --------- | ------------- | --------- | --------------- | ------------ |
| 0xF2      | число         | 0xCE      | число           | число        |
| Константа | Не меньше 256 | Константа | Не меньше 32    | Перечисление |

- Есть 2 поля маркер - это константы. Если первый указывает на тип самой записи, то зачем 2-ой маркер - не знаю.

- Индес типа - это индекс этого типа в глобальной таблице типов.
    В этой таблице хранятся все типы, которые используются в программе.

- Индекс названия - это индекс NN записи.
    NN запись - это грубо говоря пара из числа (глобального индекса) и строки (названия).
    Ее используют не только для названий типов, например, для переменных или номеров строк.

- Код - это маркер самого типа, дискриминатор.

Есть несколько кодов типов (определяются ASCII символами):

- '!' - неизвестный тип
- 'A' - массив
- 'a' - массив из FORTRAN (он в column-major порядке)
- 'Z' - массив (TODO: разница?? что значит with 0 lower bound)
- 'N' - перечисление
- 'E' - простое перечисление
- 'O' - small указатели
- 'P' - large указатели
- 'R' - диапазон (range)
- 'S' - структура
- 'G' - структура с битовыми полями
- 'U' - объединение (union)
- 'X' - внешняя процедура (объявление)
- 'V', 'v' - void
- 'c', 'd' - комплексное и двойное комплексное
- 'f' - название файла (Pascal)
- 'g' - битовое поле
- 'n' - квалификатор (const, volatile)
- 's' - множество (set)
- 'x' - процедура с зависимостями компилятора

Дальнейшие поля записи зависят от кода типа.
Например, для структуры ('S') и для объединения ('U') дальше идет массив из тройки полей:

- Название поля - хранится простой строкой
- Индекс типа - индекс в глобальной таблице типов
- Размер типа - размер в байтах, причем для пользовательских типов можно указывать размер в битах (т.е. не кратный байтам).

Таким образом, структура/объединение - это просто массив таких троек.

TODO: ссылка функция парсинга - binutils/ieee.c:parse_ieee_ty

Информация о структуре программы хранится в отдельной части объектного файла - Debug Information Part.

Она содержит в себе блоки.
Каждый блок - это информация по какой-то логической части исходной программы,
например, определение глобальной функции.

Блоки определяют область (начало и конец), которая может содержать другие записи/блоки.
Границы размечаются `BB$` и `BE$` - Block Begin и End, а `$` - номер типа:

- 1 - типы в локальной видимости
- 2 - типы в глобальной видимости
- 3 - модуль
- 4 - глобальная функция (подпрограмма)
- 5 - строка исходного кода
- 6 - локальная функция (подпрограмма)
- 10 - дебаг информация для ассемблера
- 11 - TODO: ???
- 20 - информация для библиотеки

> Дальше буду говорить *BB$*, вместо *блок типа $* - так короче, да и в
> документах и коде используется такой подход.

Для включения блоков есть правила.
Например, BB3 может содержать в себе BB4 (модуль определяет глобальную функцию), но наоборот - нет, что вполне логично.

Для получения информации о типах используются BB1 и BB2 блоки.
Они содержат TY и NN записи, описанные ранее.

Для получения таблицы строк используется блок BB5 - File name for source line numbers.

Вот так выглядит заголовок блока BB5:

| Маркер начала | Размер блока в байтах | Название файла | Штамп     | Маркер NN | Номер файла | ID файла |
| ------------- | --------------------- | -------------- | --------- | --------- | ----------- |
| BB5           | int                   | string         | Timestamp | NN        | int         | string   |

Заметки:

- Размер блока в байтах может быть 0 - значит неизвестен размер
- Название файла - абсолютный путь
- Штамп содержит в себе дату и время компиляции: год, месяц, число, час, минута, секунда
- ID файла в коде везде пустая строка

> Последние 3 поля образуют 1 запись NN. В стандарте MRI/HP отмечается, что такая запись
> должна быть единственной на каждый файл исходного кода, но не могу сказать, есть
> ли в самом стандарте IEEE такое ограничение.

Дальше идет множество записей о строке исходного кода. Каждая логическая запись
состоит из 2 отдельных записей: ATN и ASN.

ATN - id строки -> номер строки в файле

| Маркер ATN | Индекс символа | Тип символа | Дескриптор атрибутов | Номер строки | Номер столбца |
| ---------- | -------------- | ----------- | -------------------- | ------------ | ------------- |
| 0xF1CE     | int            | 0           | 7                    | int          | 0             |

Замечания:

- Указанные конкретные значения взял из кода. Они специфичны для ATN номеров строк.
- Дескриптор атрибутов можно интерпретировать как подтип ATN - он определяет
  сколько будет дальше полей и каков их смысл. Для номеров строк используется
  значение 7, но есть и другие, например, 3 - статическая переменная.
- Номер столбца 0, т.к. в коде нет возможности получить номер столбца, только номер строки.

ASN - id строки -> адрес инструкции

| Маркер ASN | Индекс строки | Адрес инструкции |
| ---------- | ------------- | ---------------- |
| 0xE2CE     | int           | int              |

Для воссоздания таблицы символов нужно прочитать все записи из BB5 для каждого
файла.

TODO: в конце ссылки на другие источники и на сам пропозал (найти ссылку)

---

> TODO: тут про разницу между -g и -ggdb (что делают, когда разница заметна)\

[ ] Общие поля для отладочных символов (строки, исходный код, типы и т.д.)

## Шагаем по коду

Чтобы понять, как это все объединить предлагаю написать свой отладчик.
Я назвал его Dumbugger, потому что он ~~тупой~~ максимально простой:

- Язык только C
- Функции все простые (например, `inline` функции не поддерживаю)
- Из модификаторов только `const` или `typedef` (например, `volatile` не поддерживаю)

Его репозиторий [тут](https://github.com/ashenBlade/dumbugger).

Мы реализуем следующие фичи:

- Точки останова - на функции, на строке файла, на инструкции
- Шаги по исходному коду - step over, step out, step in
- Чтение значений переменных
- Получение цепочки вызовов (backtrace)
- Дизассемблирование
- Чтение и изменение регистров

Для тестирования функциональность буду использовать простенькую программу на C (смысла в ее работе нет).

<spoiler title="Текст программы">

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Sample {
    int value;
} Sample;

int sample_function(int a) {
    int lon = a * 2;
    Sample s = {
        .value = 123,
    };
    Sample *sss = calloc(1, sizeof(Sample));
    sss->value = 12323;
    return lon + 1;
}

int main(int argc, const char **argv) {
    int i = argc;
    ++i;
    i = sample_function(i);
    printf("%d", i);
    return 0;
}
```

</spoiler>

### Чтение отладочных символов

Перед началом работы нам следует получить информацию - о программе и о процессе.

Информация о процессе - это загрузочный адрес и исполняемый файл.
Эту информацию можно получить с помощью `procfs`. Нам нужно прочитать следующие файлы:

1. `/proc/<PID>/exe` - путь до исполняемого файла (soft-link)
2. `/proc/<PID>/maps` - адреса загрузки различных файлов (исполняемых и библиотек)

Это сделать довольно просто: 1 - это прочитать ссылку (`readlink`), а 2 - спарсить файл.
Также у 2 шага стоит замеить, что начало информации о нашей программе будет скорее всего первой, но не уверен, что так будет всегда, то есть нельзя просто так возвращать первую прочитанную строку.

В maps мы находим первую строку, файл которой равен прочитанному из 1 шага, - в нем читаем начало диапазона.
Например, вот такой кусок этого файла:

```text
62d87e0a9000-62d87e0aa000 r--p 00000000 103:02 59118213                  /home/user/a.out
62d87e0aa000-62d87e0ab000 r-xp 00001000 103:02 59118213                  /home/user/a.out
62d87e0ab000-62d87e0ac000 r--p 00002000 103:02 59118213                  /home/user/a.out
62d87e0ac000-62d87e0ad000 r--p 00002000 103:02 59118213                  /home/user/a.out
62d87e0ad000-62d87e0ae000 rw-p 00003000 103:02 59118213                  /home/user/a.out
62d87f207000-62d87f228000 rw-p 00000000 00:00 0                          [heap]
```

Загрузочный адрес `a.out` - `0x62d87e0a9000`.

Чтобы понять зачем, прочитаем отладочную информацию (информация о программе).

Я поддерживаю только DWARF 5 в самом исполняемом файле (не отдельно).
Для работы с ним использую библиотеку [libdwarf](https://www.prevanders.net/libdwarfdoc/).

Здесь нам потребуется путь до исполняемого файла, полученный на 1 шаге.
Передаем этот путь и библиотека инициализируется.
Теперь начнем инициализировать свое состояние.

Для начала посмотрим, какая отладочная информация есть в программе.
Это можно сделать с помощью `dwarfdump` (из того же проекта, что и `libdwarf`).

Программу я представляю как множество функций, где каждая состоит из:

- Название
- Расположение (файл с исходным кодом)
- Переменные
  - Название
  - Расположение
  - Тип (далее)
- Диапазон занимаемых адресов

Для простоты поддерживаю 3 типа:

- Примитив (`int`, `long`, `char`)
- Структура
- Указатель (на примитив, структуру или другой указатель)

`union`, `enum` и т.д. - не поддерживаю.

Осталось только собрать эту информацию.
Чтобы было проще и понятнее, что и где нужно искать я часто пользовался `dwarfdump` вместо того, чтобы искать что-то в спецификации.

<spoiler title="Некоторая отладочная информация">

Я не буду вставлять код сборки отладочной информации, так как там много внутреннего/инфраструктурного кода, как например, обработка ошибок.
Но для наглядности, покажу некоторые части DWARF для тестовой программы.

Представление `sample_function`:

TODO: изменить название переменных

```text
< 1><0x0000005a>    DW_TAG_base_type
                      DW_AT_byte_size             0x00000004
                      DW_AT_encoding              DW_ATE_signed
                      DW_AT_name                  int
< 1><0x0000012e>    DW_TAG_subprogram
                      DW_AT_external              yes(1)
                      DW_AT_name                  sample_function
                      DW_AT_decl_file             0x00000001
                      DW_AT_decl_line             0x00000008
                      DW_AT_decl_column           0x00000005
                      DW_AT_prototyped            yes(1)
                      DW_AT_type                  <0x0000005a>
                      DW_AT_low_pc                0x00001149
                      DW_AT_high_pc               <offset-from-lowpc> 63 <highpc: 0x00001188>
                      DW_AT_frame_base            len 0x0001: 0x9c: 
                          DW_OP_call_frame_cfa
                      DW_AT_call_all_tail_calls   yes(1)
                      DW_AT_sibling               <0x00000184>
< 2><0x0000014e>      DW_TAG_formal_parameter
                        DW_AT_name                  a
                        DW_AT_decl_file             0x00000001 /home/ashblade/Projects/dumbugger/src/sample.c
                        DW_AT_decl_line             0x00000008
                        DW_AT_decl_column           0x00000019
                        DW_AT_type                  <0x0000005a>
                        DW_AT_location              len 0x0002: 0x914c: 
                            DW_OP_fbreg -52
< 2><0x0000015b>      DW_TAG_variable
                        DW_AT_name                  lon
                        DW_AT_decl_file             0x00000001
                        DW_AT_decl_line             0x00000009
                        DW_AT_decl_column           0x00000009
                        DW_AT_type                  <0x0000005a>
                        DW_AT_location              len 0x0002: 0x916c: 
                            DW_OP_fbreg -20
< 2><0x00000169>      DW_TAG_variable
                        DW_AT_name                  s
                        DW_AT_decl_file             0x00000001
                        DW_AT_decl_line             0x0000000a
                        DW_AT_decl_column           0x0000000c
                        DW_AT_type                  <0x000000a2>
                        DW_AT_location              len 0x0002: 0x915c: 
                            DW_OP_fbreg -36
< 2><0x00000175>      DW_TAG_variable
                        DW_AT_name                  sss
                        DW_AT_decl_file             0x00000001
                        DW_AT_decl_line             0x0000000d
                        DW_AT_decl_column           0x0000000d
                        DW_AT_type                  <0x00000184>
                        DW_AT_location              len 0x0002: 0x9160: 
                            DW_OP_fbreg -32
```

Описание:

- Узел функции `sample_function` имеет смещение `0x0000012e`
- Сама функция занимает диапазон с `0x00001149` по `0x00001188`
- У узла есть 4 дочерних узла:
  - входной аргумент `a` (`DW_TAG_formal_parameter`)
  - 3 переменных `lon`, `s`, `sss` (`DW_TAG_variable`)
- Возвращает функция - `int` (`DW_AT_type`)

Это описание подобной функции:

```c
int sample_function(int a) {
    int lon;
    Sample s;
    Sample *sss;
    /* ... */
    return lon;
}
```

Структура `Sample` описывается следующим образом:

```text
< 1><0x0000005a>    DW_TAG_base_type
                      DW_AT_byte_size             0x00000004
                      DW_AT_encoding              DW_ATE_signed
                      DW_AT_name                  int
< 1><0x00000087>    DW_TAG_structure_type
                      DW_AT_name                  Sample
                      DW_AT_byte_size             0x00000004
                      DW_AT_decl_file             0x00000001 /home/ashblade/Projects/dumbugger/src/sample.c
                      DW_AT_decl_line             0x00000004
                      DW_AT_decl_column           0x00000010
                      DW_AT_sibling               <0x000000a2>
< 2><0x00000094>      DW_TAG_member
                        DW_AT_name                  value
                        DW_AT_decl_file             0x00000001 /home/ashblade/Projects/dumbugger/src/sample.c
                        DW_AT_decl_line             0x00000005
                        DW_AT_decl_column           0x00000009
                        DW_AT_type                  <0x0000005a>
                        DW_AT_data_member_location  0
< 1><0x000000a2>    DW_TAG_typedef
                      DW_AT_name                  Sample
                      DW_AT_decl_file             0x00000001 /home/ashblade/Projects/dumbugger/src/sample.c
                      DW_AT_decl_line             0x00000006
                      DW_AT_decl_column           0x00000003
                      DW_AT_type                  <0x00000087>
```

Описание:

- Узел структуры `Sample` имеет смещение `0x00000087`
- Структура занимает 4 байта (`DW_AT_byte_size`)
- У нее есть 1 поле - `value` с типом `0x0000005a` (`DW_AT_type`) - это примитив `int` (`DW_TAG_base_type`)
- Для `struct Sample` имеется `typedef` - `0x000000a2` (`DW_TAG_typedef`)

Это описывает структуру:

```c
typedef struct Sample {
    int value;
} Sample;
```

</spoiler>

### Точки останова

В отладчике мы можем указать 3 места, куда точки останова можно ставить:

1. Машинная инструкция
2. Начало функции
3. Строка исходного кода

Как ставить точку останова на машинную инструкцию уже известно - делали ранее.
Остальные 2 имеют ту же механику (кладем инструкцию `0xCC` на место точки останова), но различается способ определения места расположения.
Если мы ставим точку останова на инструкцию, то ее адрес нам уже должен быть известен, в противном же случае этот адрес необходимо определить самостоятельно и в обоих случаях необходимы символы отладки.

Чтобы поставить точку останова на функцию необходимо знать где эта функция начинается.
В DWARF для функции указывается ее диапазон: `lowpc` (начало) и `highpc` (конец).
Нам необходимо поставить точку основа на ее начало, то есть на ее `lowpc`.

> Это я сказал очень грубо, так как
>
> 1. Ее обязательно функция будет занимать непрерывный участок памяти. В DWARF в подобных случаях указывается список занимаемых диапазонов.
> 2. Верхний адрес (lowpc) - не обязательно будет точкой входа, там может находится какой-нибудь другой код, например, для проверок целосности и т.д. . В DWARF поэтому имеется атрибут `DW_AT_entry_point` - он указывает адрес точки входа и по хорошему точку останова надо класть туда.
> 3. У функции есть эпилог и пролог - вспомогательные участки кода в начале и конце функции. Чаще всего они используются для настройки фрейма (например, обновление RBP регистра). По хорошему точку останова надо ставить на них (вход и выход из функции). Но я столкнулся с проблемой, что gcc (компилирую им) не добавляет информацию о прологе и эпилоге. Поэтому я добавил костыль - когда я достигаю точки останова, то смотрю на 2 дальнейшие инструкции - если это стандартный эпилог (`push %rbp; mov %rsp, %rbp;`) то дополнительно выполняю 2 инструкции.

Вот так выглядит информация о диапазоне функции в DWARF:

```text
< 1><0x000000e2>    DW_TAG_subprogram
                      DW_AT_name                  main
                      DW_AT_low_pc                0x00001188
                      DW_AT_high_pc               <offset-from-lowpc> 70 <highpc: 0x000011ce>
```

Занимается непрерывный диапазон памяти, поэтому highpc - это смещение относительно lowpc.

Чтобы поставить точку останова на строку исходного кода нам нужен уже другой подход - мы будем использовать таблицу строк.
Она хранится в секции `.debug_line`. Для тестовой программы она будет выглядеть следующим образом (справа добавил исходный код, чтобы было понятнее, `dwarfdump` этого не показывает):

```text
.debug_line: line number info for a single cu
Source lines (from CU-DIE at .debug_info offset 0x0000000c):

            NS new statement, BB new basic block, ET end of text sequence
            PE prologue end, EB epilogue begin
            IS=val ISA number, DI=val discriminator value
<pc>        [lno,col] NS BB ET PE EB IS= DI= uri: "filepath"
0x00001149  [   8,28] NS uri: "/home/user/main.c"               | int sample_function(int a) {
0x00001154  [   9, 9] NS                                        |     int lon = a * 2;
0x0000115c  [  10,12] NS                                        |     Sample s = {
0x00001163  [  13,19] NS                                        |     Sample *sss = calloc(1, sizeof(Sample));
0x00001176  [  14,16] NS                                        |     sss->value = 12323;
0x00001180  [  15,16] NS                                        |     return lon + 1;
0x00001186  [  16, 1] NS                                        | }
0x00001188  [  18,39] NS                                        | int main(int argc, const char **argv) {
0x00001197  [  19, 9] NS                                        |     int i = argc;
0x0000119d  [  20, 5] NS                                        |     ++i;
0x000011a1  [  21, 9] NS                                        |     i = sample_function(i);
0x000011ae  [  22, 5] NS                                        |     printf("%d", i);
0x000011c7  [  23,12] NS                                        |     return 0;
0x000011cc  [  24, 1] NS                                        | }
0x000011ce  [  24, 1] NS ET                                     |
```

Так как мы работаем с уже готовой отладочной информацией, а не с исходным кодом, то можно понять, что точки останова мы можем ставить указывая название файла и номер строки (возможно с номером столбца).
Но не номер строки внутри функции, так как работаем с простым текстом.

Логика выставления точки останова находится в `dmbg_set_breakpoint_function` TODO: ссылка на функцию:

<spoiler title="dmbg_set_breakpoint_function">

TODO: код

</spoiler>

Чтобы поставить точку останова на строке - находим адрес инструкции, с которой начинается эта строка (`dmbg_set_breakpoint_src_file`) TODO: ссылка на функцию

<spoiler title="dmbg_set_breakpoint_src_file">

TODO: код

</spoiler>

Могли заметить функцию `set_breakpoint_at_addr` - она содержит в себе логику добавления `0xCC` инструкции и сохранения точки останова.
Но главное - заметить что ей передается не просто адрес из символов отладки, а смещенный относительно адреса загрузки.
Это необходимо, так как тестовая программа скомпилировалась как PIC (position independent code). Если бы этого не было, то мы бы передавали те же самые адреса, что и в символах отладки.

> С последним столкнулся, когда случайно скомпилировал gcc без флага `--enable-default-pie` и удивлялся, когда `ptrace` валился с `EIO` при передаче ему адреса за вычетом загрузочного адреса.
> То есть, если у нас не PIE, то не нужно учитывать адрес загрузки процесса.

### Шаги в исходном коде

Под шагами имеется ввиду семейство `step XXX` команд:

- `step out` - выйти из текущей выполняемой функции
- `step over` - выполнить текущую строку без захода во внутрь других функций
- `step in` - выполнить текущую строку и зайти во внутрь выполняемой

Первой реализуем step in - выполняем 1 строку и если был вызов функции, то спускаемся в нее.

Это самая простая реализация, так как нам просто нужно выполнять инструкции пока не уйдем с текущей строки. Причем не важно куда - на строку в текущей или другой функции.
Но также не стоит забывать о том, что при входе в другую функцию мы можем попасть на ее пролог. Если остановимся прямо перед ним, то состояние будет не совсем корректным - надо учесть.

<spoiler title="step in">

Код логики шага

TODO: код

Пролог определяется так

TODO: код для пролога + макрос определения

</spoiler>

Теперь step over. Здесь уже нельзя просто выполнять инструкции - если пойдем вглубь вызываемой функции и будем уже там выполнять по 1 инструкции, то про производительность говорить не придется.
Поэтому применим другой подход - будем ставить точки останова на строке внутри функции. Наивный подход - ставить точку останова на следующую строку. Иногда он может сработать, но стоит вспомнить об управляющих конструкциях (`for`, `if`, `goto`) так станет понятно, что это нерабочий подход - управление может перейти куда угодно.
Чтобы это исправить мы будем ставить точки останова на все строки, а когда остановимся, то удалим их.

<spoiler title="step over">

TODO: код

</spoiler>

> Можно прочитать инструкции текущей строки и определить есть ли там инструкции перехода, но это сложно и затратно

Также стоит заметить еще один момент - возвращение из функции. В коде можно заметить, что в самом начале читается адрес возврата и ставится на него точка останова.
Это важный момент, так как ранее мы ставили точки останова только на строки внутри функции, но в таком случае по достижении `return` выполнение просто продолжится - точки останова внутри функции удалены не будут.
Тем более это не то что ожидается - если step over достигает `return`, то мы должны остановиться на строке, на которую вернулись. Для этого мы и ставим точку останова на адресе возврата.
Сам адрес возврата хранится на стеке, по адресу `%RBP + 0x8` - нужно просто его прочитать.

Есть и 2 момент - что после возвращения из этой функции? Адрес возврата указывает на следующую инструкцию после `call`, но обычно там находится код восстанавливающий контекст. Например, регистры из стека.
Необходимость в этой части такая же как и в прологе - если не выполнить, то контекст будет старым (из возвращенной функции) и при выполнении некоторых других команд отладчика могут быть выполнены некорректные действия.
Например, если пролог не будет выполнен, то rbp будет старым, а это может привести к тому, что точка останова будет указывать не на правильный адрес или значение переменной будет читаться из неправильного адреса.

Для обработки этой ситуации имеется функция TODO: название этой функии, сейчас `exec_after_return`:


<spoiler title="exec_after_return">

TODO: код

</spoiler>

Последняя команда - step out. Она просто выходит из текущей функции. То есть поставить точку останова на адресе возврата. Но не забываем (как в предыдущем шаге) выполнить инструкции до следующей строки, чтобы восстановить контекст.
Все необходимые знания (чтение адреса возврата и выполнение кода после `return`) для этого уже имеются, поэтому просто приложу готовый код:

<spoiler title="step out">

TODO: код

</spoiler>

### Чтение значений переменных

Просто так выполнять код не имеет смысла, если мы не знаем над какими данными выполняются операции.
Поэтому следующим шагом реализуем чтение значений переменных.

Отладчик будет поддерживать только следующие типы данных:

- примитивы (int, long, char)
- структуры
- указатели

Также для структур буду выводить только ее поля - без рекурсивного спуска в другие структуры.
Если у поля структуры есть указатель или вложенная структура, то их выводить не буду.

Первым делом нам необходимо найти где переменная хранится.
Я предполагаю, что все переменные хранятся на стеке, то есть без регистров.
В такой реализации, чтобы найти значение переменной необходимо прочитать данные на стеке по определенному смещению.

Здесь все просто: Адрес переменной = `RBP` + смещение. (Со 100% вероятностью это будет отрицательное смещение).
Если посмотрим на символы DWARF, то увидим эти (отрицательные) смещения (`DW_AT_location` - `DW_OP_fbreg -52`):

```text
< 1><0x0000012e>    DW_TAG_subprogram
                      DW_AT_name                  sample_function
                      DW_AT_frame_base            len 0x0001: 0x9c: 
                          DW_OP_call_frame_cfa
< 2><0x0000014e>      DW_TAG_formal_parameter
                        DW_AT_name                  a
                        DW_AT_type                  <0x0000005a>
                        DW_AT_location              len 0x0002: 0x914c: 
                            DW_OP_fbreg -52
```

Переменная `a` хранится на стеке со смещением -52 относительно начала фрейма.

<spoiler title="Нахождение переменных в нетривиальных местах">

Переменные могут хранится не только на стеке. Часто они хранятся напрямую в регистрах.
Чтобы обрабатывать такие ситуации в DWARF многие аспекты выражаются в виде выражений, как тот же `DW_AT_location`.
Например, при компилировании с ключом `-Og`:

```text
< 2><0x00000193>      DW_TAG_formal_parameter
                        DW_AT_name                  a
                        DW_AT_location              0x0000005f
      .debug_loclists offset  : 0x0000005f
      <debug_loclists offset 0x0000005f with 3 entries follows>
   [ 0]<start,end            0x00001149 0x00001157>
                            DW_OP_reg5
   [ 1]<start,end            0x00001157 0x00001167>
                            DW_OP_entry_value 0x00000001 contents 0x55
                            DW_OP_stack_value
   [ 2]<end-of-list>
                        DW_AT_GNU_locviews          0x0000005b 
```

Можно заметить, что расположение этой же самой переменной выражается в виде списка расположений -
ее месторасположение меняется в зависимости от текущей исполняемой инструкции.
Таким образом, эта переменная хранится:

- В текущем регистре `RDI` - если инструкция между адресами `0x1149` и `0x1157`
- В значении `RDI`, что был при входе в функцию - если инструкция между адресами `0x1157` и `0x1167`

За что отвечает `DW_AT_GNU_locviews` не знаю.

</spoiler>

Но стоит также сделать замечание касательно самого DWARF. Смещение в `DW_OP_fbreg` указывает на САМОЕ начало фрейма - с учетом адреса возврата и сохраненного регистра `RBP`.
Поэтому выражение для получения адреса будет выглядеть так: `%RBP + offset - 16` (16 т.к. система 64 битная).

<spoiler title="Код получения адреса переменной">

TODO: код

</spoiler>

Теперь будем читать значения.

Логика здесь разделяется на 3 случая в зависимости от типа:

#### Примитив

Если это примитив, то мы читаем слово (`PEEK_TEXT`) и отсекаем столько, сколько тип занимает.
А когда будем отображать, то дополнительно учтем знак.

В DWARF размер и знак указываются в атрибутах `DW_AT_byte_size` и `DW_AT_encoding`. Например, для `int` запись будет такой:

```text
< 1><0x0000005a> DW_TAG_base_type
                   DW_AT_byte_size    0x00000004
                   DW_AT_encoding     DW_ATE_signed
                   DW_AT_name         int
```

Для чтения базовых переменных имеется функция `read_simple_value`. Она читает значение и возвращает строку, представляющую значение.
Я немного схитрил и не стал кастить значение прочитанного слова - вместо этого я использую разные строки формата для одного и того же переданного значения.

<spoiler title="read_simple_value">

TODO: код

</spoiler>

#### Структура

Значение структуры - это значение всех ее полей. Но как уже сказал, все поля обрабатываются как примитивные, без рекурсивного спуска в значения других структур.
Сама структура - это множество полей. У каждого поля есть свое смещение относительно начала структуры.

Например, для структуры Sample с 3 полями разного типа в DWARF будет следующая запись:

```text
< 1><0x00000087>    DW_TAG_structure_type
                      DW_AT_name                  Sample
                      DW_AT_byte_size             0x00000010
< 2><0x00000094>      DW_TAG_member
                        DW_AT_name                  value
                        DW_AT_type                  <0x0000005a>
                        DW_AT_data_member_location  0
< 2><0x000000a0>      DW_TAG_member
                        DW_AT_name                  another
                        DW_AT_type                  <0x00000068>
                        DW_AT_data_member_location  4
< 2><0x000000ac>      DW_TAG_member
                        DW_AT_name                  hello
                        DW_AT_type                  <0x00000061>
                        DW_AT_data_member_location  8
```

Каждое поле структуры указывает свой тип (`DW_AT_type`) и смещение (`DW_AT_member_location`).
Чтение структуры можно свести к циклу: читаем тип (`DW_AT_type`) по адресу `base_addr + DW_AT_member_location`, где `base_addr` - это адрес начала структуры.

Собственно, таким образом и реализуется логика чтения структуры:

<spoiler title="get_struct_values">

TODO: код

</spoiler>

#### Указатель

Когда встречается указатель, то вывожу то, на что он указывает, то есть разыменовываю указатель.
А дальнейшая обработка зависит уже от типа на который указывал.

Вся необходимая логика уже написана, все что осталось прочитать значение указателя.

<spoiler title="Чтение значения указателя">

TODO: код - часть case TypeKindPointer

</spoiler>

### Цепочка вызовов

В процессе работы может быть вызвано множество функций. Было бы полезно просмотреть весь стек вызовов.
Сейчас мы эту функциональность реализуем.

Для этого нам понадобится использовать 2 регистра - `RBP` и `RIP`.
В начале получаем `RIP` и с его помощью находим текущее расположение.

Теперь осталось найти функции выше по стеку. Здесь потребуется использовать регистр `RBP` - он указывает на базу фрейма.
У каждой функции свой фрейм и, чтобы сохранить его между вызовами различных функций, каждая новая функция сохраняет старое значение в своем фрейме.
Таким образом, они образуют связный список, где текущий фрейм указывает на предыдущий.
С помощью этого мы можем проитерироваться по фреймам, но нам нужно еще найти функции, которым принадлежат эти фреймы.
Это мы сделаем с помощью другого значения, что сохраняется во фрейме - адрес возврата. Он хранится по адресу `RBP + 0x8`.

В итоге, мы получаем следующую функцию для получения бэктрейса:

<spoiler title="dmbg_get_backtrace">

TODO: код dmbg_get_backtrace

`get_bt_function_at_addr` - это функция, которая по переданному адресу находит ее функцию и соответствующую строку кода. Это мы уже делали на предыдущих шагах.

</spoiler>

### Полезности

Основная функциональность отладчика реализована, но осталось много вспомогательных фичей: отображение исходного кода, чтение регистров и дизассемблирование.

#### Отображение исходного кода

Чтобы отобразить текущее положение в исходном коде нам необходимо знать только `RIP` и таблицу строк: с их помощью мы получаем файл и номер строки в нем.
Но это только путь к файлу, а не его содержимое. Хорошо, что путь к файлу - полный, с корнем. Поэтому алгоритм такой: читаем `RIP`, находим по нему файл и номер строки, открываем этот файл и читаем строки возле указанного номера.

<spoiler title="Отображение исходного кода">

Я разбил логику на 2 части: нахождение файла с номером строки и само отображение содержимого.

TODO: код dmbg_get_src_position

TODO: код команды

</spoiler>

#### Дизассемблирование

Дизассембилрование не каждый день необходимо, но это весьма полезная фича. В частности, она необходима если мы хотим поставить точку останова на ассемблерной команде - нужно знать ее адрес.

Самостоятельно это реализовывать долго и сложно, поэтому я воспользовался библиотекой `libopcodes`.
Она позволяет дизассемблировать код различных архитектур в различном формате (ATT, INTEL).
Скорее всего, вы уже встречали ее - она используется в `objdump`.

Для дизассемблирования ей нужно передать сами инструкции для дизассемблирования. Причем, эта часть сделана обобщенной - мы можем передавать как уже полностью прочитанный файл, либо реализовать callback и при его вызове читать необходимый диапазон данных.
Так как нужно дизассемблировать только текущий участок, то я использовал 2 вариант - реализовал свой callback.

На вход callback'у передается буфер (куда записывать прочитанные данные), адрес (по которому читать) и количество байт (сколько читать).
Он реализован в функции `read_child_memory_opcodes_callback`.

<spoiler title="read_child_memory_opcodes_callback">

TODO: код

</spoiler>

TODO: разница между O0 и Og

## Исследуем gdb

Теперь давайте посмотрим на то, как работают настоящие отладчики. Сделаем это на примере gdb.

<spoiler title="Отступы">

Одна из вещей, которая меня поразила, но не вписывается в повествование - это стиль кода, а точнее отступов.
Первый раз в жизни встретился со стилем GNU - чаще встречал K&R или Allman.

В GNU отступ - 2 пробела, причем скобки имеют свой уровень. Но больше поразило не это, а использование табов и пробелов - они используются совместно.
Ранее, я думал, что табы и пробелы хаотично смешаны, но затем понял, что 1 таб - 8 пробелов (чаще видел 4).
Не знаю почему, но для меня вопрос о табах и пробелах теперь закрыт.

TODO: скриншот табов/пробелов

</spoiler>

### Структура файлов

gdb использует множество библиотек для своей работы. Все они содержатся внутри репозитория. Пройдемся по основным:

- libbfd (Binary File Descriptor) - обработка объектных файлов различного формата (ELF, a.out, IEEE 695, mach-o ...)
- libopcodes - библиотека для дизассемблирования инструкций
- cpu - множество файлов описывающих особенности некоторых архитектур ЦП. Файлы имеют расширения `.cpu` и `.opc`, хотя исходный код `Scheme` и `C` соответственно (в комментарии на 1 строке указан исходный код).
- gas - ассебмлер GNU
- gprof - профилировщик GNU
- libintl - библиотека для интернационализации (основана на gettext)
- ld - линковщик GNU
- libdecnumber - библиотека для работы с десятичными числами (32/64/128 битных)
- libiberty - библиотека, содержащая множество вспомогательных функций, которые используются во многих проектах GNU (например, реализация `random` или `sha`)
- libreadline - библиотека, содержащая множество функций для реализации интерактивной командной строки (история, автодополнение, буферизация...)
- sim - симулятор некоторых ЦП (при запуске gdb в режиме симуляции)
- zlib - библиотека для сжатия
- binutils - набор различных утилит для работы с объектными и исполняемыми файлами (ld, gas, grpof, nm, objdump ...)
- gold - линковщик для ELF файлов с упором на скорость
- elfcpp - библиотека для чтения и записи ELF файлов

### Архитектура

TODO: формат отладки SOM

TODO: ссылка на event-loop файл

Архитектура GDB - событийно-ориентированная. Для обработки событий используется цикл событий.
Его реализация располагается в [`event-loop.c`]().
Всего есть 3 типа событий (в скобках указана функция обработчик типа события):

- Таймауты событий (`poll_timers`)
- Файловые дескрипторы (`gdb_wait_for_event`)
- Асинхронные события (`check_async_event_handlers`)

TODO: уточнить
Работа с командной строкой ведется как с файловым дескриптором.

В проекте существует огромное количество файлов и каждый файл отвечает за свою функциональность.
Каждый такой файл можно считать отдельным модулем со своими интерфейсом и состоянием.
Их достаточно много и для автоматизации существует инфраструктура - каждый модуль определяет глобальную функцию `_initialize_XXX` (где XXX - название какой-либо фукциональности) и в момент сборки (через make) создается функция `initialize_files`, которая поочередно вызывает все эти функции.
Например, в файле `breakpoint.c` находится функционал для работы с точками останова и для его инициализации существует функция `_initialize_breakpoint`.

Для выполнения команд существует своя инфраструктура. Все команды регистрируются в едином реестре.
Регистрация команды выполняется с помощью функции `add_cmd`, причем у функции команды должна быть следующая сигнатура:

```c
void cmd_simple_func_ftype (const char *args, int from_tty);
```

Каждой команде помимо ее аргументов отдается флаг `from_tty` - исполняется ли в интерактивном терминале.

Можно заметить, что все команды - это функции, не методы класса, и передаются только аргументы команды.
Это потому что состояние хранится в глобальных переменных, либо получается через публичный интерфейс (но также хранится в `static` переменных).

В терминах gdb отлаживаемый процесс называется inferrior. Причина этого в том, что отлаживаться может не только процесс, но и core-dump или симулируемый процесс (не настоящий).

gdb должен быть максимально кросс-платформенным и поддерживать самые разнообразные форматы отладки и объектных файлов.
Это достигается с помощью абстракций.

Так, `gdbarch` - структура, которая представляет целевую платформу. Она хранит в себе не только состояние (например, размер переменной `long double`), но и функции взаимодействия (например, для получения `PC` регистра).
Каждая поддерживаемая архитектура реализует все необходимые функции. Если указатель на функцию `NULL`, значит функциональность не реализована/поддерживается.
Например, для функции `skip_main_prologue` нашел поддерживаемые архитектуры: x86_64, x86, FR-V, RS/6000, ARM.

Для расширяемости многие части реализованы в виде интерфейса (в C стиле - структура с указателями).
Многие из таких имеют суффикс `ops`.
Например, есть интерфейсы для:

- Точек останова - `breakpoint_ops` (поставить точку останова)
- Отлаживаемого процесса - `target_ops` (продолжить выполнение, присоединиться)
- Скриптового языка - `extension_language_script_ops` (GDB, python)
- Динамических библиотек - `solib_ops` (открытие, адрес загрузки)
- Чисел с плавающей точкой - `target_float_ops` (мат. операции, приведение к строке, приведение к другому типу)
- Записи трейса - `trace_file_write_ops` (открытие/закрытие файла, запись)
- Вычисления адреса символа - `symbol_computed_ops` (описание расположения, получение значения)

Есть много других, но о них не буду говорить.

<spoiler title="О стиле кода">

TODO: про отступы, стиль кода, смешение C и C++

</spoiler>

Моя машина - Linux, x86_64. Для нее будут использованы следующие ops/функции:

- `svr4_so_ops` - взаимодействие с динамическими библиотеками SVR4
- `code_breakpoint_ops` - дефолтный интерфейс создания точек останова
- `amd64_linux_XXX` - семейство функций для работы с платформой - регистры, стек ... (находятся в `amd64-linux-tdep.c`)
- `i386_gdbarch_tdep` - структура с платформо-зависимыми функциями (включает в себя `amd64_linux_XXX` функции выше)

Теперь, рассмотрим то, как реализуется функциональность написанная ранее.

### Старт

Для начала, рассмотрим что происходит на старте: запуск процесса и чтение символов.

Первым идет чтение символов запускаемого файла - как основные, так и отладочные.
Я компилирую в ELF, поэтому для его чтения используется функция `elf_symfile_read`.

Для чтения отладочных символов DWARF используется `cooked_index_worker`.
Точнее это интерфейс, который реализуют 2 основных класса и каждый ответственнен за свою секцию:

- `cooked_index_debug_names` - `.debug_names`
- `cooked_index_debug_info` - `.debug_info`, `.debug_types` ...

Первый - читает все строки из `.debug_names` секции.
Более интересен второй, так как в `.debug_info` и `.debug_types` содержится основная отладочная информация - DIE.

Логика обработки `.debug_info` (со всеми его DIE) содержится в методе `index_dies` класса `cooked_indexer`.
Там находится большой `while` цикл, проходящийся по всем DIE и рекурсивно спускающийся к дочерним.
Например, вот кусок обработки `DW_TAG_subprogram`:

<spoiler title="Обработка DW_TAG_subprogram">

```c++
const gdb_byte *
cooked_indexer::index_dies (cutu_reader *reader,
			    const gdb_byte *info_ptr,
			    const cooked_index_entry *parent_entry,
			    bool fully)
{
  const gdb_byte *end_ptr = (reader->buffer
			     + to_underlying (reader->cu->header.sect_off)
			     + reader->cu->header.get_length_with_initial ());

  while (info_ptr < end_ptr)
    {
      sect_offset this_die = (sect_offset) (info_ptr - reader->buffer);
      unsigned int bytes_read;
      const abbrev_info *abbrev = peek_die_abbrev (*reader, info_ptr,
						   &bytes_read);
      info_ptr += bytes_read;
      if (abbrev == nullptr)
	break;

      const char *name = nullptr;
      parent_map::addr_type defer {};
      cooked_index_flag flags = IS_STATIC;
      sect_offset sibling {};
      const cooked_index_entry *this_parent_entry = parent_entry;

      info_ptr = scan_attributes (reader->cu->per_cu, reader, info_ptr,
				  info_ptr, abbrev, &name, &linkage_name,
				  &flags, &sibling, &this_parent_entry,
				  &defer, &is_enum_class, false);
      /* ... */
      if (abbrev->has_children)
	{
	  switch (abbrev->tag)
	    {
	    /* ... */
	    case DW_TAG_subprogram:
	      if ((m_language == language_fortran
		   || m_language == language_ada)
		  && this_entry != nullptr)
		{
		  info_ptr = recurse (reader, info_ptr, this_entry, true);
		  continue;
		}
	      break;
	    }
	}
      /* ... */
    }

  return info_ptr;
}
```

Обратите внимание на функцию `recurse`. Она рекурсивно вызывает тот же метод `index_dies`, но в отличие от первого запуска уже передает указатель на родителя:

```c++
const gdb_byte *
cooked_indexer::recurse (cutu_reader *reader,
			 const gdb_byte *info_ptr,
			 const cooked_index_entry *parent_entry,
			 bool fully)
{
  info_ptr = index_dies (reader, info_ptr, parent_entry, fully);

  if (parent_entry != nullptr)
    {
      /* Both start and end are inclusive, so use both "+ 1" and "- 1" to
	 limit the range to the children of parent_entry.  */
      parent_map::addr_type start
	= parent_map::form_addr (parent_entry->die_offset + 1,
				 reader->cu->per_cu->is_dwz);
      parent_map::addr_type end
	= parent_map::form_addr (sect_offset (info_ptr - 1 - reader->buffer),
				 reader->cu->per_cu->is_dwz);
      m_die_range_map->add_entry (start, end, parent_entry);
    }

  return info_ptr;
}
```

</spoiler>

Также стоит обратить внимание и на то как читаются отладочные символы.
В больших программах отладочной информации много и прочитать их все в 1 поток может занять большое количество времени.
Поэтому здесь вступает в работу фоновая многопоточная обработка.

В фоновом потоке запукается основная функция чтения отладочных символов.
Если говорим о gdb, то это значит, что между моментом его запуска (или указания исполняемого файла) до момента когда символы необходимы (сам запуск) может пройти время.
Поэтому чтобы впустую не останавливать работу эта часть переклаывается на фоновый поток и, когда происходит запуск (все отложенные операции надо применить), просто дожидаемся когда этот фоновый воркер закончит работу.

Но это еще не все. Для большей оптимизации эта работа распараллеливается.
У нас есть множество CU, которые между собой не связаны. Это и есть точка распараллеливания.
Но будет плохо если 1 поток возьмет 2 CU по 100Мб, а другой тоже 2, но по 1Мб.
Поэтому для распределения CU используется их размер - каждому выделяется примерно равное количество CU по размеру (сумма размеров CU / количество потоков).

<spoiler title="Иллюстрация">

В комментариях я нашел такую интересную иллюстрацию того как организовано чтение отладочных символов с точки зрения работы кода.

```c++
/* The main index of DIEs.

   The index is created by multiple threads.  The overall process is
   somewhat complicated, so here's a diagram to help sort it out.

   The basic idea behind this design is (1) to do as much work as
   possible in worker threads, and (2) to start the work as early as
   possible.  This combination should help hide the effort from the
   user to the maximum possible degree.

   . Main Thread                |       Worker Threads
   ============================================================
   . dwarf2_initialize_objfile
   . 	      |
   .          v
   .     cooked index ------------> cooked_index_worker::start
   .          |                           / | \
   .          v                          /  |  \
   .       install                      /   |	\
   .  cooked_index_functions        scan CUs in workers
   .          |               create cooked_index_shard objects
   .          |                           \ | /
   .          v                            \|/
   .    return to caller                    v
   .                                 initial scan is done
   .                                state = MAIN_AVAILABLE
   .                              "main" name now available
   .                                        |
   .                                        |
   .   if main thread calls...              v
   .   compute_main_name         cooked_index::set_contents
   .          |                           / | \
   .          v                          /  |  \
   .   wait (MAIN_AVAILABLE)          finalization
   .          |                          \  |  /
   .          v                           \ | /        
   .        done                      state = FINALIZED
   .                                        |
   .                                        v
   .                              maybe write to index cache
   .                                  state = CACHE_DONE
   .
   .
   .   if main thread calls...
   .   any other "quick" API
   .          |
   .          v
   .   wait (FINALIZED)
   .          |
   .          v
   .    use the index
*/
```

</spoiler>

### Точки останова

Перейдем к точкам останова.

В gdb имеется общая структура `breakpoint`. Она может представлять не только точки останова, но трейспоинты ([tracepoint](https://www.sourceware.org/gdb/current/onlinedocs/gdb.html/Tracepoints.html)), и вотчпоинты ([watchpoint](https://www.sourceware.org/gdb/current/onlinedocs/gdb.html/Set-Watchpoints.html)).
Дополнительно, они разделяются на `Software` и `Hardware` - последние реализуются с помощью поддержки железа (как можно догадаться). Например, с их помощью можно реализовать отслеживание изменения какого-либо участка памяти (data breakpoint).

В перечислении `bp_loc_type` хранятся различаемые типы точек останова:

```c
enum bp_loc_type
{
  bp_loc_software_breakpoint,
  bp_loc_hardware_breakpoint,
  bp_loc_software_watchpoint,
  bp_loc_hardware_watchpoint,
  bp_loc_tracepoint,
  bp_loc_other
};
```

Чтобы поставить точку останова необходимо вызвать большое количество функций.
По большей части это все абстракции.

Но логика выставления точки останова практически такая же как написали мы: находим адрес инструкции, читаем старое значение, заменяем первый байт на `0xCC`, записываем и сохраняем старое значение.
TODO: ссылка
Эта логика хранится в [`default_memory_insert_breakpoint`](gdb/mem-break.c)

<spoiler title="default_memory_insert_breakpoint">

```c++
/* Insert a breakpoint on targets that don't have any better
   breakpoint support.  We read the contents of the target location
   and stash it, then overwrite it with a breakpoint instruction.
   BP_TGT->placed_address is the target location in the target
   machine.  BP_TGT->shadow_contents is some memory allocated for
   saving the target contents.  It is guaranteed by the caller to be
   long enough to save BREAKPOINT_LEN bytes (this is accomplished via
   BREAKPOINT_MAX).  */

int
default_memory_insert_breakpoint (struct gdbarch *gdbarch,
				  struct bp_target_info *bp_tgt)
{
  CORE_ADDR addr = bp_tgt->placed_address;
  const unsigned char *bp;
  gdb_byte *readbuf;
  int bplen;
  int val;

  /* Determine appropriate breakpoint contents and size for this address.  */
  bp = gdbarch_sw_breakpoint_from_kind (gdbarch, bp_tgt->kind, &bplen);

  /* Save the memory contents in the shadow_contents buffer and then
     write the breakpoint instruction.  */
  readbuf = (gdb_byte *) alloca (bplen);
  val = target_read_memory (addr, readbuf, bplen);
  if (val == 0)
    {
      /* These must be set together, either before or after the shadow
	 read, so that if we're "reinserting" a breakpoint that
	 doesn't have a shadow yet, the breakpoint masking code inside
	 target_read_memory doesn't mask out this breakpoint using an
	 unfilled shadow buffer.  The core may be trying to reinsert a
	 permanent breakpoint, for targets that support breakpoint
	 conditions/commands on the target side for some types of
	 breakpoints, such as target remote.  */
      bp_tgt->shadow_len = bplen;
      memcpy (bp_tgt->shadow_contents, readbuf, bplen);

      val = target_write_raw_memory (addr, bp, bplen);
    }

  return val;
}
```

</spoiler>

> Также стоит отметить, что точки останова выставляются лениво - только после продолжения выполнения (команда `continue`).
> До этого изменения просто накапливаются.

Но перед тем как переходить к следующему шагу, надо рассмотреть то, как происходит работа с памятью отлаживаемого процесса.
Здесь также используется своя инфраструктура.
Функции `target_read_raw_memory` и `target_write_raw_memory` можно назвать интерфейсом этой инфраструктуры - чтение и запись, соответственно.
Платформо-зависимые функции хранятся в `target_ops` (см. выше). Здесь нам интересна функция/поле `to_xfer_partial`.
Функции которые занимаются чтением/записью памяти имеют в себе `xfer` (`X transFER`) - потому что в ядре своем имеется одна и та же функция, а ее логика зависит от передаваемых аргументов.

gdb хранит внутри вебя кэш памяти процесса. Когда происходит запрос на чтение или запись, то вначале информация ищется в нем.
Этот кэш называется 

Теперь вопрос - как ведется работа с памятью в процессе? В своем отладчике я использовал `ptrace`. Это рабочий подход, но если потребуется прочитать большой участок памяти, то могут возникнуть проблемы с производительностью.
Эта задача решается тем, что мы читаем из файла памяти процесса - `/proc/<PID>/mem`.
Для чтения/записи используются `pread64` и `pwrite64` соответственно (либо обычные `read`/`write` если отсутствуют).

Сама функция для чтения/записи памяти из файла:

<spoiler title="linux_proc_xfer_memory_partial_fd">

```c++
/* Helper for linux_proc_xfer_memory_partial and
   proc_mem_file_is_writable.  FD is the already opened /proc/pid/mem
   file, and PID is the pid of the corresponding process.  The rest of
   the arguments are like linux_proc_xfer_memory_partial's.  */

static enum target_xfer_status
linux_proc_xfer_memory_partial_fd (int fd, int pid,
				   gdb_byte *readbuf, const gdb_byte *writebuf,
				   ULONGEST offset, LONGEST len,
				   ULONGEST *xfered_len)
{
  ssize_t ret;

  gdb_assert (fd != -1);

  /* Use pread64/pwrite64 if available, since they save a syscall and
     can handle 64-bit offsets even on 32-bit platforms (for instance,
     SPARC debugging a SPARC64 application).  But only use them if the
     offset isn't so high that when cast to off_t it'd be negative, as
     seen on SPARC64.  pread64/pwrite64 outright reject such offsets.
     lseek does not.  */
#ifdef HAVE_PREAD64
  if ((off_t) offset >= 0)
    ret = (readbuf != nullptr
	   ? pread64 (fd, readbuf, len, offset)
	   : pwrite64 (fd, writebuf, len, offset));
  else
#endif
    {
      ret = lseek (fd, offset, SEEK_SET);
      if (ret != -1)
	ret = (readbuf != nullptr
	       ? read (fd, readbuf, len)
	       : write (fd, writebuf, len));
    }

  if (ret == -1)
    {
      linux_nat_debug_printf ("accessing fd %d for pid %d failed: %s (%d)",
			      fd, pid, safe_strerror (errno), errno);
      return TARGET_XFER_E_IO;
    }
  else if (ret == 0)
    {
      /* EOF means the address space is gone, the whole process exited
	 or execed.  */
      linux_nat_debug_printf ("accessing fd %d for pid %d got EOF",
			      fd, pid);
      return TARGET_XFER_EOF;
    }
  else
    {
      *xfered_len = ret;
      return TARGET_XFER_OK;
    }
}
```

</spoiler>

> У этого подхода есть преимущество - мы можем продолжить читать память даже если какой-то поток будет уничтожен.
> Более того - это файл, значит мы можем читать память даже тогда, когда все потоки запущены (`ptrace` такое не допускает)

Но это возможно только если `/proc/<PID>/mem` файл доступен для записи. Для устаревших ядер (в документации указывается ядро RHEL6) происходит откат к `ptrace` реализации.

Логика чтения с помощью `ptrace` заключена в функции `inf_ptrace_peek_poke`.
Она довольно проста - последовательно вызываем `ptrace` пока буфер не окажется нужной длины.
Единственное, что хочется отметить - `ptrace` обернут своей функцией `gdb_ptrace`.

<spoiler title="inf_ptrace_peek_poke">

```c++
/* Transfer data via ptrace into process PID's memory from WRITEBUF, or
   from process PID's memory into READBUF.  Start at target address ADDR
   and transfer up to LEN bytes.  Exactly one of READBUF and WRITEBUF must
   be non-null.  Return the number of transferred bytes.  */

static ULONGEST
inf_ptrace_peek_poke (ptid_t ptid, gdb_byte *readbuf,
		      const gdb_byte *writebuf,
		      ULONGEST addr, ULONGEST len)
{
  ULONGEST n;
  unsigned int chunk;

  /* We transfer aligned words.  Thus align ADDR down to a word
     boundary and determine how many bytes to skip at the
     beginning.  */
  ULONGEST skip = addr & (sizeof (PTRACE_TYPE_RET) - 1);
  addr -= skip;

  for (n = 0;
       n < len;
       n += chunk, addr += sizeof (PTRACE_TYPE_RET), skip = 0)
    {
      /* Restrict to a chunk that fits in the current word.  */
      chunk = std::min (sizeof (PTRACE_TYPE_RET) - skip, len - n);

      /* Use a union for type punning.  */
      union
      {
	PTRACE_TYPE_RET word;
	gdb_byte byte[sizeof (PTRACE_TYPE_RET)];
      } buf;

      /* Read the word, also when doing a partial word write.  */
      if (readbuf != NULL || chunk < sizeof (PTRACE_TYPE_RET))
	{
	  errno = 0;
	  buf.word = gdb_ptrace (PT_READ_I, ptid,
				 (PTRACE_TYPE_ARG3)(uintptr_t) addr, 0);
	  if (errno != 0)
	    break;
	  if (readbuf != NULL)
	    memcpy (readbuf + n, buf.byte + skip, chunk);
	}
      if (writebuf != NULL)
	{
	  memcpy (buf.byte + skip, writebuf + n, chunk);
	  errno = 0;
	  gdb_ptrace (PT_WRITE_D, ptid, (PTRACE_TYPE_ARG3)(uintptr_t) addr,
		  buf.word);
	  if (errno != 0)
	    {
	      /* Using the appropriate one (I or D) is necessary for
		 Gould NP1, at least.  */
	      errno = 0;
	      gdb_ptrace (PT_WRITE_I, ptid, (PTRACE_TYPE_ARG3)(uintptr_t) addr,
			  buf.word);
	      if (errno != 0)
		break;
	    }
	}
    }

  return n;
}
```

</spoiler>

Кроме этих способов есть еще один - системные вызовы `process_vm_readv` и `process_vm_writev`.
Они позволяют читать и писать в адресное пространство другого процесса, причем передать за раз можно несколько буферов (для передачи используется вектор, `v` в названии).
Но его использование отклонили из-за нескольких проблем:

1. `process_vm_writev` не позволяет записывать в RO страницы. Это критический недостаток, так как именно таким способом и ставятся точки останова.
2. `process_vm_*v` может вызвать гонку в моменты, когда дочерний процесс вызывает какой-либо `exec`, так как адресное пространство будет изменено.

TODO: amd64_analyze_prologue - определение пролога функции своими руками, amd64_skip_prologue - пропуск пролога

<spoiler title="Различные точки останова">

TODO: про различные точки останова: longjmp, watchpoint, momentary и т.д.

В gdb существует большое количество типов точек останова.
Хоть они все и делают одно и то же (останавливают работу дочернего процесса), различается метод их обработки.
Их виды описаны в перечислении `bptype`:

```c++
/* Type of breakpoint.  */

enum bptype
  {
    bp_none = 0,		/* Eventpoint has been deleted */
    bp_breakpoint,		/* Normal breakpoint */
    bp_hardware_breakpoint,	/* Hardware assisted breakpoint */
    bp_single_step,		/* Software single-step */
    bp_until,			/* used by until command */
    bp_finish,			/* used by finish command */
    bp_watchpoint,		/* Watchpoint */
    bp_hardware_watchpoint,	/* Hardware assisted watchpoint */
    bp_read_watchpoint,		/* read watchpoint, (hardware assisted) */
    bp_access_watchpoint,	/* access watchpoint, (hardware assisted) */
    bp_longjmp,			/* secret breakpoint to find longjmp() */
    bp_longjmp_resume,		/* secret breakpoint to escape longjmp() */

    /* Breakpoint placed to the same location(s) like bp_longjmp but used to
       protect against stale DUMMY_FRAME.  Multiple bp_longjmp_call_dummy and
       one bp_call_dummy are chained together by related_breakpoint for each
       DUMMY_FRAME.  */
    bp_longjmp_call_dummy,

    /* An internal breakpoint that is installed on the unwinder's
       debug hook.  */
    bp_exception,
    /* An internal breakpoint that is set at the point where an
       exception will land.  */
    bp_exception_resume,

    /* Used by wait_for_inferior for stepping over subroutine calls,
       and for skipping prologues.  */
    bp_step_resume,

    /* Used by wait_for_inferior for stepping over signal
       handlers.  */
    bp_hp_step_resume,

    /* Used to detect when a watchpoint expression has gone out of
       scope.  These breakpoints are usually not visible to the user.

       This breakpoint has some interesting properties:

       1) There's always a 1:1 mapping between watchpoints
       on local variables and watchpoint_scope breakpoints.

       2) It automatically deletes itself and the watchpoint it's
       associated with when hit.

       3) It can never be disabled.  */
    bp_watchpoint_scope,

    /* The breakpoint at the end of a call dummy.  See bp_longjmp_call_dummy it
       is chained with by related_breakpoint.  */
    bp_call_dummy,

    /* A breakpoint set on std::terminate, that is used to catch
       otherwise uncaught exceptions thrown during an inferior call.  */
    bp_std_terminate,

    /* Some dynamic linkers (HP, maybe Solaris) can arrange for special
       code in the inferior to run when significant events occur in the
       dynamic linker (for example a library is loaded or unloaded).

       By placing a breakpoint in this magic code GDB will get control
       when these significant events occur.  GDB can then re-examine
       the dynamic linker's data structures to discover any newly loaded
       dynamic libraries.  */
    bp_shlib_event,

    /* Some multi-threaded systems can arrange for a location in the 
       inferior to be executed when certain thread-related events occur
       (such as thread creation or thread death).

       By placing a breakpoint at one of these locations, GDB will get
       control when these events occur.  GDB can then update its thread
       lists etc.  */

    bp_thread_event,

    /* On the same principal, an overlay manager can arrange to call a
       magic location in the inferior whenever there is an interesting
       change in overlay status.  GDB can update its overlay tables
       and fiddle with breakpoints in overlays when this breakpoint 
       is hit.  */

    bp_overlay_event, 

    /* Master copies of longjmp breakpoints.  These are always installed
       as soon as an objfile containing longjmp is loaded, but they are
       always disabled.  While necessary, temporary clones of bp_longjmp
       type will be created and enabled.  */

    bp_longjmp_master,

    /* Master copies of std::terminate breakpoints.  */
    bp_std_terminate_master,

    /* Like bp_longjmp_master, but for exceptions.  */
    bp_exception_master,

    bp_catchpoint,

    bp_tracepoint,
    bp_fast_tracepoint,
    bp_static_tracepoint,
    /* Like bp_static_tracepoint but for static markers.  */
    bp_static_marker_tracepoint,

    /* A dynamic printf stops at the given location, does a formatted
       print, then automatically continues.  (Although this is sort of
       like a macro packaging up standard breakpoint functionality,
       GDB doesn't have a way to construct types of breakpoint from
       elements of behavior.)  */
    bp_dprintf,

    /* Event for JIT compiled code generation or deletion.  */
    bp_jit_event,

    /* Breakpoint is placed at the STT_GNU_IFUNC resolver.  When hit GDB
       inserts new bp_gnu_ifunc_resolver_return at the caller.
       bp_gnu_ifunc_resolver is still being kept here as a different thread
       may still hit it before bp_gnu_ifunc_resolver_return is hit by the
       original thread.  */
    bp_gnu_ifunc_resolver,

    /* On its hit GDB now know the resolved address of the target
       STT_GNU_IFUNC function.  Associated bp_gnu_ifunc_resolver can be
       deleted now and the breakpoint moved to the target function entry
       point.  */
    bp_gnu_ifunc_resolver_return,
  };
```

Некоторые из них мы будем использовать:

- `bp_single_step`
- `bp_step_resume`
- `bp_finish`

Первые 2 для реализации step over и step in, а 3 - для step out.

</spoiler>

### Step in/out/over

Теперь самая интересная часть - шаги в коде.
Пойдем также - step in, step over, step out. У gdb другое именование - step, next и fininsh соответственно.
Я буду использовать step XXX именование для единообразия.

#### Step over

Обработка step over разделена на 2 части: запуск и обработка останова.
Вспомним, что архитектура событийно-ориентированная, поэтому эти 2 части можно описать так:

- Запуск - настройка окружения и запуск процесса
- Обработка останова - решаем что делать, когда процесс остановился

И вот тут начинается разница с нашей реализацией. В dumbugger я ставил точку останова на все строки внутри этой функции, а после удалял.
В gdb используется другой подход:

> Выполняем по одной инструкции до тех пор пока текущая строка не поменяется.
> Но если мы встретим вызов функции, то ставим точку останова на адрес возврата.

Работает это таким образом. На этапе запуска вызывается `step_1`.
Главное что она выполняет - инициализирует `thread_control_state`.
Это структура, которая хранит состояние для выполнения логики `step`.
Например, диапазон PC текущей строки, фрейм, в котором начали выполнение, и т.д.

После того, как определились начинаем выполнять по одной инструкции - `ptrace(PTRACE_SINGLESTEP)`.
На этом завершается 1 и начинается 2 часть.
Она заключается в постоянной обработке остановки дочернего процесса - каждый раз после его остановки соответствующий сигнал будет отправляться gdb (событийно-ориентированная архитектура).

Когда мы выполняем инструкции, у нас есть 2 исхода - переходим к следующей инструкции или вызываем функцию.
Каждый раз, когда мы останавливаемся, то проверяем где:

1. В том же диапазоне инструкций
2. Вышли за диапазон, но заметили, что находимся в начале какой-то функции
3. Вышли за диапазон

3-ий случай - завершение работы. На этом можно вернуть управление пользователю и продолжать выполнять его команды.
Но нас интересуют 2 остальных.

Если мы находимся в том же диапазоне, то продолжаем выполнение. Но выполняем по одной инструкции за раз.
Благодаря этому нам не надо постоянно перезаписывать память процесса (ставить точки останова).
Обнаруживаем это с помощью такой проверки:

```c++
if (pc_in_thread_step_range (ecs->event_thread->stop_pc (),
			     ecs->event_thread)
    && (execution_direction != EXEC_REVERSE
	|| *curr_frame_id == original_frame_id))
  {
    /* ... */
    keep_going (ecs);
  }
```

Но что если мы вызывали функцию? gdb в этом случае ставит точку на адресе возврата и продолжает выполнение.
По возвращении выполняет ту же самую проверку (3 варианта выше).
За эту ситуацию отвечает этот код:

```c++
if ((get_stack_frame_id (frame)
     != ecs->event_thread->control.step_stack_frame_id)
    && get_frame_type (frame) != SIGTRAMP_FRAME
    && ((frame_unwind_caller_id (frame)
         == ecs->event_thread->control.step_stack_frame_id)
	&& ((ecs->event_thread->control.step_stack_frame_id
	     != outer_frame_id)
	    || (ecs->event_thread->control.step_start_function
		!= find_pc_function (ecs->event_thread->stop_pc ())))))
  {
    /* ... */
    if (ecs->event_thread->control.step_over_calls == STEP_OVER_ALL)
      {
        insert_step_resume_breakpoint_at_caller (frame);
        keep_going (ecs);
        return;
      }
  }
```

Можно заметить, что для проверки функций используется структура `frame_id`.
gdb для каждой функции создает свой уникальный слепок. Он вычисляется в функции `compute_frame_id`.
Внутри же вызывается функция из поля `this_id` - именно в ней и содержится основная логика.
Например, для моей программы вызвалась `dwarf2_frame_this_id`, так как я использовал символы отладки DWARF.

#### Step in

На самом деле, step in и step over - это один и тот же код, просто изначальные условия (`thread_control_state`) немного отличаются: поле `step_over_calls` для `step over` равно `STEP_OVER_ALL`, а для `step in` - `STEP_OVER_NONE`.
Эту разницу можно увидеть так (флаг `skip_subroutines`):

```c++
/* Step until outside of current statement.  */
static void
step_command (const char *count_string, int from_tty)
{
  step_1 (0, 0, count_string);
}

/* Likewise, but skip over subroutine calls as if single instructions.  */
static void
next_command (const char *count_string, int from_tty)
{
  step_1 (1, 0, count_string);
}

static void
step_1 (int skip_subroutines, int single_inst, const char *count_string)
{ /* ... */ }
```

В таком случае, проверка на `STEP_OVER_ALL` (см. код выше) не сработает и мы пойдем дальше.
А дальше нас ждем другое условие, под которое мы попадаем:

```c++
{
  struct symtab_and_line tmp_sal;

  tmp_sal = find_pc_line (ecs->stop_func_start, 0);
  if (tmp_sal.line != 0
      && !function_name_is_marked_for_skip (ecs->stop_func_name,
                                            tmp_sal)
      && !inline_frame_is_marked_for_skip (true, ecs->event_thread))
    {
       if (execution_direction == EXEC_REVERSE)
         /* ... */
       else
         handle_step_into_function (gdbarch, ecs);
       return;
    }
}
```

`handle_step_into_function` - функция, которая продолжает выполнение до первой строки исходного кода.

#### Step out

Step out реализован немного по другому.
Вначале мы также выставляем точку остнова. Ставим ее на адрес возврата и продолжаем выполнение.
Состояние программы представляется как цепочка фреймов (вызовов функций).
Для получения адреса возврата нам нужно получить предыдущий фрейм в этой цепочке и получить его PC ().
Предыдущий фрейм находится с помощью функции `get_prev_frame`.

В функции `finish_forward` заключаются действия 1-ой части - ставим точку останова и продолжаем работу:

```c++
static void
finish_forward (struct finish_command_fsm *sm, const frame_info_ptr &frame)
{
  struct frame_id frame_id = get_frame_id (frame);
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct symtab_and_line sal;
  struct thread_info *tp = inferior_thread ();

  sal = find_pc_line (get_frame_pc (frame), 0);
  sal.pc = get_frame_pc (frame);

  sm->breakpoint = set_momentary_breakpoint (gdbarch, sal,
					     get_stack_frame_id (frame),
					     bp_finish);

  set_longjmp_breakpoint (tp, frame_id);

  /* We want to print return value, please...  */
  tp->control.proceed_to_finish = 1;

  proceed ((CORE_ADDR) -1, GDB_SIGNAL_DEFAULT);
}
```

Когда точка останова выставлена, то процесс продолжает работу, и после остановки удаляется.

Из интересного - обнаружение `main` - входной точки. В случае step out это важно, так как выходить за пределы `main` нет смысла.
За это отвечает функция `inside_main_func`. Ее логика проста: получаем название входной точки (символ) и проверяем, что текущий фрейм не этой функции.
2-ая часть проста - надо проверить адрес. Но 1-ая часть не тривиальна, так как в разных ЯП разное название входной точки.
Но это решается просто - функция `main_name` возвращает символ входной точки.
В начале проверяется, что есть символы специфичные для ЯП: `__gnat_ada_main_program_name` (ADA), `D main` (D), `main.main` (go), `_p__M0_main_program` или `pascal_main_program` (Pascal).
Если не нашлись, то используется стандартный `main`.

### Отображение значений

Так как значения типов зависят от языка, то и за отображение ответственнен он (ЯП).
Другая важная функциональность - вывод состояния (значения переменных, адресов памяти и т.д.).
В gdb есть 2 команды для печати:

- `x` - скалярное значение по переданному адресу
- `print` - вычисление выражение и вывод результата в соответствии с его реальным типом

Они разные, но в конечном счете обе используют одни и те же функции, только с разными аргументами.
Можно выделить 2 функции:

- `value_print_scalar_formatted`
- `value_print`

Вначале рассмотрим 1 функцию. Она выводит в лог скалярное значение.
Максимальная типизация - указание размера числа и знаковость.
Спускаясь ниже по стеку вызовов, за саму печать разных форматов чисел используются разные функции:

- `print_XXX_chars` - число указанной длинны в указанном XXX основании, например, `print_hex_chars`
- `print_floating` - число с плавающей точкой
- `print_address` - адрес

Многие из этих функций достойны внимания.

- `print_octal_chars` - выводит число в восьмеричной системе. Загвоздка заключается в том, что каждая цифра представляется 3 битами - не кратно 4.
  Поэтому было принято решение - разлить логику на циклы по 3 шага. В каждом происходит перенос оставшихся бит на следующий шаг. Таким образом, за 3 шага мы обрабатываем 24 бита = 3 байта.

<spoiler title="print_octal_chars">

```c++
   void
print_octal_chars (struct ui_file *stream, const gdb_byte *valaddr,
		   unsigned len, enum bfd_endian byte_order)
{
  const gdb_byte *p;
  unsigned char octa1, octa2, octa3, carry;
  int cycle;

  /* Octal is 3 bits, which doesn't fit.  Yuk.  So we have to track
   * the extra bits, which cycle every three bytes:
   *
   * Byte side:       0            1             2          3
   *                         |             |            |            |
   * bit number   123 456 78 | 9 012 345 6 | 78 901 234 | 567 890 12 |
   *
   * Octal side:   0   1   carry  3   4  carry ...
   *
   * Cycle number:    0             1            2
   *
   * But of course we are printing from the high side, so we have to
   * figure out where in the cycle we are so that we end up with no
   * left over bits at the end.
   */
#define BITS_IN_OCTAL 3
#define HIGH_ZERO     0340
#define LOW_ZERO      0034
#define CARRY_ZERO    0003
#define HIGH_ONE      0200
#define MID_ONE       0160
#define LOW_ONE       0016
#define CARRY_ONE     0001
#define HIGH_TWO      0300
#define MID_TWO       0070
#define LOW_TWO       0007

  /* For 32 we start in cycle 2, with two bits and one bit carry;
     for 64 in cycle in cycle 1, with one bit and a two bit carry.  */

  cycle = (len * HOST_CHAR_BIT) % BITS_IN_OCTAL;
  carry = 0;

  gdb_puts ("0", stream);
  bool seen_a_one = false;
  for (p = valaddr + len - 1;
       p >= valaddr;
       p--)
    {
      switch (cycle)
        {
	  case 0:
	    /* Carry out, no carry in */

	    octa1 = (HIGH_ZERO & *p) >> 5;
	    octa2 = (LOW_ZERO & *p) >> 2;
	    carry = (CARRY_ZERO & *p);
	    emit_octal_digit (stream, &seen_a_one, octa1);
	    emit_octal_digit (stream, &seen_a_one, octa2);
	    break;

	  case 1:
	    /* Carry in, carry out */
            octa1 = (carry << 1) | ((HIGH_ONE & *p) >> 7);
	    octa2 = (MID_ONE & *p) >> 4;
	    octa3 = (LOW_ONE & *p) >> 1;
	    carry = (CARRY_ONE & *p);
	    emit_octal_digit (stream, &seen_a_one, octa1);
	    emit_octal_digit (stream, &seen_a_one, octa2);
	    emit_octal_digit (stream, &seen_a_one, octa3);
	    break;

	  case 2:
	    /* Carry in, no carry out */

	    octa1 = (carry << 2) | ((HIGH_TWO & *p) >> 6);
	    octa2 = (MID_TWO & *p) >> 3;
	    octa3 = (LOW_TWO & *p);
	    carry = 0;
	    emit_octal_digit (stream, &seen_a_one, octa1);
	    emit_octal_digit (stream, &seen_a_one, octa2);
	    emit_octal_digit (stream, &seen_a_one, octa3);
	    break;

	  default:
	    error (_("Internal error in octal conversion;"));
	}

      cycle++;
      cycle = cycle % BITS_IN_OCTAL;
    }
}
```

</spoiler>

- `print_decimal_chars` - эта функция выводит число в десятичном представлении.
  В ней используется достаточно интересный алгоритм - он переводит в десятичное представление шестандцатеричное любой длины (то есть не только кратное 2 - short, int, long).

<spoiler title="print_decimal_chars">

В идее этого алгоритма, то что число представляется в виде потока байт, а сам байт - это 2 шестнадцатеричных числа.
Все что нам нужно - это пройтись по всем этим числам и сконвертировать.

Для хранения результирующего числа используется вектор.
Количество цифр мы уже можем оценить - оно точно не больше чем количество шестнадцатеричных умноженное в 2 раза (так как шестнадцатеричное число может быть больше 10).
Поэтому, этот вектор сразу инициализируем этим количеством.
Сам этот вектор будет хранить цифры нашего десятичного числа.

Теперь переходим к самой идее.
Здесь используется примерно тот же алгоритм, что и при обычном переводе числа из 16-ого основания в 10-е.
Работа происходит итерациями. На каждой итерации мы проходимся по всем полубайтам (шестнадцатеричным цифрам) исходного числа от MSB до LSB.

Как мы добавим *шестнадцатеричное* число к *десятичному*?
Переведем его в десятичное основание и сложим.
Но наше число хранится в виде вектора цифр - нам придется также раскладывать число по разрядам и складывать.
Это накладно поэтому используется другой подход.

Мы берем очередной полубайт и складываем его с нашей *первой цифрой*.
А затем лавинно переносим в следующий разряд переполнение.

Еще одна важная деталь - мы проходим от MSB до LSB.
Если мы будем просто складывать числа и делать простой перенос, то знание о разрядах потеряется.
То есть, просто складывая мы не получим корректного ответа, если в числе будет больше 1 байта.
Для учета разряда в алгоритме сделан такой подход: перед тем как переходить к следующему полубайту предыдущее число сдвигается на 1 разряд (умножается на 16).
Если мы умножим каждую цифру в десятичном числе на 16, то мы сдвинем влево шестнадцатеричное на 1 разряд (припишем справа `0`).
А теперь магия - если к этому числу добавить очередной полубайт, то получится то же самое число до этого разряда.

Таким образом, в конце каждой итерации у нас на руках десятичное представление для шестнадцатеричного числа до N разряда (с начала).
Как только мы доходим до 0 разряда, то алгоритм завершен.

Чтобы лучше понять, рассмотрим такой пример - перевод числа `4D2` (это десятичное 1234).
В шагах я буду указывать что находится в векторе цифр:

| Цифра (итерация) | Вектор      |
| ---------------- | ----------- |
| 4                | 4 0 0 0     |
| D                | 64 0 0 0    |
|                  | 77 0 0 0    |
|                  | 7 7 0 0     |
| 2                | 112 112 0 0 |
|                  | 114 112 0 0 |
|                  | 4 123 0 0   |
|                  | 4 3 12 0    |
|                  | 4 3 2 1     |

Можете заметить, что в конце каждой итерации мы получаем десятичные числа для числа до определенного разряда (если обрезать):

- 4 - 4
- 4D - 77
- 4D2 - 1234

P.S. цифры в векторе в обратном порядке

```c++
void
print_decimal_chars (struct ui_file *stream, const gdb_byte *valaddr,
		     unsigned len, bool is_signed,
		     enum bfd_endian byte_order)
{
#define TEN             10
#define CARRY_OUT(  x ) ((x) / TEN)	/* extend char to int */
#define CARRY_LEFT( x ) ((x) % TEN)
#define SHIFT( x )      ((x) << 4)
#define LOW_NIBBLE(  x ) ( (x) & 0x00F)
#define HIGH_NIBBLE( x ) (((x) & 0x0F0) >> 4)

  const gdb_byte *p;
  int carry;
  int decimal_len;
  int i, j, decimal_digits;
  int dummy;
  int flip;

  gdb::byte_vector negated_bytes;
  if (is_signed
      && maybe_negate_by_bytes (valaddr, len, byte_order, &negated_bytes))
    {
      gdb_puts ("-", stream);
      valaddr = negated_bytes.data ();
    }

  /* Base-ten number is less than twice as many digits
     as the base 16 number, which is 2 digits per byte.  */

  decimal_len = len * 2 * 2;
  std::vector<unsigned char> digits (decimal_len, 0);

  /* Ok, we have an unknown number of bytes of data to be printed in
   * decimal.
   *
   * Given a hex number (in nibbles) as XYZ, we start by taking X and
   * decimalizing it as "x1 x2" in two decimal nibbles.  Then we multiply
   * the nibbles by 16, add Y and re-decimalize.  Repeat with Z.
   *
   * The trick is that "digits" holds a base-10 number, but sometimes
   * the individual digits are > 10.
   *
   * Outer loop is per nibble (hex digit) of input, from MSD end to
   * LSD end.
   */
  decimal_digits = 0;		/* Number of decimal digits so far */
  p = (byte_order == BFD_ENDIAN_BIG) ? valaddr : valaddr + len - 1;
  flip = 0;
  while ((byte_order == BFD_ENDIAN_BIG) ? (p < valaddr + len) : (p >= valaddr))
    {
      /*
       * Multiply current base-ten number by 16 in place.
       * Each digit was between 0 and 9, now is between
       * 0 and 144.
       */
      for (j = 0; j < decimal_digits; j++)
	{
	  digits[j] = SHIFT (digits[j]);
	}

      /* Take the next nibble off the input and add it to what
       * we've got in the LSB position.  Bottom 'digit' is now
       * between 0 and 159.
       *
       * "flip" is used to run this loop twice for each byte.
       */
      if (flip == 0)
	{
	  /* Take top nibble.  */

	  digits[0] += HIGH_NIBBLE (*p);
	  flip = 1;
	}
      else
	{
	  /* Take low nibble and bump our pointer "p".  */

	  digits[0] += LOW_NIBBLE (*p);
	  if (byte_order == BFD_ENDIAN_BIG)
	    p++;
	  else
	    p--;
	  flip = 0;
	}

      /* Re-decimalize.  We have to do this often enough
       * that we don't overflow, but once per nibble is
       * overkill.  Easier this way, though.  Note that the
       * carry is often larger than 10 (e.g. max initial
       * carry out of lowest nibble is 15, could bubble all
       * the way up greater than 10).  So we have to do
       * the carrying beyond the last current digit.
       */
      carry = 0;
      for (j = 0; j < decimal_len - 1; j++)
	{
	  digits[j] += carry;

	  /* "/" won't handle an unsigned char with
	   * a value that if signed would be negative.
	   * So extend to longword int via "dummy".
	   */
	  dummy = digits[j];
	  carry = CARRY_OUT (dummy);
	  digits[j] = CARRY_LEFT (dummy);

	  if (j >= decimal_digits && carry == 0)
	    {
	      /*
	       * All higher digits are 0 and we
	       * no longer have a carry.
	       *
	       * Note: "j" is 0-based, "decimal_digits" is
	       *       1-based.
	       */
	      decimal_digits = j + 1;
	      break;
	    }
	}
    }

  /* Ok, now "digits" is the decimal representation, with
     the "decimal_digits" actual digits.  Print!  */

  for (i = decimal_digits - 1; i > 0 && digits[i] == 0; --i)
    ;

  for (; i >= 0; i--)
    {
      gdb_printf (stream, "%1d", digits[i]);
    }
}
```

</spoiler>

- `print_floating` - выводит число с плавающей точкой. Здесь интересно то, что для работы с плавающей точкой используется интерфейс - `target_float_ops`.
   На моей машине используется формат float IEEE 754 одинарной точности, поэтому для работы с ней используется структура `floatformat`.
   Для вывода значения используется 3 шага: 1) создается строку форматирования, 2) конвертируем в формат float исполняемой машины и 3) выводим с помощью `printf`.

- `print_binary_chars` - выводит двоичное представление числа. Здесь все просто - проходим по всем битам и выводим.
  Но даже здесь есть интересная часть - обнаружение ниббла без всех нулей.
  Если такой встретился, то мы должны вывести его весь. Причина этого куска проста - нибблы равные 0000 отображаются просто как 0 (чтобы уменьшить занимаемое место)

<spoiler title="print_binary-char">

```c++
void
print_binary_chars (struct ui_file *stream, const gdb_byte *valaddr,
		    unsigned len, enum bfd_endian byte_order, bool zero_pad,
		    const struct value_print_options *options)
{
  const gdb_byte *p;
  unsigned int i;
  int b;
  bool seen_a_one = false;
  const char *digit_separator = nullptr;

  /* Declared "int" so it will be signed.
     This ensures that right shift will shift in zeros.  */

  const int mask = 0x080;

  if (options->nibblesprint)
    digit_separator = current_language->get_digit_separator();

  for (p = valaddr + len - 1;
     p >= valaddr;
     p--)
  {
    for (i = 0; i < (HOST_CHAR_BIT * sizeof (*p)); i++)
      {
        if (options->nibblesprint && seen_a_one && i % 4 == 0)
  	  gdb_putc (*digit_separator, stream);

        if (*p & (mask >> i))
  	  b = '1';
        else
  	  b = '0';

        if (zero_pad || seen_a_one || b == '1')
  	  gdb_putc (b, stream);
        else if (options->nibblesprint)
  	{
          /* Обнаружение не нулевого ниббла */
  	  if ((0xf0 & (mask >> i) && (*p & 0xf0))
  	      || (0x0f & (mask >> i) && (*p & 0x0f)))
  	    gdb_putc (b, stream);
  	}

        if (b == '1')
  	  seen_a_one = true;
      }
  }

  /* When not zero-padding, ensure that something is printed when the
     input is 0.  */
  if (!zero_pad && !seen_a_one)
    gdb_putc ('0', stream);
}
```

</spoiler>

Когда дело доходит до `print` ситуация иная. Ему на вход поступает выражение из родного ЯП.
Его нужно не только вычислить (для получения результата), но и понять тип для его корректного отображения.

ЯП представляется базовым классом `language_defn` - от него наследуются все конкретные ЯП.
Например, для C это будет класс `c_language`. Также есть и для ADA, D, rust и др.
В этом классе нам интересен метод `value_print`. Он печатает переданное значение.
Для языка C реализация есть в функции `c_value_print_inner`.

Если посмотреть в нее, то можно заметить уже знакомый шаблон: проверяем `typedef`, а затем выводим в соответствии с типом (gdb использует внутренние типы, общие для многих ЯП, как например, массив или целое число).

<spoiler title="c_value_print_inner">

```c++
void
c_value_print_inner (struct value *val, struct ui_file *stream, int recurse,
		     const struct value_print_options *options)
{
  struct type *type = val->type ();

  type = check_typedef (type);
  switch (type->code ())
    {
    case TYPE_CODE_ARRAY:
      c_value_print_array (val, stream, recurse, options);
      break;

    case TYPE_CODE_PTR:
      c_value_print_ptr (val, stream, recurse, options);
      break;

    case TYPE_CODE_UNION:
    case TYPE_CODE_STRUCT:
      c_value_print_struct (val, stream, recurse, options);
      break;

    case TYPE_CODE_CHAR:
    case TYPE_CODE_INT:
      c_value_print_int (val, stream, options);
      break;

    case TYPE_CODE_METHODPTR:
    case TYPE_CODE_MEMBERPTR:
    case TYPE_CODE_REF:
    case TYPE_CODE_RVALUE_REF:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_FLAGS:
    case TYPE_CODE_FUNC:
    case TYPE_CODE_METHOD:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_RANGE:
    case TYPE_CODE_FLT:
    case TYPE_CODE_DECFLOAT:
    case TYPE_CODE_VOID:
    case TYPE_CODE_ERROR:
    case TYPE_CODE_UNDEF:
    case TYPE_CODE_COMPLEX:
    default:
      generic_value_print (val, stream, recurse, options, &c_decorations);
      break;
    }
}
```

</spoiler>

Как выводятся целые числа (TYPE_CODE_INT, TYPE_CODE_CHAR) знаем - `value_print_scalar_formatted` (вызывается внутри).
Рассмотрим то, как выводится структура (TYPE_CODE_STRUCT).

За ее отображение отвечает функция `cp_print_value_fields`.
Отображение полей структуры можно грубо описать циклом по каждому полю: выводим название поля и его значение.
Для представления типов используется структура `type`. Она хранит в себе всю информацию о типе, который представляет.
Поля структуры (у типа) хранятся в виде массива и доступ к ним происходит аналогично - по индексу.
Само поле представляется структурой `field`. У нее есть интересующий нас метод - `name`, он возвращает название поля.

Но для получения поля структуры используется не `type` и не `field` - структура `value`.
Это структура, которая представляет какое-либо значение, но о своем типе не знает.
И в нем нам нужен метод `primitive_field` - он позволяет получить значение (другой `value`) поля. Но так как `value` о своем типе не знает, то мы его передаем (сам тип родительской структуры).
Если посмотреть на реализацию `primitive_field`, то можно увидеть уже знакомые шаги:

- Получаем тип родителя и поля
- Проверяем их `typedef`
- Находим смещение поля относительно структуры
- Читаем значение поля

<spoiler title="primitive_field">

```c++
struct value *
value::primitive_field (LONGEST offset, int fieldno, struct type *arg_type)
{
  struct value *v;
  struct type *type;
  int unit_size = gdbarch_addressable_memory_unit_size (arch ());

  arg_type = check_typedef (arg_type);
  type = arg_type->field (fieldno).type ();

  check_typedef (type);

  if (arg_type->field (fieldno).bitsize ())
    {
      /* Упакованная структура */
    }
  else if (fieldno < TYPE_N_BASECLASSES (arg_type))
    {
      /* Поле базового класса */
    }
  else if (NULL != TYPE_DATA_LOCATION (type))
    {
      /* Динамическое поле */
    }
  else
    {
      /* Обычное поле */
      offset += (arg_type->field (fieldno).loc_bitpos ()
		 / (HOST_CHAR_BIT * unit_size));

      if (this->lval () == lval_register && lazy ())
	fetch_lazy ();

      if (lazy ())
	v = value::allocate_lazy (type);
      else
	{
	  v = value::allocate (type);
	  contents_copy_raw (v, v->embedded_offset (),
			     embedded_offset () + offset,
			     type_length_units (type));
	}
      v->set_offset (this->offset () + offset + embedded_offset ());
    }
  v->set_component_location (this);
  return v;
}
```

Далее, для вывода значения используется функция `common_val_print`.
Но как уже ранее было сказано, значения (их отображение и интерпретация) часто зависят от ЯП, поэтому в реальности вывод значения делегируется самому ЯП - методу `value_print` класса `language_defn`.
Таким образом, мы входим в рекурсию.

</spoiler>

### Цепочка вызовов

Теперь перейдем к backtrace, отображении цепочки вызовов до текущей функции.
Здесь все просто - вся логика это просто цикл, в котором мы идем к каждому предыдущему фрейму и отображаем информацию о нем.
Это реализуется в цикле:

```c++
static void
backtrace_command_1 (const frame_print_options &fp_opts,
		     const backtrace_cmd_options &bt_opts,
		     const char *count_exp, int from_tty)

{
  frame_info_ptr fi;
  int count;
  int py_start = 0, py_end = 0;
  enum ext_lang_bt_status result = EXT_LANG_BT_ERROR;
  
  /* ... */

  if (bt_opts.no_filters || result == EXT_LANG_BT_NO_FILTERS)
    {
      frame_info_ptr trailing;
      
      /* ... */

      for (fi = trailing; fi && count--; fi = get_prev_frame (fi))
	{
	  print_frame_info (fp_opts, fi, 1, LOCATION, 1, 0);
	  if ((flags & PRINT_LOCALS) != 0)
	    print_frame_local_vars (fi, false, NULL, NULL, 1, gdb_stdout);

	  trailing = fi;
	}
      
      /* ... */

    }
}
```

За отображение информации о фрейме (часть `print_frame_info`) отвечает функция `print_frame`.

# Особенности управляемых языков

До этого момента мы говорили о C (возможно C++), но большая часть разработчиков использует более высокоуровневые языки - Python, Java, C#, JavaScript.
Есть и другие ЯП, но рассмотрю только их.

## C\#

TODO: структура события добавить код (а то он один без структуры события)

В директории `src/coreclr/debug` - все экспортируемые платформой сущности, используемые для отладки.
Директория `di` - debug interface. В ней содержится публичный интерфейс.

Файлы:

- `breakpoint.cpp` - работа с точками останова

DAC - Data Access Component (основной интерфейс для взаимодействия)

DBI - CLR debugger interface (COM)

Файл `src/coreclr/pal/prebuilt/inc/cordebug.h` - объявления для вспомогательных файлов.
Для взаимодействия с платформой (и отлаживаемым процессом) объявлен свой интерфейс.

> В `cordebug.h` он сгенерирован с помощью компилятора MIDL и имеет реализацию как для C++, так и для C - интерфейсы (класс с нулевыми виртуальными функциями) и структура + функции соответственно.

Существует большое количество интерфейсов и все они ответственны за свою область. Например, существует интерфейс ``

Главный момент здесь в том, что рантайм сделан кросс-платформенным и он различает HOST (где запускается) и TARGET (на какой машине должен запускаться). Эта разница чувствуется, когда дамп с линукса отлаживается на Windows.
Поэтому некоторая часть работы отдается конвертации форматов и т.п.

Класс `DebugInterface` - COM отладчик (интерфейс к нему)

Дополнительно, имеется 2 интерфейса отладки - DAC и DBI:

- DBI - интерфейс отладчика CLR.
- DAC, Data Access Component - современный инт

Мы взаимодействуем в DBI, а он в свою очередь все запросы конвертирует в интерфейс DAC.
Для этого выделен отдельный интерфейс `IDacDbiInterface`.

У отладчика разделяют 2 части - left-side и right-side. Left-side - отладчик на стороне самого процесса (RC, Runtime-Controller); Right-side - это сторона запускающего (DI, Debugger Interface).
Таким образом, процесс отладки - это взаимодействие отладчика на строне отлаживаемого процесса и отладчика с нашей стороны.
Сейчас рассматривать будем LHS - способ взаимодействия с управляемым кодом.
Файлы для LHS/RC описаны в директории `ee` (часто можно увидеть аббревиатуру EE - Execution Engine), а для RHS/DI - в `di`.

Что до RHS, то его интерфейс описан в файле `src/coreclr/pal/prebuilt/inc/cordebug.h` - приведены основные интерфейсы отладчика.
Если реализовывать свой отладчик, то скорее всего использовать нужно эту часть - левая остается на рантайме (предположение).

Для взаимодействия между LHS и RHS используются события.
Структура `DebuggerIPCEvent` представляет такое событие.
Можно заметить, что используется IPC.
Все IPC события описаны в файле `src/coreclr/debug/inc/dgbipceventtypes.h`, причем в обе строны - как RHS -> LHS, так и наоборот.

> Для отправки событий используются различные стратегии в зависимости от цели (я нашел 4 реализации).
> Но если отлаживаемый процесс находится локально, то используется механизм общей памяти - событие записывается в память отлаживаемого процесса (DCB, Debugger IPC Control Block), а затем выставляется Condition Variable и LHS узнает о событии.

Рассмотрим как реализуются основные операции.

### Точки останова

Событие для точек останова:

- `DB_IPCE_BREAKPOINT_ADD` - выставление точки остнова
- `DB_IPCE_BREAKPOINT_REMOVE` - удаление точки останова

Сама точка останова представляется классом `DebuggerBreakpoint`.
Так как код управляемый и JIT компилируется, то в процессе выполнения наш код может быть либо уже скомпилирован в нативный, либо хранится все еще в IL.
Этот класс отвечает за оба случая.

> Можно заметить, что используется паттерн RAII - функция выставления точки останова вызывается из конструктора.

Для выставления точки останова в машинном коде используется функция `AddBindAndActivateNativeManagedPatch`.
Выставление точки останова и патчинг очень похожи. Это отражается и в коде:

- класс `DebuggerControllerPatch` представляет изменения в коде
- метод `DebuggerController::ApplyPatch` применяет переданный патч
- в глобальном переменной-массиве `g_patches` хранятся все патчи (точки останова)

Инструкция точки останова платформо-зависимая. Это отражается и в реализации.
За выставление точки останова (непосредственно по адресу) ответственна функция `CORDbgInsertBreakpoint`.
У нее есть множество реализаций - на каждую поддерживаемую архитектуру:

- `x86_64`
- `x86`
- `LoongArch`
- `RISC-V`
- `ARM`

Если посмотрим на реализацию x86_64, то увидим знакомые действия:

```c++
inline void CORDbgInsertBreakpoint(UNALIGNED CORDB_ADDRESS_TYPE *address)
{
    *((unsigned char*)address) = 0xCC; // int 3 (single byte patch)
    FlushInstructionCache(GetCurrentProcess(), address, 1);
}
```

За патч в IL код отвечается функция `AddILPatch`.
Здесь нельзя просто взять и вписать инструкцию останова, так как один и тот же код может быть за-JIT-ен множество раз - причина generic'и.
Поэтому используется такой подход: мы также создаем патч, но не применяем его - он будет применен уже после JIT компиляции.
Когда код будет скомпилирован, то для него будет создан новый патч - и вот уже он будет применен.
Такой патч (для IL кода еще не скомпилированного) называется Primary Patch и за его выставление ответственна функция `AddILPrimaryPatch`.

TODO: при достижении точки останова что делаем
При достижении точки останова мы также создаем событие - `DB_IPCE_BREAKPOINT`.
Только оно идет уже в обратную сторону - LHS -> RHS.

Когда мы хотим продолжить выполнение, то точку останова (инструкцию) нужно убрать.
За удаление точки останова отвечает метод `UnapplyPatch` (противоположный `ApplyPatch`).

### Шаги в исходном коде

Шаги также реализованы в виде событий.
Команды:

- `DB_IPCE_STEP` - шаг в коде (поведение зависит от аргументов)
- `DB_IPCE_STEP_OUT` - step out
- `DB_IPCE_STEP_CANCEL` - отмена выполнения шага (код продолжит выполнение (TODO: уточнить))

Ответы:

- `DB_IPCE_STEP_RESULT` - успешная обработка команды выше
- `DB_IPCE_STEP_COMPLETE` - команда выше завершена

Разница между ответами в том, что 1 отправляется сразу, а 2 только когда шаг был завершен.
Это необходимо, так как выполнение шага может занять большое количество времени, а за 1 раз можно обрабатывать только 1 событие.

Таким образом, работа ведется следующим образом:

1. <- `DB_IPCE_STEP`/`DB_IPCE_STEP_OUT`
2. -> `DB_IPCE_STEP_RESULT`
3. *проходит время*
4. -> `DB_IPCE_STEP_COMPLETE`

Разберем как работает `DB_IPCE_STEP`.
Струкрута для этого события выглядит следующим образом:

<spoiler title="Структура события для шага">

Это анонимная структура - поле внутри другой структуры `DebuggerIPCEvent`.

```c++
struct MSLAYOUT
{
    LSPTR_STEPPER        stepperToken;
    VMPTR_Thread         vmThreadToken;
    FramePointer         frameToken;
    bool                 stepIn;
    bool                 rangeIL;
    bool                 IsJMCStop;
    unsigned int         totalRangeCount;
    CorDebugStepReason   reason;
    CorDebugUnmappedStop rgfMappingStop;
    CorDebugIntercept    rgfInterceptStop;
    unsigned int         rangeCount;
    COR_DEBUG_STEP_RANGE range; //note that this is an array
} StepData;
```

</spoiler>

Можно заметить поле `stepIn` - это флаг. Если он выставлен, то необходимо выполнить step in, иначе step out.
Есть и другие, например, поле `rangeIL` - это тоже флаг и используется для указания того, что переданные данные для IL кода, а не нативного.

Логика шагания заключена в классе `DebuggerStepper` и его методе `Step`.

> Также есть класс `DebuggerJMCStepper`. Он используется для JMC, [Just My Code](https://learn.microsoft.com/en-us/visualstudio/debugger/just-my-code?view=vs-2022).
> То есть отладчик будет работать только с нашими функциями и не будет проваливаться во внутренние функции платформы или чужие модули.
> Если флаг `IsJMCStop` в событии выставлен, то будет использоваться эта структура.

Логика шага похожа на gdb - ставим точку останова на следующей выполняемой инструкции.
Но есть главное различие - предсказывание переходов.

Для того, чтобы получить следующую инструкцию используется специальный класс `NativeWalker`.
Его главная задача - дать понять, какого типа инструкция идет дальше.
Он различает 8 типов инструкций. Они определены в перечислении `WALK_TYPE`.

<spoiler title="WALK_TYPE">

```c++
enum WALK_TYPE
{
  WALK_NEXT,
  WALK_BRANCH,
  WALK_COND_BRANCH,
  WALK_CALL,
  WALK_RETURN,
  WALK_BREAK,
  WALK_THROW,
  WALK_META,
  WALK_UNKNOWN
};
```

</spoiler>

При создании инстанса этого класса ему передается PC и состояние регистров.
После этого, мы можем получить тип инструкции, на который PC указывает.
С помощью этого мы и понимаем как ставить точку останова.

Обрабатываются 3 ситуации (в зависимости от текущей инструкции):

- Обычная инструкция - ставим точку останова на следующей инструкции
- RETURN - ставим точку останова по адресу возврата
- CALL - ставим точку останова по указанному в CALL адресу

Но инструкция CALL не такая простая, как я описал. Для него предусмотрено несколько граничных случаев:

- Адрес находится внутри текущей функции
- Используется Tail Call (поддерживается платформой)
- Вызов funclet'ов (мини-функций: внутренних функций, try/catch блоки и т.д. - функция, которая использует стек родителя)

> Эта логика выполняется для управляемого кода, то есть скомпилированного из IL рантаймом.
> Кроме него есть и неуправляемый код.
> Если мы его встречаем, то ничего сделать не можем.
> В таких случаях, документация говорит выполнить step out и поставить точку останова уже в управляемом коде.

Теперь, перейдем к step out. Его логика тажке заключена в классе `DebuggerStepper`, но метод уже `StepOut`.
Сама логика выставления точки останова заключена в `TrapStepOut`.

Happy path простой - ставим точку останова на адресе возврата.

<spoiler title="TrapStepOut - Happy Path">

```c++
// Place a single patch somewhere up the stack to do a step-out
void DebuggerStepper::TrapStepOut(ControllerStackInfo *info, bool fForceTraditional)
{
    ControllerStackInfo returnInfo;
    DebuggerJitInfo *dji;

    while (info->HasReturnFrame())
    {
        // Continue walking up the stack & set a patch upon the next
        // frame up.  We will eventually either hit managed code
        // (which we can set a definite patch in), or the top of the
        // stack.
        StackTraceTicket ticket(info);

        returnInfo.GetStackInfo(ticket, GetThread(), info->GetReturnFrame().fp, NULL, !(m_rgfMappingStop & STOP_UNMANAGED));
        info = &returnInfo;

        if (/* ... */)
        {
            /* Динамически скомпилированный код */
            continue;
        }
        else if (info->m_activeFrame.managed)
        {
            if (info->m_activeFrame.frame == NULL)
            {
                if (!fForceTraditional && !this->IsInterestingFrame(&info->m_activeFrame))
                    continue;

                dji = info->m_activeFrame.GetJitInfoFromFrame();

                // Note: we used to pass in the IP from the active frame to GetJitInfo, but there seems to be no value
                // in that, and it was causing problems creating a stepper while sitting in ndirect stubs after we'd
                // returned from the unmanaged function that had been called.
                ULONG reloffset = info->m_activeFrame.relOffset;

                AddBindAndActivateNativeManagedPatch(info->m_activeFrame.md,
                    dji,
                    reloffset,
                    info->GetReturnFrame().fp,
                    NULL);

                // Do not set m_reason to STEP_RETURN here.  Logically, the funclet and the parent method are the
                // same method, so we should not "return" to the parent method.
                if (!fReturningFromFinallyFunclet)
                {
                    m_reason = STEP_RETURN;
                }
                break;
            }
            else if (info->m_activeFrame.frame == FRAME_TOP)
            {
                /* Единственный фрейм */
                break;
            }
            else if (info->m_activeFrame.frame->GetFrameType() == Frame::TYPE_FUNC_EVAL)
            {
                /*
                 * Динамически вычисляемое выражения.
                 * Например, выражение для отладчика
                 */
                break;
            }
            else if (info->m_activeFrame.frame->GetFrameType() == Frame::TYPE_SECURITY &&
                     info->m_activeFrame.frame->GetInterception() == Frame::INTERCEPTION_NONE)
            {
                /* Фрейм для обработки политик безопасности */
                continue;
            }
            else
            {
                /* Остальные случаи */
            }
        }
        else
        {
            /* Неуправляемый код */
        }
    }
}
```

</spoiler>

Но интересно не это. Если посмотрели на код, то могли заметить, что имеется некоторое количество граничных случаев:

- Динамически скомпилированный код - .NET позволяет своими силами в рантайме создавать сборки, компилировать их и запускать.
  Представьте ситуацию - динамически скомпилированный код вызвал нашу функцию и мы в ней остановились. Что будет, если мы пошлем команду step out?
  В .NET решили, что если на пути встретится фрейм динамического кода, то мы его **пропустим**.
- Единственный фрейм - такое может случиться, если это `Main`. Так как это единственный фрейм, то выход из него означает завершение работы программы.
  То есть, в этом случае мы ничего не будем делать.
- Вычисление динамического выражения - это случаи, когда отладчик отправляет в рантайм выражения, которые необходимо вычислить.
  Такие выражения ближе к динамически скомпилированному коду, но ведет себя как единственный фрейм, то есть ничего не делаем.
  В общем, поведение логичное - этот фрейм, грубо говоря, существует в вакууме, так как ни к кому не привязан.
- Политики безопасности - с помощью атрибутов можно задавать различные политики безопасности (декларативная безопасность).
  Если на методе есть такой атрибут, то перед его вызовом будет вызван перехватчик (interceptor) - код, который проверяет права.
  Если мы находимся в таком контексте, то необходимо поставить точку останова на функции выше в цепочке вызовов.
- Остальные случаи - этим я обозвал все случаи (в управляемом коде), которые не обработались выше.
  Если добрались сюда, то ставим точку останова на следующем фрейме, который будем выполнять.
  Такое поведение в комментарии назвали step next.
- Неуправляемый код - ставим точку останова на адресе возврата.

> Для работы с фреймами используется отдельный класс `Frame`. Он базовый - абстрактный.
> Всего я нашел 18 подклассов `Frame`. Например, `FuncEvalFrame` - это фрейм, который создается отладчиком во время вычисления выражения для вызова функций.

## Java

Для начала: Java - это язык, JVM - это виртуальная машина и спецификация.
Есть множество реализаций JVM, но я буду рассматривать HotSpot.

[Java Platform Debugger Architecture (JPDA)](https://docs.oracle.com/en/java/javase/23/docs/specs/jpda/architecture.html) - описание архитектуры JVM для целей отладки.
Он состоит из нескольких слоев:

- JVM TI (Java VM Tool Interface) - определяет сервисы, которые JVM (отлаживаемая) предоставляет для отладки
- JDWP (Java Debug Wire Protocol) - коммуникационный протокол между отладчиком и JVM
- JDI (Java Debug Interface) - интерфейс Java для взаимодействия с отладчиком (отладка Java через Java)

<spoiler title="Визуализация JDPA">



```text
           Components                          Debugger Interfaces

                /    |--------------|
               /     |     VM       |
 debuggee ----(      |--------------|  <------- JVM TI - Java VM Tool Interface
               \     |   back-end   |
                \    |--------------|
                /           |
 comm channel -(            |  <--------------- JDWP - Java Debug Wire Protocol
                | \              |
                | -------------- |
                | front-end      |
                | -------------- | <------- JDI - Java Debug Interface |
                | UI             |
                | -------------- |

```

</spoiler>

Для отладки JVM определен свой протокол - [Java Debug Wire Protocol (JDWP)](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-spec.html).
Он описывает коммуникационный протокол между JVM и отладчиком.

Протокол использует пакеты для общения. Каждый пакет имеет заголовок фиксированного размера.
Пакеты могут быть 2 типов: команда (command) и ответ (reply).

В заголовке можно выделить 2 главных поля:

- `id` - идентификатор пакета
- `flags` - различные флаги

Сейчас во флагах может быть только 1 значение - `0x80`. Если он выставлен, то пакет - ответ, иначе - команда.
Также есть 2 поля, специфичные для для команды/ответа:

- `command set` (команда) - номер набора команд
- `command` (команда) - номер команды в указанном наборе команд. Вместе с `command set` уникально идентифицирует команда
- `error code` (ответ) - код ошибки

> Перед тем как начать взаимодействие по этому протоколу необходимо установить соединение.
> Делается это с помощью handshake пакета из 14 байт - "JDWP-Handshake".

Протокол асинхронный и можно отправить несколько пакетов за раз.
Для их разграничения существует поле `id`.

Кроме того, в каждом пакете в конце идет поле переменной длины - `Data`.
В ней хранятся данные, специфичные для конкретной команды.
Чтобы определить длину этого поля, в заголовке первым полем идет `length` - длина всего пакета, включая само это поле.

Теперь, перейдем к [JVM Tool Interface](https://docs.oracle.com/en/java/javase/23/docs/specs/jvmti.html). Напомню, что TI - это интерфейс самой JVM.
Он используется не только для отладки, но и для мониторинга, профилирования и различного рода анализа.

Также, стоит сказать, что он нативный, то есть реализован в C.
JVM имеет концепцию агентов - линкующихся библиотек. С помощью JVM TI (и заголовочного файла jvmti.h) можно получить доступ к этому интерфейсу.
Но это нативный интерфейс - есть еще и JDWP. Он описывает протокол взаимодействия. Согласитесь, странно описывать бинарный протокол для нативных функций.
Этот протокол для передачи пакетов использует отдельный транспорт.
В [спецификации](https://docs.oracle.com/en/java/javase/17/docs/specs/jpda/conninv.html#transports) описаны сокет (TCP/IP) и общая память, но есть возможность подключить и сторонний транспорт (Service Provider Interface).

Теперь перейдем к самой функциональности

### Точки останова

За взаимодействие через JVM TI в HotSpot отвечает класс `JvmtiEnv`.
Для выставления точки останова используется метод `SetBreakpoint`.

Но как водится в Java перед тем как сделать что-то встречаем большое количество абстракций и косвенности (насчитал еще 11 вспомогательных классов).
Если спуститься вглубь, то в конечном счете используется метод `set` класса `BreakpointInfo`.
Он работает так:

1. Получаем текущий поток
2. Находим адрес инструкции
3. Выставляем туда инструкцию точки останова - `Bytecodes::_breakpoint`

Можно заметить разницу с предыдущим рантаймом: в .NET точка останова ставится нативная (уже скомпилированный код), а в Java выставляется инструкция в байт код.
Эти решения исходят из дизайна: .NET всегда JIT компилирует, а JVM имеет перед собой выбор - интерпретация или JIT компиляция.
Работать с байткодом намного удобнее.

<spoiler title="BreakpointInfo::set">

```c++
void BreakpointInfo::set(Method* method) {
  Thread *thread = Thread::current();
  *method->bcp_from(_bci) = Bytecodes::_breakpoint;
  method->incr_number_of_breakpoints(thread);
  {
    // Deoptimize all dependents on this method
    HandleMark hm(thread);
    methodHandle mh(thread, method);
    CodeCache::mark_dependents_on_method_for_breakpoint(mh);
  }
}
```

</spoiler>

Чтобы удалить точку останова есть аналогичный метод `clear`:

<spoiler title="BreakpointInfo::clear">

```c++
void BreakpointInfo::clear(Method* method) {
  *method->bcp_from(_bci) = orig_bytecode();
  assert(method->number_of_breakpoints() > 0, "must not go negative");
  method->decr_number_of_breakpoints(Thread::current());
}
```

</spoiler>

### Шаги

Чтобы понять, как устроены шаги в исходном коде, стоит вспомнить, что архитектура отладки многоуровневая:

1. JVM
2. Агенты
3. JDWP
4. Клиенты

Из всего этого не рассматривали только 2 - агентов. Агентами называют подключаемые библиотеки, которые работают вместе с JVM.
Агенты могут свободно взаимодействовать с JVM.
Их можно и написать самим, но нам сейчас важен агент `jdk.jdwp.agent` - агент, реализующий протокол JDWP.

Но зачем это нужно знать?
Дело в том, что в JVM TI предоставляет возможно выполнить только SINGLE_STEP - 1 инструкцию байт-кода.
Поэтому реализовывать логику шагов (step XXX) нужно самим. Вот тут и помогает агент `jdk.jdwp.agent`.

> Это поведение можно сравнить и с `ptrace`: JVM как ОС предоставляет возможность выполнить 1 инструкцию, а мы как пользователи (агент) придаем смысл этим шагам.

В JDWP для шагов также есть команда, но только одна.
Ее поведение различается в зависимости от аргументов (каждый аргумент имеет определенные константные значения):

- `depth` - поведение шага
  - `INTO = 0` - step into
  - `OVER = 1` - step over
  - `OUT = 2` - step out
- `size` - гранулярность единицы выполнения
  - `MIN = 0` - шагнуть как можно меньше (часто это просто 1 инструкция байт-кода)
  - `LINE = 1` - шагнуть до следующей строки исходного кода (если этой информации нет, то `MIN`)

Если `size = LINE`, то эта команда принимает уже знакомые очертания `step IN(TO)`, `step OVER` и `step OUT`.

Сами шаги - это асинхронные события. Поэтому, когда в JVM отправляем SINGLE_STEP, то ответ приходит в виде события (когда шаг окончен).
В общем, step XXX реализованы через *постоянную отправку SINGLE_STEP* и отслеживания текущего положения. Очень похоже на реализацию gdb, но тут есть большая разница в одном моменте - обработка вызова функции. В gdb, когда мы запросили `step over` и была вызвана функция - мы ставим точку останова на адресе возврата. В JVM (как минимум в `jdk.jdwp.agent`) сделано иначе - мы *отслеживаем удаление фрейма*. Для этого используется отдельное событие `FramePop`

Таким образом, реализации шагов следующие (представим, что знаем где границы текущей строки):

- `step in`
  - выполняем SINGLE_STEP пока:
    - не будет вызвана другая функция (отслеживаем по количеству фреймов)
    - либо не изменится текущая строка
- `step over`
  - выполняем SINGLE_STEP пока не изменится текущая строка
  - если была вызвана функция, то подписываемся на событие удаления фрейма (NotifyFramePop) - продолжим когда вернемся обратно
- `step out`
  - подписываемся на событие удаления фрейма (NotifyFramePop)

Это все реализовано не 1 функцией, а несколькими - для нескольких событий.
Например, в функции `stepControl_handleStep` - логика при получении события окончания `SINGLE_STEP`, а в `handleFramePopEvent` - при получении события удаления фрейма. Также есть обработчики для `JVMTI_EVENT_EXCEPTION_CATCH` и `JVMTI_EVENT_METHOD_ENTRY` - бросок исключения и вызов метода.

<spoiler title="stepControl_handleStep">

```c++
jboolean
stepControl_handleStep(JNIEnv *env, jthread thread,
                       jclass clazz, jmethodID method)
{
    jboolean completed = JNI_FALSE;
    StepRequest *step;
    jint currentDepth;
    jint fromDepth;
    jvmtiError error;
    char *classname;

    classname = NULL;
    stepControl_lock();

    step = threadControl_getStepRequest(thread);
    if (step == NULL) {
        EXIT_ERROR(AGENT_ERROR_INVALID_THREAD, "getting step request");
    }

    /*
     * Сейчас нет обрабатываемых шагов
     */
    if (!step->pending) {
        goto done;
    }

    /*
     * Если нужно выполнить STEP INTO 1 инструкции, то все уже готово
     */
    if (step->depth == JDWP_STEP_DEPTH(INTO) &&
        step->granularity == JDWP_STEP_SIZE(MIN)) {
        completed = JNI_TRUE;
        goto done;
    }

    /*
     * Функция, для который был вызыван STEP уже завершилась
     */
    if (step->frameExited) {
        completed = JNI_TRUE;
        goto done;
    }

    currentDepth = getFrameCount(thread);
    fromDepth = step->fromStackDepth;

    if (fromDepth > currentDepth) {
        /*
         * Скорее всего, не получили уведомление об удалении фрейма
         */
        completed = JNI_TRUE;
    } else if (fromDepth < currentDepth) {
        /* Провалились в вызов другой функции */
        if (   step->depth == JDWP_STEP_DEPTH(INTO)
            && (!eventFilter_predictFiltering(step->stepHandlerNode, clazz,
                                          (classname = getClassname(clazz))))
            && hasLineNumbers(method) ) {

            /* STEP INTO завершается, если по пути была вызвана функция */
            completed = JNI_TRUE;
        } else {
            /*
             * Нужно продолжить выполнение в функции, на которой начали шаги.
             * Подписываемся на событие FramePop, а после продолжим выполнение.
             * Можно заметить, что здесь обрабатывается step into - скорее всего
             * вызываемый метод нужно обойти стороной (не прошел фильтр)
             */
            disableStepping(thread);

            if (step->depth == JDWP_STEP_DEPTH(INTO)) {
                step->methodEnterHandlerNode =
                    eventHandler_createInternalThreadOnly(
                                       EI_METHOD_ENTRY,
                                       handleMethodEnterEvent, thread);
                if (step->methodEnterHandlerNode == NULL) {
                    EXIT_ERROR(AGENT_ERROR_INVALID_EVENT_TYPE,
                                "installing event method enter handler");
                }
            }

            error = JVMTI_FUNC_PTR(gdata->jvmti,NotifyFramePop)
                        (gdata->jvmti, thread, 0);
            if (error == JVMTI_ERROR_DUPLICATE) {
                error = JVMTI_ERROR_NONE;
            } else if (error != JVMTI_ERROR_NONE) {
                EXIT_ERROR(error, "setting up notify frame pop");
            }
        }
        jvmtiDeallocate(classname);
        classname = NULL;
    } else {
        /*
         * Остались в той же функции
         */
        if (step->granularity == JDWP_STEP_SIZE(MIN)) {
            /* Если нужно выполнить 1 инструкцию, то все уже сделано */
            completed = JNI_TRUE;
        } else {
            /* Закончить step in/over можно только если строка изменилась */
            if (step->fromLine != -1) {
                jint line = -1;
                jlocation location;
                jmethodID method;
                WITH_LOCAL_REFS(env, 1) {
                    jclass clazz;
                    error = getFrameLocation(thread,
                                        &clazz, &method, &location);
                    if ( isMethodObsolete(method)) {
                        method = NULL;
                        location = -1;
                    }
                    if (error != JVMTI_ERROR_NONE || location == -1) {
                        EXIT_ERROR(error, "getting frame location");
                    }
                    if ( method == step->method ) {
                        log_debugee_location("stepControl_handleStep: checking line loc",
                                thread, method, location);
                        line = findLineNumber(thread, location,
                                      step->lineEntries, step->lineEntryCount);
                    }
                    if (line != step->fromLine) {
                        completed = JNI_TRUE;
                    }
                } END_WITH_LOCAL_REFS(env);
            } else {
                /* 
                 * Случай, если нативная функция вызвала Java функцию.
                 * В таком случае, просто завершаем шаг, т.к. не можем
                 * корректно обработать различные события
                 */
                completed = JNI_TRUE;
            }
        }
    }
done:
    if (completed) {
        completeStep(env, thread, step);
    }
    stepControl_unlock();
    return completed;
}
```

</spoiler>

<spoiler title="handleFramePopEvent">

```c++
static void
handleFramePopEvent(JNIEnv *env, EventInfo *evinfo,
                    HandlerNode *node,
                    struct bag *eventBag)
{
    StepRequest *step;
    jthread thread = evinfo->thread;

    stepControl_lock();

    step = threadControl_getStepRequest(thread);
    if (step == NULL) {
        EXIT_ERROR(AGENT_ERROR_INVALID_THREAD, "getting step request");
    }

    if (step->pending) {
        /*
         * Note: current depth is reported as *before* the pending frame
         * pop.
         */
        jint currentDepth;
        jint fromDepth;
        jint afterPopDepth;

        currentDepth = getFrameCount(thread);
        fromDepth = step->fromStackDepth;
        afterPopDepth = currentDepth-1;

        /*
         * If we are exiting the original stepping frame, record that
         * fact here. Once the next step event comes in, we can safely
         * stop stepping there.
         */
        if (fromDepth > afterPopDepth ) {
            step->frameExited = JNI_TRUE;
        }

        if (step->depth == JDWP_STEP_DEPTH(OVER)) {
            /*
             * Either
             * 1) the original stepping frame is about to be popped
             *    [fromDepth == currentDepth]. Re-enable stepping to
             *    reach a point where we can stop.
             * 2) a method called from the stepping frame has returned
             *    (during which we had stepping disabled)
             *    [fromDepth == currentDepth - 1]. Re-enable stepping
             *    so that we can continue instructions steps in the
             *    original stepping frame.
             * 3) a method further down the call chain has notified
             *    of a frame pop [fromDepth < currentDepth - 1]. This
             *    *might* represent case (2) above if the stepping frame
             *    was calling a native method which in turn called a
             *    java method. If so, we must enable stepping to
             *    ensure that we get control back after the intervening
             *    native frame is popped (you can't get frame pop
             *    notifications on native frames). If the native caller
             *    calls another Java method before returning,
             *    stepping will be disabled again and another frame pop
             *    will be awaited.
             *
             *    If it turns out that this is not case (2) with native
             *    methods, then the enabled stepping is benign and
             *    will be disabled again on the next step event.
             *
             * Note that the condition not covered above,
             * [fromDepth > currentDepth] shouldn't happen since it means
             * that too many frames have been popped. For robustness,
             * we enable stepping in that case too, so that the errant
             * step-over can be stopped.
             *
             */
            LOG_STEP(("handleFramePopEvent: starting singlestep, depth==OVER"));
            enableStepping(thread);
        } else if (step->depth == JDWP_STEP_DEPTH(OUT) &&
                   fromDepth > afterPopDepth) {
            /*
             * The original stepping frame is about to be popped. Step
             * until we reach the next safe place to stop.
             */
            LOG_STEP(("handleFramePopEvent: starting singlestep, depth==OUT && fromDepth > afterPopDepth (%d>%d)",fromDepth, afterPopDepth));
            enableStepping(thread);
        } else if (step->methodEnterHandlerNode != NULL) {
            /* We installed a method entry event handler as part of a step into operation. */
            JDI_ASSERT(step->depth == JDWP_STEP_DEPTH(INTO));
            if (fromDepth >= afterPopDepth) {
                /*
                 * We've popped back to the original stepping frame without finding a place to stop.
                 * Resume stepping in the original frame.
                 */
                LOG_STEP(("handleFramePopEvent: starting singlestep, have methodEnter handler && depth==INTO && fromDepth >= afterPopDepth (%d>=%d)", fromDepth, afterPopDepth));
                enableStepping(thread);
                (void)eventHandler_free(step->methodEnterHandlerNode);
                step->methodEnterHandlerNode = NULL;
            } else {
                LOG_STEP(("handleFramePopEvent: starting singlestep, have methodEnter handler && depth==INTO && fromDepth < afterPopDepth (%d<%d)", fromDepth, afterPopDepth));
            }
        }
        LOG_STEP(("handleFramePopEvent: finished"));
    }

    stepControl_unlock();
}
```

TODO: fullspeed, fastmode, slowmode - это че?

<spoiler title="fullspeed режим">

В процессе исследования кода нашел упоминание о режиме [fullspeed debugging](https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/enhancements1.4.html#fsd).
Это специальный режим выполнения кода и важен он во время отладки.
Вспомните, что код может либо интерпретироваться, либо компилироваться. Но, как мы сможем отладить машинные инструкции, если работать умеем только с байт-кодом?

Раньше (до версии 1.4) если было необходимо отлаживать программу, то единственный способ ее выполнения - интерпретация.
Эту проблему рашает fullspeed режим.

Работает он просто - если нужно поставить точку останова куда-то, то эта часть только интерпретируется, не компилируется.
У класса потока есть отдельный флаг, который отслеживает этот `interpretation-only` режим:

```c++
class JavaThread: public Thread {
  /* ... */
private:
  // Used by the interpreter in fullspeed mode for frame pop, method
  // entry, method exit and single stepping support. This field is
  // only set to non-zero at a safepoint or using a direct handshake
  // (see EnterInterpOnlyModeClosure).
  // It can be set to zero asynchronously to this threads execution (i.e., without
  // safepoint/handshake or a lock) so we have to be very careful.
  // Accesses by other threads are synchronized using JvmtiThreadState_lock though.
  int               _interp_only_mode;

 public:
  // used by the interpreter for fullspeed debugging support (see above)
  static ByteSize interp_only_mode_offset() { return byte_offset_of(JavaThread, _interp_only_mode); }
  bool is_interp_only_mode()                { return (_interp_only_mode != 0); }
  int get_interp_only_mode()                { return _interp_only_mode; }
  int set_interp_only_mode(int val)         { return _interp_only_mode = val; }
  void increment_interp_only_mode()         { ++_interp_only_mode; }
  void decrement_interp_only_mode()         { --_interp_only_mode; }
  
  /* ... */
}
```

За переход в `iterpretation-only` режим отвечает класс `EnterInterpOnlyModeClosure`.
В нем есть такой комментарий, описывающий как работает этот режим:

```c++
class EnterInterpOnlyModeClosure {
 public:
  void do_thread(Thread* th) {
    JavaThread* jt = JavaThread::cast(th);
    JvmtiThreadState* state = jt->jvmti_thread_state();

    // invalidate_cur_stack_depth is called in enter_interp_only_mode
    state->enter_interp_only_mode();

    Continuation::set_cont_fastpath_thread_state(jt);

    if (jt->has_last_Java_frame()) {
      // If running in fullspeed mode, single stepping is implemented
      // as follows: first, the interpreter does not dispatch to
      // compiled code for threads that have single stepping enabled;
      // second, we deoptimize all compiled java frames on the thread's stack when
      // interpreted-only mode is enabled the first time for a given
      // thread (nothing to do if no Java frames yet).
      ResourceMark resMark;
      for (StackFrameStream fst(jt, false /* update */, false /* process_frames */); !fst.is_done(); fst.next()) {
        if (fst.current()->can_be_deoptimized()) {
          Deoptimization::deoptimize(jt, *fst.current());
        }
      }
    }
    _completed = true;
  }
};
```

Можно заметить, что логика довольно проста - проходимся по всем фреймам потока и переводим его в байт-код (деоптимизируем).

</spoiler>

## Python

Дальше мы будем препарировать Python, точнее его интерпретатор CPython.
Он сильно отличается от предыдущих. И не только тем, что он только интерпретируемый.

Главное отличие - как реализована отладка, точнее отладчик.
Отладчик Python реализован в Python: точки останова, шаги, вычисления выражений - это все в самом языке.
Встроенный модуль `bdb` содержит 2 класса:

- `Bdb` - базовый класс отладчика: шаги, трейсинг, вычисление выражений, запуск/останов
- `Breakpoint` - класс точки останова: создание, удаление, (де)активация

Замечание: я не говорил, что отладчик *полностью* реализован в Python. На самом деле весь отладчик реализован поверх единственной функции из модуля `sys` - `settrace`.
Эта функция сохраняет колбек, который будет вызываться при любом интересном событии интерпретатора:

- Вызов/начало/продолжение/возвращение функции
- Исполнение новой строки (исходного) кода
- Исполнение новой инструкции (байт-кода)
- Обработка исключений
- Корутины

Как можно догадаться, работа отладчика заключается в том, чтобы корректно обработать эти события.
Этим и занимается метод `Bdb.trace_dispatch` (он и регистрируется в `sys.settrrace`):

<spoiler title="Bdb.trace_dispatch">

```python
def trace_dispatch(self, frame, event, arg):
    """Dispatch a trace function for debugged frames based on the event.

    This function is installed as the trace function for debugged
    frames. Its return value is the new trace function, which is
    usually itself. The default implementation decides how to
    dispatch a frame, depending on the type of event (passed in as a
    string) that is about to be executed.

    The event can be one of the following:
        line: A new line of code is going to be executed.
        call: A function is about to be called or another code block
                is entered.
        return: A function or other code block is about to return.
        exception: An exception has occurred.
        c_call: A C function is about to be called.
        c_return: A C function has returned.
        c_exception: A C function has raised an exception.

    For the Python events, specialized functions (see the dispatch_*()
    methods) are called.  For the C events, no action is taken.

    The arg parameter depends on the previous event.
    """
    if self.quitting:
        return # None
    if event == 'line':
        return self.dispatch_line(frame)
    if event == 'call':
        return self.dispatch_call(frame, arg)
    if event == 'return':
        return self.dispatch_return(frame, arg)
    if event == 'exception':
        return self.dispatch_exception(frame, arg)
    if event == 'c_call':
        return self.trace_dispatch
    if event == 'c_exception':
        return self.trace_dispatch
    if event == 'c_return':
        return self.trace_dispatch
    print('bdb.Bdb.dispatch: unknown debugging event:', repr(event))
    return self.trace_dispatch
```

</spoiler>

> Если посмотреть на код, то можно заметить, что некоторый события возвращают функции.
> Это не спроста: колбек функция должна возвращать функцию, которая будет использоваться для трассировки нового `scope`'а.
> То есть, есть глобальная функция трассировщик, которая в зависимости от окружения, может переопределить поведение следующего трассировщика.

Последний вопрос - как это все запустить? Когда мы отлаживаем код, то не вставляем явных вызовов `sys.set_trace` (это функция, запускающая отладчик).
Ответ тоже простой - отдельный модуль `pdb`.

Главное что в нем есть - класс `Pdb`, интерактивный отладчик. Он наследуется от `Bdb` и использует его функциональность (так обычно и создают отладчики).
Идя ниже по стеку вызовов находим то, как реализуется отладка (стек вызовов):

- `pdb.main` - получаем цель для выполнения (модуль/скрипт)
- `target.code` - получаем код цели (сейчас получаем строку):
  - скрипт - читаем файл и компилируем его: `exec(compile(fp.read()!r, path, 'exec'))` (это простая строка!)
  - модуль - используем вспомогательный модуль `runpy` для получения кода модуля
- `Pdb._run` - выполняем цель
- `Bdb.run` - отлаживаем переданное выражение (`run` - функция для отладки выражений)
  - `compile(cmd)` - комплируем код, если передали простую строку (как в `target.code` для скрипта)
  - `sys.settrace(self.trace_dispatch)` - регистрируем колбэк для отладки
  - `exec(cmd)` - выполняем переданный код

Вот так и реализуется отладка. На этом этапе уже должно стать понятно, как реализуются всякие step XXX, точки останова и т.д., но для полноты картины рассмотрим.

### Точки останова

Точку останова представляет класс `Breakpoint`. Это простой дата-класс, без логики.

Хранение точек останова разделено:

- В `Pdb` хранится словарь файл -> номер строки где поставлена точка останова
- В `Breakpoint` хранится статический словарь `breaks`: файл + номер строки -> список объектов `Breakpoint`.

Точка останова зависит от номера строки, поэтому в `trace_dispatch` за проверку точек останова ответственна функция `dispatch_line`.
Проверка находится в функции `break_here` и осуществляется так:

1. Проверяем, что в `Pdb` эта точка останова зарегистрирована
2. Получаем список всех точек останова находящихся на этой строке
   1. Пропускаем неактивные
   2. Пропускаем те, что не принадлежат функции (например, точка останова на объявлении функции (`def`))
   3. Пропускаем игнорируемые (счетчик `ignore`)
   4. С помощью `eval` проверяем условие
3. Если найденная точка останова временная - удаляем

Шаг 2 реализован в функции `effective`, что говорит само за себя - находим *действующую* точку останова.

<spoiler title="break_here">

```python
def break_here(self, frame):
    """Return True if there is an effective breakpoint for this line.

    Check for line or function breakpoint and if in effect.
    Delete temporary breakpoints if effective() says to.
    """
    filename = self.canonic(frame.f_code.co_filename)
    if filename not in self.breaks:
        return False
    lineno = frame.f_lineno
    if lineno not in self.breaks[filename]:
        # The line itself has no breakpoint, but maybe the line is the
        # first line of a function with breakpoint set by function name.
        lineno = frame.f_code.co_firstlineno
        if lineno not in self.breaks[filename]:
            return False

    # flag says ok to delete temp. bp
    (bp, flag) = effective(filename, lineno, frame)
    if bp:
        self.currentbp = bp.number
        if (flag and bp.temporary):
            self.do_clear(str(bp.number))
        return True
    else:
        return False
```

</spoiler>

<spoiler title="effective">

```python
def effective(file, line, frame):
    """Return (active breakpoint, delete temporary flag) or (None, None) as
       breakpoint to act upon.

       The "active breakpoint" is the first entry in bplist[line, file] (which
       must exist) that is enabled, for which checkfuncname is True, and that
       has neither a False condition nor a positive ignore count.  The flag,
       meaning that a temporary breakpoint should be deleted, is False only
       when the condiion cannot be evaluated (in which case, ignore count is
       ignored).

       If no such entry exists, then (None, None) is returned.
    """
    possibles = Breakpoint.bplist[file, line]
    for b in possibles:
        if not b.enabled:
            continue
        if not checkfuncname(b, frame):
            continue
        # Count every hit when bp is enabled
        b.hits += 1
        if not b.cond:
            # If unconditional, and ignoring go on to next, else break
            if b.ignore > 0:
                b.ignore -= 1
                continue
            else:
                # breakpoint and marker that it's ok to delete if temporary
                return (b, True)
        else:
            # Conditional bp.
            # Ignore count applies only to those bpt hits where the
            # condition evaluates to true.
            try:
                val = eval(b.cond, frame.f_globals, frame.f_locals)
                if val:
                    if b.ignore > 0:
                        b.ignore -= 1
                        # continue
                    else:
                        return (b, True)
                # else:
                #   continue
            except:
                # if eval fails, most conservative thing is to stop on
                # breakpoint regardless of ignore count.  Don't delete
                # temporary, as another hint to user.
                return (b, False)
    return (None, None)
```

</spoiler>

### Шаги

За шаги отвечают методы того же `Bdb`:

- `set_next` - step over
- `set_step` - step in
- `set_return` - step out

Но если посмотреть, то можно увидеть, что все они реализуются тем, что просто выставляют определенные значения полей:

- `stopframe` - фрейм, на котором надо остановиться
- `returnframe` - фрейм, на котором надо остановиться при *выходе*
- `stoplineno` - номер строки, на которой надо остановиться (остановиться на строке не меньшей, чем указано)

Таким образом, нужное поведение достигается различной комбинацией этих параметров:

|                     | stopframe        | returnframe   | stoplineno |
| ------------------- | ---------------- | ------------- | ---------- |
| step over           | текущий фрейм    | None          | 0          |
| step in             | None             | None          | 0          |
| step out            | предыдущий фрейм | текущий фрейм | 0          |
| step out (корутина) | текущий фрейм    | None          | -1         |

После при вызове колбэка определяем нужно ли останавливаться. В этой таблице более-менее все ясно кроме последней строки.
Причина в деталях реализации: итерирование реализовано с помощью `while` цикла, который бросает исключение `StopIteration` по окончании. Генераторы - это сопрограммы, также итеративно возвращают значения, но и им новые значения также можно передать (с помощью `send`). Реализованы аналогично, но бросают `GeneratorExit` при окончании.
Логическое окончание их работы наступает не тогда, когда их фрейм изменился, а тогда, когда было выброшено соответствующее исключение. Поэтому отследить их окончание с помощью `return` нельзя. Но мы можем отлеживать исключения - для них есть отдельные события и свой обработчик - `dispatch_exception`. В нем и проверяется подобная ситуация.

<spoiler title="dispatch_exception">

```python
GENERATOR_AND_COROUTINE_FLAGS = CO_GENERATOR | CO_COROUTINE | CO_ASYNC_GENERATOR

def dispatch_exception(self, frame, arg):
    """Invoke user function and return trace function for exception event.

    If the debugger stops on this exception, invoke
    self.user_exception(). Raise BdbQuit if self.quitting is set.
    Return self.trace_dispatch to continue tracing in this scope.
    """
    if self.stop_here(frame):
        # When stepping with next/until/return in a generator frame, skip
        # the internal StopIteration exception (with no traceback)
        # triggered by a subiterator run with the 'yield from' statement.
        if not (frame.f_code.co_flags & GENERATOR_AND_COROUTINE_FLAGS
                and arg[0] is StopIteration and arg[2] is None):
            self.user_exception(frame, arg)
            if self.quitting: raise BdbQuit
    # Stop at the StopIteration or GeneratorExit exception when the user
    # has set stopframe in a generator by issuing a return command, or a
    # next/until command at the last statement in the generator before the
    # exception.
    elif (self.stopframe and frame is not self.stopframe
            and self.stopframe.f_code.co_flags & GENERATOR_AND_COROUTINE_FLAGS
            and arg[0] in (StopIteration, GeneratorExit)):
        self.user_exception(frame, arg)
        if self.quitting: raise BdbQuit

    return self.trace_dispatch
```

</spoiler>

## JavaScript

Последним будем рассматривать NodeJS в качестве рантайма JavaScript.
Но NodeJS основан на движке V8, поэтому мы скорее будем рассматривать V8. Поэтому я мои слова будут справедливы для любого рантайма, основанного на V8.

Если движок встраивается, то разработчики для взаимодействия с отладчиком используют Inspector Protocol - протокол взаимодействия с отладчиком. Например, им пользуется Dev Tools в Chrome, но конечный пользователь им (протоколом) не пользуется.

TODO:
- V8DebuggerAgentImpl - есть функции stepOver, stepInto, stepOut, setbreakpoint и т.д. <-- искать

Для начала опишу сам протокол инспектора.
Во-первых, все команды предсталяются в виде JSON объектов примерно такой структуры:

```json
{
    // Номер-идентификатор сообщения для отслеживания
    "seq": "number",
    // Тип сообщения: запрос, ответ, событие
    "type": "request | response | event",
    // Если type === 'request'
    // Название команды
    "command": "string",
    // Объект из именованых пар: название - значение аргумента
    "arguments": {
        "argName": "value"
    },
    // Если type === 'response'
    // Ответ на какой запрос
    "request_seq": "number",
    // Выполнявшаяся команда
    "command": "string",
    // Успешно или нет выполнилось
    "success": "boolean",
    // Возвращаемое значение (в зависимости от команды)
    "body": "object",
    // Сообщение об ошибке, если !success
    "message": "string",
    // Флаг того, что VM приостановлена командой
    "running": "boolean",
    // Идентификаторы связных объектов (такое объекты имеют поле handle, на которое и идет ссылка)
    "refs": [],
    // Если type === 'event'
    // Название события
    "event": "string",
    // Данные события
    "body": "object"
}
```

Транспорт не оговаривается, но к инспектору обычно подключаются через HTTP, а в NodeJS через веб-сокеты (если запустить node с флагом `--inspect`, то будет выведен URL с веб-сокетом).

Но это вопрос представления объекта сообщения. Другой момент - как он кодируется. Если отправляем по HTTP, то кодировка ему на откуп (текстовый/бинарный), но вот внутри все сериализованные сообщения представляются в кодировке CBOR - Concise Binary Object Representation (RFC 8949). Если очень коротко - это бинарный JSON: есть аналогичные литералы (true, false, null, undefined) и типы (строки, числа, объекты, массивы), нет строгой схемы. Он даже имеет CWT - аналог JWT, но для CBOR.

Строгой спецификации протокола я не нашел (возможно ее и нет), но все сообщения, используемые протоколом описываются в файле `js_protocol.pdl` (в репозитории V8), специальном формате, используемом для Chrome DevTools.

Также я файл в репозитории `bugger-v8-client` - [PROTOCOL.md](https://github.com/buggerjs/bugger-v8-client/blob/master/PROTOCOL.md) (последний коммит 9 лет назад). Он в более человеческом ~~щадящем~~ виде описывает протокол.

Теперь, перейдем к архитектуре отладчика.

Архитектура отладки 2 уровневая - Клиент и Бэкэнд. Если посмотреть поближе на реализацию, то увидим большое количество абстракций:

- `V8Inspector`
- `V8InspectorSession`
- `UberDispatcher`
- `DomainDispatcher`
- `FronendChannel`
- `Backend`/`Frontend`

Замечу, что 1) есть еще абстракции и 2) для каждой может быть несколько реализаций.
Поэтому, чтобы было проще, опишу в 2 словах кто за что отвечает и как это работает:

`V8Inspector` - это интерфейс к движку V8. Главное что нам от него надо - доступ к `V8InspectorSession`, основному классу взаимодействия. Его можно получить через метод `connect`. Когда мы его получили, то все сообщения протокола отправляем ему.

В самом `V8InspectorSession` нам нужен только 1 метод - `dispatchProtcolMessage`.
Все что делает этот метод - перенаправляет сообщение уже объекту `UberDispatcher`.

Ненадолго вернемся к протоколу. Все команды разделены по доменам (`Domain`). Можно сказать, это просто области различной функциональности. Название каждой команды в начале имеет название ее домена. Например, `Debugger.stepOver` - команда step over для отладчика, а `Profiler.startPreciseCoverage` - начало сбора информации о покрытии кода.

Так вот, задача `UberDispatcher` - это найти домен, которому принадлежит команда и отправить ее.
Каждый такой домен (его обработчиу) - класс `DomainDispatcher` (его инстанс).
Когда команда доходит до него, то она выполняется.

Последний этап - отправка ответа. Здесь стоит заметить, что `UberDispatcher` отправляет команды в 1 сторону, обратно ничего не возвращает. Это вполне сходится с асинхронной природой команд для отладчика (видели такое и раньше).

Но как же отправляются ответы клиенту? Здесь мы приходим к последней абстракции - `FrontendChannel`.
Из названия становится понятно, что это канал взаимодействия с фронтэндом (кто встраивает).
Для взаимодействия с фронтэндом со стороны бэкэнда есть 2 основных метода: `SendProtocolResponse` и `sendProtocolNotification` (ответ и событие).

И вот мы подошли к финишной черте. Единственная абстракция, про которую мы не говорили - `Backend`. Это интерфейс для работы с рантаймом. Если посмотреть на его объявление, то можно заметить, что все его методы похожи на сгенерированный кодкакого-нибудь API: принимаемые аргументы указываются жестко (байтность, опциональность и т.д.), а возвращает объект класса `Response`.

> В реально так и есть - этот класс (как и много других описанных ранее классов) - продукт кодогенерации.
> Поэтому ссылок на них нет, только здесь могу код показать.

<spoiler title="Backend">

```c++
class  Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse continueToLocation(std::unique_ptr<protocol::Debugger::Location> in_location, Maybe<String> in_targetCallFrames) = 0;
    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse enable(Maybe<double> in_maxScriptsCacheSize, String* out_debuggerId) = 0;
    virtual DispatchResponse evaluateOnCallFrame(const String& in_callFrameId, const String& in_expression, Maybe<String> in_objectGroup, Maybe<bool> in_includeCommandLineAPI, Maybe<bool> in_silent, Maybe<bool> in_returnByValue, Maybe<bool> in_generatePreview, Maybe<bool> in_throwOnSideEffect, Maybe<double> in_timeout, std::unique_ptr<protocol::Runtime::RemoteObject>* out_result, Maybe<protocol::Runtime::ExceptionDetails>* out_exceptionDetails) = 0;
    virtual DispatchResponse getPossibleBreakpoints(std::unique_ptr<protocol::Debugger::Location> in_start, Maybe<protocol::Debugger::Location> in_end, Maybe<bool> in_restrictToFunction, std::unique_ptr<protocol::Array<protocol::Debugger::BreakLocation>>* out_locations) = 0;
    virtual DispatchResponse getScriptSource(const String& in_scriptId, String* out_scriptSource, Maybe<Binary>* out_bytecode) = 0;
    virtual DispatchResponse disassembleWasmModule(const String& in_scriptId, Maybe<String>* out_streamId, int* out_totalNumberOfLines, std::unique_ptr<protocol::Array<int>>* out_functionBodyOffsets, std::unique_ptr<protocol::Debugger::WasmDisassemblyChunk>* out_chunk) = 0;
    virtual DispatchResponse nextWasmDisassemblyChunk(const String& in_streamId, std::unique_ptr<protocol::Debugger::WasmDisassemblyChunk>* out_chunk) = 0;
    virtual DispatchResponse getWasmBytecode(const String& in_scriptId, Binary* out_bytecode) = 0;
    virtual DispatchResponse getStackTrace(std::unique_ptr<protocol::Runtime::StackTraceId> in_stackTraceId, std::unique_ptr<protocol::Runtime::StackTrace>* out_stackTrace) = 0;
    virtual DispatchResponse pause() = 0;
    virtual DispatchResponse pauseOnAsyncCall(std::unique_ptr<protocol::Runtime::StackTraceId> in_parentStackTraceId) = 0;
    virtual DispatchResponse removeBreakpoint(const String& in_breakpointId) = 0;
    virtual DispatchResponse restartFrame(const String& in_callFrameId, Maybe<String> in_mode, std::unique_ptr<protocol::Array<protocol::Debugger::CallFrame>>* out_callFrames, Maybe<protocol::Runtime::StackTrace>* out_asyncStackTrace, Maybe<protocol::Runtime::StackTraceId>* out_asyncStackTraceId) = 0;
    virtual DispatchResponse resume(Maybe<bool> in_terminateOnResume) = 0;
    virtual DispatchResponse searchInContent(const String& in_scriptId, const String& in_query, Maybe<bool> in_caseSensitive, Maybe<bool> in_isRegex, std::unique_ptr<protocol::Array<protocol::Debugger::SearchMatch>>* out_result) = 0;
    virtual DispatchResponse setAsyncCallStackDepth(int in_maxDepth) = 0;
    virtual DispatchResponse setBlackboxPatterns(std::unique_ptr<protocol::Array<String>> in_patterns) = 0;
    virtual DispatchResponse setBlackboxedRanges(const String& in_scriptId, std::unique_ptr<protocol::Array<protocol::Debugger::ScriptPosition>> in_positions) = 0;
    virtual DispatchResponse setBreakpoint(std::unique_ptr<protocol::Debugger::Location> in_location, Maybe<String> in_condition, String* out_breakpointId, std::unique_ptr<protocol::Debugger::Location>* out_actualLocation) = 0;
    virtual DispatchResponse setInstrumentationBreakpoint(const String& in_instrumentation, String* out_breakpointId) = 0;
    virtual DispatchResponse setBreakpointByUrl(int in_lineNumber, Maybe<String> in_url, Maybe<String> in_urlRegex, Maybe<String> in_scriptHash, Maybe<int> in_columnNumber, Maybe<String> in_condition, String* out_breakpointId, std::unique_ptr<protocol::Array<protocol::Debugger::Location>>* out_locations) = 0;
    virtual DispatchResponse setBreakpointOnFunctionCall(const String& in_objectId, Maybe<String> in_condition, String* out_breakpointId) = 0;
    virtual DispatchResponse setBreakpointsActive(bool in_active) = 0;
    virtual DispatchResponse setPauseOnExceptions(const String& in_state) = 0;
    virtual DispatchResponse setReturnValue(std::unique_ptr<protocol::Runtime::CallArgument> in_newValue) = 0;
    virtual DispatchResponse setScriptSource(const String& in_scriptId, const String& in_scriptSource, Maybe<bool> in_dryRun, Maybe<bool> in_allowTopFrameEditing, Maybe<protocol::Array<protocol::Debugger::CallFrame>>* out_callFrames, Maybe<bool>* out_stackChanged, Maybe<protocol::Runtime::StackTrace>* out_asyncStackTrace, Maybe<protocol::Runtime::StackTraceId>* out_asyncStackTraceId, String* out_status, Maybe<protocol::Runtime::ExceptionDetails>* out_exceptionDetails) = 0;
    virtual DispatchResponse setSkipAllPauses(bool in_skip) = 0;
    virtual DispatchResponse setVariableValue(int in_scopeNumber, const String& in_variableName, std::unique_ptr<protocol::Runtime::CallArgument> in_newValue, const String& in_callFrameId) = 0;
    virtual DispatchResponse stepInto(Maybe<bool> in_breakOnAsyncCall, Maybe<protocol::Array<protocol::Debugger::LocationRange>> in_skipList) = 0;
    virtual DispatchResponse stepOut() = 0;
    virtual DispatchResponse stepOver(Maybe<protocol::Array<protocol::Debugger::LocationRange>> in_skipList) = 0;

};
```

</spoiler>

Этот интерфейс реализует класс `V8DebuggerAgentImpl`. Если посмотреть на его реализацию, то увидим, что и он на самом деле просто обертка над другим объектом. Но на этот раз последним - `V8Debugger`. Внутри него и содержится логика отладки.

Например, вот реализация метода `stepOverStatement`:

<spoiler title=V8Debugger::stepOverStatement>

```c++
void V8Debugger::stepOverStatement(int targetContextGroupId) {
  DCHECK(isPaused());
  DCHECK(targetContextGroupId);
  m_targetContextGroupId = targetContextGroupId;
  v8::debug::PrepareStep(m_isolate, v8::debug::StepOver);
  continueProgram(targetContextGroupId);
}
```

</spoiler>

Собирая все вместе, можно построить такой график взаимодействия с отладчиком

```text
                                    V8Inspector
                                         |
                                         |
                                         | connect()
                                         |
                                         |
              dispatch(msg)              V
   Frontend  ------------------> V8InspectorSession
    (клиент)                             |
      ^                                  | 
      |                                  | dispatch(msg)
      |                                  | 
      |                                  V
      |                           UberDispatcher
      |                                  |
      |                                  |
      |                                  | 
      |                                  | dispatch(msg)
      |                                  |
      |         SendResponse()           V
FrontendChannel <--------------- DomainDispatcher
                                      ^     |
                                      |     |
                                      |     | invoke function
                                      |     |
                                      |     V
                                      Backend   
                                      ^     |
                                      |     |
                                      |     |
                                      |     |
                                      |     V
                                     V8Debugger
                                       (магия)
```

Теперь, переходим к рассмотрению реализации функциональность отладчика.

### Точки останова

В установке точки останова принимает участие еще один важный объект (`V8Debugger` здесь не участвует, `Backend` отправляет запрос описанным далее объектам): `Script`.

`Script` - это еще одна абстракция (интерфейс). Почему становится ясно, когда понимаешь, что V8 может выполнять не только JS, но и WASM, а способы выставления точек останова в них могут различаться.

Поэтому за выставление точек останова ответственнен сам скрипт. И эта логика содержится в его методе `SetBreakPoint`.

И в нем есть объект другого класса - `Debug`. Этот класс ответственнен за работу с точками останова.

Перед выставлением точки останова необходимо подготовить окружение. Речь идет о байт-коде V8. Поведение не сильно отличается от, например, Java: выстраиваем функции (создаем обычные функции из inline), деоптимизация, получение байт-кода.

Когда эта процедура закончена, то мы сохраняем точку останова в отдельном массиве, а после выставляем уже в коде.
Само выставление точки останова находится в методе `ApplyDebugBreak`:

<spoiler title="ApplyDebugBreak">

```c++
void BytecodeArrayIterator::ApplyDebugBreak() {
  // Get the raw bytecode from the bytecode array. This may give us a
  // scaling prefix, which we can patch with the matching debug-break
  // variant.
  uint8_t* cursor = cursor_ - prefix_size_;
  interpreter::Bytecode bytecode = interpreter::Bytecodes::FromByte(*cursor);
  if (interpreter::Bytecodes::IsDebugBreak(bytecode)) return;
  interpreter::Bytecode debugbreak =
      interpreter::Bytecodes::GetDebugBreak(bytecode);
  *cursor = interpreter::Bytecodes::ToByte(debugbreak);
}
```

</spoiler>

Можно заметить, что здесь мы себя ведем точно также, как и с обычными машинными инструкциями - перетираем инструкцию точкой останова. Разве что, мы дополнительно проверяем, что там уже стоит точка останова.

Когда мы хотим удалить точку останова, то делаем аналогичные вещи:

<spoiler title="ClearBreakPoint">


```c++
void BreakIterator::ClearDebugBreak() {
  DCHECK(GetDebugBreakType() >= DEBUGGER_STATEMENT);
  Tagged<BytecodeArray> bytecode_array =
      debug_info_->DebugBytecodeArray(isolate());
  Tagged<BytecodeArray> original =
      debug_info_->OriginalBytecodeArray(isolate());
  bytecode_array->set(code_offset(), original->get(code_offset()));
}
```

</spoiler>

> Примечание: в коде используется класс `BreakIterator`. Это итератор по точкам останова.
> Выставление точек останова реализовано не кусками, а единым целым - удаляются и выставляются все одновременно.

<spoiler title="А что с WASM">

Я обронил слово, что для WASM будет другая логика. Теперь, опишу почему. За него отвечает класс `WasmScript` (наследуется от `Script`).

Он переопределяет нужный нам метод `SetBreakPoint`. И если посмотреть на реализацию, то она состоит из 3 простых шагов: находим модуль, находим место для точки останова и выставляем ее.

```c++
// static
bool WasmScript::SetBreakPoint(DirectHandle<Script> script, int* position,
                               DirectHandle<BreakPoint> break_point) {
  DCHECK_NE(kOnEntryBreakpointPosition, *position);

  // Find the function for this breakpoint.
  const wasm::WasmModule* module = script->wasm_native_module()->module();
  int func_index = GetContainingWasmFunction(module, *position);
  if (func_index < 0) return false;
  const wasm::WasmFunction& func = module->functions[func_index];
  int offset_in_func = *position - func.code.offset();

  int breakable_offset = FindNextBreakablePosition(script->wasm_native_module(),
                                                   func_index, offset_in_func);
  if (breakable_offset == 0) return false;
  *position = func.code.offset() + breakable_offset;

  return WasmScript::SetBreakPointForFunction(script, func_index,
                                              breakable_offset, break_point);
}
```

Если опустимся ниже, то найдем как выставляются точки останова в WASM:

```c++
class DebugInfo {
    /* ... */
    void SetBreakpoint(int func_index, int offset, Isolate* isolate) {
        // Get the set of previously set breakpoints, to check later whether a new
        // breakpoint was actually added.
        std::vector<int> all_breakpoints = FindAllBreakpoints(func_index);

        auto& isolate_data = per_isolate_data_[isolate];
        std::vector<int>& breakpoints =
            isolate_data.breakpoints_per_function[func_index];
        auto insertion_point =
            std::lower_bound(breakpoints.begin(), breakpoints.end(), offset);
        if (insertion_point != breakpoints.end() && *insertion_point == offset) {
            // The breakpoint is already set for this isolate.
            return;
        }
        breakpoints.insert(insertion_point, offset);

        // Find the insertion position within {all_breakpoints}.
        insertion_point = std::lower_bound(all_breakpoints.begin(),
                                           all_breakpoints.end(), offset);
        bool breakpoint_exists =
            insertion_point != all_breakpoints.end() && *insertion_point == offset;
        // If the breakpoint was already set before, then we can just reuse the old
        // code. Otherwise, recompile it. In any case, rewrite this isolate's stack
        // to make sure that it uses up-to-date code containing the breakpoint.
        WasmCode* new_code;
        if (breakpoint_exists) {
        new_code = native_module_->GetCode(func_index);
        } else {
        all_breakpoints.insert(insertion_point, offset);
        int dead_breakpoint =
            DeadBreakpoint(func_index, base::VectorOf(all_breakpoints), isolate);
        new_code = RecompileLiftoffWithBreakpoints(
            func_index, base::VectorOf(all_breakpoints), dead_breakpoint);
        }
        UpdateReturnAddresses(isolate, new_code, isolate_data.stepping_frame);
    }
    /* ... */
}
```

Можно заметить, что если мы поставили точку останова, то приходится перекомпилировать весь модуль. Даже с учетом того, что используется кэш, это не самый быстрый вариант.

> Если что, Liftoff - это компилятор WASM в V8

</spoiler>

Теперь, когда выполнение доходит до точки останова рантайм об этом узнает и вызовет обработчик `Runtime_DebugBreakOnBytecode`. Сама логика обработки точки останова находится в том же классе `Debug`, методе `Break`.

Вот кусок этого метода, ответственный за обработку точек останова:

<spoiler title="Debug::Break">

```c++
void Debug::Break(JavaScriptFrame* frame,
                  DirectHandle<JSFunction> break_target) {
  RCS_SCOPE(isolate_, RuntimeCallCounterId::kDebugger);
  // Just continue if breaks are disabled or debugger cannot be loaded.
  if (break_disabled()) return;

  // Enter the debugger.
  DebugScope debug_scope(this);
  DisableBreak no_recursive_break(this);

  // Return if we fail to retrieve debug info.
  Handle<SharedFunctionInfo> shared(break_target->shared(), isolate_);
  if (!EnsureBreakInfo(shared)) return;
  PrepareFunctionForDebugExecution(shared);

  Handle<DebugInfo> debug_info(TryGetDebugInfo(*shared).value(), isolate_);

  // Find the break location where execution has stopped.
  BreakLocation location = BreakLocation::FromFrame(debug_info, frame);
  const bool hitInstrumentationBreak =
      IsBreakOnInstrumentation(debug_info, location);
  bool shouldPauseAfterInstrumentation = false;
  if (hitInstrumentationBreak) {
    debug::DebugDelegate::ActionAfterInstrumentation action =
        OnInstrumentationBreak();
    switch (action) {
      case debug::DebugDelegate::ActionAfterInstrumentation::kPause:
        shouldPauseAfterInstrumentation = true;
        break;
      case debug::DebugDelegate::ActionAfterInstrumentation::
          kPauseIfBreakpointsHit:
        shouldPauseAfterInstrumentation = false;
        break;
      case debug::DebugDelegate::ActionAfterInstrumentation::kContinue:
        return;
    }
  }

  // Find actual break points, if any, and trigger debug break event.
  ClearMutedLocation();
  bool has_break_points;
  bool scheduled_break =
      scheduled_break_on_function_call() || shouldPauseAfterInstrumentation;
  MaybeHandle<FixedArray> break_points_hit =
      CheckBreakPoints(debug_info, &location, &has_break_points);
  if (!break_points_hit.is_null() || break_on_next_function_call() ||
      scheduled_break) {
    StepAction lastStepAction = last_step_action();
    debug::BreakReasons break_reasons;
    if (scheduled_break) {
      break_reasons.Add(debug::BreakReason::kScheduled);
    }
    // If it's a debugger statement, add the reason and then mute the location
    // so we don't stop a second time.
    bool is_debugger_statement = IsBreakOnDebuggerStatement(shared, location);
    if (is_debugger_statement) {
      break_reasons.Add(debug::BreakReason::kDebuggerStatement);
    }

    // Clear all current stepping setup.
    ClearStepping();
    // Notify the debug event listeners.
    OnDebugBreak(!break_points_hit.is_null()
                     ? break_points_hit.ToHandleChecked()
                     : isolate_->factory()->empty_fixed_array(),
                 lastStepAction, break_reasons);

    if (is_debugger_statement) {
      // Don't pause here a second time
      SetMutedLocation(shared, location);
    }
    return;
  }
  /* ... */
}
```

</spoiler>

<spoiler title="Кодогенерация">

Из интересного - интерфес рантайма. Если мы в режиме интерпретатора, то у каждого байт-кода есть своя функция обработчик. И название функции обработчки создается с помощью макроса `IGNITION_HANDLER`. Например, обработчик байт-кода `DebugBreak0` определяется так:

```c++
IGNITION_HANDLER(Name, InterpreterAssembler) {
    TNode<Context> context = GetContext();
    TNode<Object> accumulator = GetAccumulator();
    TNode<PairT<Object, Smi>> result_pair = CallRuntime<PairT<Object, Smi>>(
        Runtime::kDebugBreakOnBytecode, context, accumulator);
    TNode<Object> return_value = Projection<0>(result_pair);
    TNode<IntPtrT> original_bytecode = SmiUntag(Projection<1>(result_pair));
    SetAccumulator(return_value);
    DispatchToBytecodeWithOptionalStarLookahead(original_bytecode);
}
```

Замечания:

- На самом деле, имеется 5 байт-кодов для точки останова (как можно догадаться из суффикса `0`)
- Все `DebugBreakX` одинаковы, поэтому их определение создается с помощью другого макроса. Для удобства я раскрыл его.

Можете заметить, интересную функцию `CallRuntime`. Это функция, которая вызывает функции интерфейса рантайма. А для определения, какую функцию надо вызвать, передается код (перечисление). Очень похоже на системный вызов.

Но и это еще не все. Посмотрим на ее определение:

```c++
RUNTIME_FUNCTION_RETURN_PAIR(Runtime_DebugBreakOnBytecode) {
  using interpreter::Bytecode;
  using interpreter::Bytecodes;
  using interpreter::OperandScale;

  DirectHandle<Object> value = args.at(0);
  HandleScope scope(isolate);

  // Return value can be changed by debugger. Last set value will be used as
  // return value.
  ReturnValueScope result_scope(isolate->debug());
  isolate->debug()->set_return_value(*value);

  // Get the top-most JavaScript frame.
  JavaScriptStackFrameIterator it(isolate);
  if (isolate->debug_execution_mode() == DebugInfo::kBreakpoints) {
    isolate->debug()->Break(it.frame(),
                            handle(it.frame()->function(), isolate));
  }

  // If the user requested to restart a frame, there is no need
  // to get the return value or check the bytecode for side-effects.
  if (isolate->debug()->IsRestartFrameScheduled()) {
    Tagged<Object> exception = isolate->TerminateExecution();
    return MakePair(exception,
                    Smi::FromInt(static_cast<uint8_t>(Bytecode::kIllegal)));
  }

  // Return the handler from the original bytecode array.
  InterpretedFrame* interpreted_frame =
      reinterpret_cast<InterpretedFrame*>(it.frame());

  bool side_effect_check_failed = false;
  if (isolate->debug_execution_mode() == DebugInfo::kSideEffects) {
    side_effect_check_failed =
        !isolate->debug()->PerformSideEffectCheckAtBytecode(interpreted_frame);
  }

  // Make sure to only access these objects after the side effect check, as the
  // check can allocate on failure.
  Tagged<SharedFunctionInfo> shared = interpreted_frame->function()->shared();
  Tagged<BytecodeArray> bytecode_array = shared->GetBytecodeArray(isolate);
  int bytecode_offset = interpreted_frame->GetBytecodeOffset();
  Bytecode bytecode = Bytecodes::FromByte(bytecode_array->get(bytecode_offset));

  if (Bytecodes::Returns(bytecode)) {
    // If we are returning (or suspending), reset the bytecode array on the
    // interpreted stack frame to the non-debug variant so that the interpreter
    // entry trampoline sees the return/suspend bytecode rather than the
    // DebugBreak.
    interpreted_frame->PatchBytecodeArray(bytecode_array);
  }

  // We do not have to deal with operand scale here. If the bytecode at the
  // break is prefixed by operand scaling, we would have patched over the
  // scaling prefix. We now simply dispatch to the handler for the prefix.
  // We need to deserialize now to ensure we don't hit the debug break again
  // after deserializing.
  OperandScale operand_scale = OperandScale::kSingle;
  isolate->interpreter()->GetBytecodeHandler(bytecode, operand_scale);

  if (side_effect_check_failed) {
    return MakePair(ReadOnlyRoots(isolate).exception(),
                    Smi::FromInt(static_cast<uint8_t>(bytecode)));
  }
  Tagged<Object> interrupt_object = isolate->stack_guard()->HandleInterrupts();
  if (IsException(interrupt_object, isolate)) {
    return MakePair(interrupt_object,
                    Smi::FromInt(static_cast<uint8_t>(bytecode)));
  }
  return MakePair(isolate->debug()->return_value(),
                  Smi::FromInt(static_cast<uint8_t>(bytecode)));
}
```

Опять макросы. Вообще, весь код полон этих макросов и кодогенерации. Например, многе реализации упомянутые выше (`DomainDispatcher` и др.) на самом деле кодосгенерированы. Для генерации используется шаблонный язык jinja, а все файлы с шаблонами имеют расширение `.template`. Тот же `DomainDispatcher` генерируется шаблоном `TypeBuilder_cpp.template`.

Поэтому, если хотите поизучать его код, то без сборки исходников будет сложновато.

</spoiler>

### Шаги

Мы уже могли видеть метод `stepOverStatement` в классе `V8Debugger`. И да, остальные методы для шагов находятся в нем же.

Все они устроены по одному и тому же принципу: вызываем `v8::debug::PrepareStep` с нужным аргументом, а затем `continueProgram` для продолжения работы. Функция `v8::debug::PrepareStep` принадлежит уже знакомому классу `Debug`.

Сам алгоритм их обработки схож с тем, что видели в предыдущих рантаймах: сохраняем желаемое состояние (фрейм, строка и т.д.) и продолжаем выполнение, а как только программа остановилась, то сверяем текущее и желаемое состояние.

В этом состоянии нам нужно знать только о 2 переменных:

1. `last_step_action` - последний выполнявшийся шаг (ставим равным запрошенному). Нужен просто чтобы обнаружить, что на момент остановки мы запросили шаг
2. `traget_frame_count` - количество фреймов, которое хотим достичь (глубина стека), или -1, если без разницы. Вспомните, что step into отличается от step over необходимостью остановки при вызове функции.

После, мы вызываем функцию `FloodWithOneShot`, которая позволит нам выполнить 1 шаг, и продолжаем выполнение.

За обработку шагов отвечает тот же метод, что и за точки останова - `Debug::Break`. Но уже 2 часть (оставил там в коде троеточие).

<spoiler title="Debug::Break">

```c++
void Debug::Break(JavaScriptFrame* frame,
                  DirectHandle<JSFunction> break_target) {
  /* ... */

  // No break point. Check for stepping.
  StepAction step_action = last_step_action();
  int current_frame_count = CurrentFrameCount();
  int target_frame_count = thread_local_.target_frame_count_;
  int last_frame_count = thread_local_.last_frame_count_;

  // StepOut at not return position was requested and return break locations
  // were flooded with one shots.
  if (thread_local_.fast_forward_to_return_) {
    // We might hit an instrumentation breakpoint before running into a
    // return/suspend location.
    // We have to ignore recursive calls to function.
    if (current_frame_count > target_frame_count) return;
    ClearStepping();
    PrepareStep(StepOut);
    return;
  }

  bool step_break = false;
  switch (step_action) {
    case StepNone:
      if (has_break_points) {
        SetMutedLocation(shared, location);
      }
      return;
    case StepOut:
      // StepOut should not break in a deeper frame than target frame.
      if (current_frame_count > target_frame_count) return;
      step_break = true;
      break;
    case StepOver:
      // StepOver should not break in a deeper frame than target frame.
      if (current_frame_count > target_frame_count) return;
      [[fallthrough]];
    case StepInto: {
      // StepInto and StepOver should enter "generator stepping" mode, except
      // for the implicit initial yield in generators, where it should simply
      // step out of the generator function.
      if (location.IsSuspend()) {
        ClearStepping();
        if (!IsGeneratorFunction(shared->kind()) ||
            location.generator_suspend_id() > 0) {
          thread_local_.suspended_generator_ =
              location.GetGeneratorObjectForSuspendedFrame(frame);
        } else {
          PrepareStep(StepOut);
        }
        return;
      }
      FrameSummary summary = FrameSummary::GetTop(frame);
      const bool frame_or_statement_changed =
          current_frame_count != last_frame_count ||
          thread_local_.last_statement_position_ !=
              summary.SourceStatementPosition();
      // If we stayed on the same frame and reached the same bytecode offset
      // since the last step, we are in a loop and should pause. Otherwise
      // we keep "stepping" through the loop without ever acutally pausing.
      const bool potential_single_statement_loop =
          current_frame_count == last_frame_count &&
          thread_local_.last_bytecode_offset_ == summary.code_offset();
      step_break = step_break || location.IsReturn() ||
                   potential_single_statement_loop ||
                   frame_or_statement_changed;
      break;
    }
  }

  StepAction lastStepAction = last_step_action();
  // Clear all current stepping setup.
  ClearStepping();

  if (step_break) {
    // If it's a debugger statement, add the reason and then mute the location
    // so we don't stop a second time.
    debug::BreakReasons break_reasons;
    bool is_debugger_statement = IsBreakOnDebuggerStatement(shared, location);
    if (is_debugger_statement) {
      break_reasons.Add(debug::BreakReason::kDebuggerStatement);
    }
    // Notify the debug event listeners.
    OnDebugBreak(isolate_->factory()->empty_fixed_array(), lastStepAction,
                 break_reasons);

    if (is_debugger_statement) {
      // Don't pause here a second time
      SetMutedLocation(shared, location);
    }
  } else {
    // Re-prepare to continue.
    PrepareStep(step_action);
  }
}
```

</spoiler>

И вот тут нам нужно состояние, которое мы выставляли ранее: В случае step over мы проверяем, что находимся во фрейме не ниже требуемого. А дальше все одинаково - просто останавливаемся (`return` без переустановки шагов и других функций).

- step out: если находимся во фрейме ниже требуемого, то продолжаем выполнение
- step over: если находимся во фрейме ниже требуемого, то продолжаем выполнение (идем в step into)
- step into: останавливаемся если (либо):
  - строка/кадри изменились
  - возможно мы в цикле из 1 стейтмента
  - на инструкции возврата

Еще можно заметить, что в step into дополнительно обрабатываются генераторы, а точнее `yeild` стейтмент. Если мы до них доходим, то переходим в режим step out, так как нам нужно вернуть результат, а это возврат из функции.

# Другие ОС

Мы забрались слишком высоко - управляемые языки со своим рантаймом. Теперь пора вернуться вниз по иерархии и рассмотреть подробнее примеры каждого слоя. Начнем с операционных систем. Ранее мы рассмотрели только Linux. Пришло время для других. Начнем в Windows.

## Windows

Windows, FreeBSD, ColibriOS (???), Реального времени ОС

# Другие процессоры (архитектуры)

x86, ARM, SPARC-V, Байкал (????)

# Среды разработки

VS Code, CodeBlocks
Как различные IDE взаимодействуют с отладчиками - м.б. есть общий протокол работы с ними


TODO: jit реализован через ptrace ?
