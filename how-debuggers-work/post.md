# Как работают дебаггеры

О чем написать:

1. Ядро работы дебагера: `ptrace` + `INT 3`
2. Попробовать написать свой дебаггер
   - Простой интерфейс
   - DWARF формат попробовать распарсить (и дебажиться по строчкам)
   - Фича - откат истории
3. Как работают в управляемых ЯП (байт-код, jit, C#, java, python)
4. Особенности различных платформ
   - Windows
   - FreeBSD
   - М.б. другие платформы
5. Как это работает в VS Code (про этот интерфейс рассказать на примере gdb)
6. Фичи некоторые:
   1. GDB вызывает функции как
   2. Развертка стека
7. Некоторые ответы на вопросы
   1. При attach есть настоящий родитель, а есть приаттачившийся - как получать уведомления (waitpid)?
   2. Цикл при отладке - один другого и наоборот отлаживает (https://habr.com/ru/articles/439882/)?


# Ядро

Поинты:
- Все вокруг ptrace и int 3
- ptrace - это системный вызов
- int 3 - это инструкция для генерации прерывания
- брейкпоинт - это по факту прерывание
- он специально сделан однобайтовым + пример где это может выстрелить если не однобайтовый
- PEEK and POKE рассказать
- БП только для инструкций - для строк и т.д. нужны отладочные символы
- Что если к завершенному потомку чужому приаттачиться? Все получат результат или только кто-то один (exit code потомка) 
- `strace` использует `PTRACE_SYSCALL` (найти код)

Весь процесс дебагинга крутится вокруг 2 вещей:
- `ptrace`
- `INT 3`

`ptrace` - это системный вызов, который используется для отслеживания процесса (**p**rocess **trace**). 
Интерфейс следующий:

`long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);`

Можно заметить сходство с другими вызовами по типу `ioctl` или `fcntl` - код запроса (перечисление `__ptrace_request`), идентификатор объекта (`pid`) и вспомогательные данные (`addr`, `data`).

> Понимаю, что на этом вызове много обязанностей и трудно придумать более тонкий вариант, но это как-то контрастирует с философией Unix - `делают что-то одно`. 
> Может я прикапываюсь.

Благодаря этому системному вызову можно:
- `PTRACE_CONT`/`PTRACE_SINGLESTEP` - Получить контроль над выполнением
- Прочитать и изменять:
  - `PTRACE_GETREGS`/`PTRACE_SETREGS` - Регистры
  - `PTRACE_PEEKDATA`/`PTRACE_POKEDATA` - Память и код
  - `PTRACE_PEEKUSER`/`PTRACE_POKEUSER` - TODO: придумать как назвать
  - `PTRACE_SET_THREAD_AREA` - Локальные данные потока (TLS)
- `PTRACE_SET_SYSCALL` - Подменять вызываемые системные вызовы
- `PTRACE_SECCOMP_GET_FILTER` - Получать информацию о [seccomp](https://man.archlinux.org/man/seccomp.2.en)

<spoiler title="PEEK & POKE">

TODO: тут про peek & poke написать

</spoiler>

Для начала рассмотрим общий взгляд на процесс отладки. Грубо говоря, процесс отладки итеративный и каждую итерацию можно представить в виде 3 шагов:

1. Ждем точку останова
2. Выполняем необходимые действия 
3. Продолжаем работы

Рассмотрим каждый шаг.

> Далее буду использовать терминологию из man: `tracer` - отладчик, `tracee` - процесс, который отлаживаем

## Ждем точку останова

Первое - нам необходимо дождаться остановки tracee. 
Пока представим, что она есть и рано или поздно tracee до нее дойдет.

Главный принцип работы `ptrace` можно описать так: tracee получает сигнал и останавливается, а tracer в этот момент получает контроль, что-то делает и продолжает работу tracee.
Для ожидания этого сигнала tracer использует `waitpid`.

TODO: надо ли оставлять?
> Раньше я думал, что этот системный вызов нужен для ожидания завершения дочернего процесса, но, в общем случае, он используется для отслеживания изменения статуса потомка (wait for state changes in child of the calling process, как написано в man'е).

И сам смысл точки останова в следующем:

> tracee останавливается каждый раз, когда *получает сигнал* (любой), а tracer в это время пробуждается и *`WIFSTOPPED`*, вызванный на полученном статусе, возвращает `true`. 

То есть, отслеживаемый процесс получает любой сигнал, в этот момент останавливается и `waitpid` возвращается с соответствующим статусом. 

Ждать остановки tracee требуется обязательно - практически все `ptrace` вызовы, которые изменяют состояние tracee, вернут `ESRCH`, если будут вызваны над работающим процессом. С одной стороны, ограничение - нельзя вставить палку в колеса едущему велосипеду, но, с другой, интересно было бы посмотреть что случиться. Если кратко, то только 5 команд не требуют остановленного состояния, но и они используются для начала и окончания процесса отладки. Об этих командах можно посмотреть в секции Informational and restarting ptrace commands в `man 2 ptrace`.

<spoiler title="Разные статусы остановки">

TODO: описать


тут про то, что 
- всего есть running и stopped состояния, причем заблокирован сисколом = running
- ptrace-stop имеет множество подклассов
- 


</spoiler>

Когда `waitpid` вернулся, то необходимо проверить его статус. Грубо говоря, статус можно разделить 2 случая - останов и конец работы процесса. Определить это можно по упомянутому выше `WIFSTOPPED`. С учетом того, что останавливаться будем множество раз, то код отладчика в общем случае можно представить следующим образом:

```cpp
pid_t pid;
int wstatus;
while (1)
{
    /* 
     * Ждем остановки tracee 
     */
    pid_t ret_pid = waitpid(pid, &wstatus, 0);
    if (!WIFSTOPPED(wstatus))
    {
        /* 
         * Процесс завершил работу
         */
        break;
    }

    /* 
     * Выполняем необходимые действия
     * ...
     */

    /* 
     * И продолжаем работу
     * ...
     */
}
```

## Основные манипуляции

На этом моменте, tracee остановлен, а нам (дебаггеру) вернули управление из `waitpid`. 
Представим, что точка останова сработала и процесс не завершил свою работу. 
Теперь начинается самое интересное - процесс отладки: просмотр и изменение состояния tracee.

Команды, которые призваны получать и изменять состояние tracee, в документации называются информационными (informational). Есть множество аспектов процесса, которыми мы можем управлять и для них есть по 2 команды (`PTRACE_*`) - для чтения и записи. 

Сейчас нас будут интересовать только `PTRACE_PEEKTEXT`/`PTRACE_POKETEXT` и `PTRACE_GETREGS`/`PTRACE_SETREGS`. Первая команда используется для получения и изменения данных и кода процесса, а вторая - для регистров.

> Дополнительно есть `PTRACE_PEEKDATA`/`PTRACE_POKEDATA`.
> Эта команда должна работать с данными процесса (областью памяти), а `PTRACE_PEEKTEXT`/`PTRACE_POKETEXT` - с секцией кода (`.text`).
> Но, как описано в man, у линукса адресное пространство данных и кода единое, поэтому обе команды выполняют одно и то же.

В сигнатуре `ptrace` используется 4 аргумента: первые 2 для идентификации процесса и операции, а вторые 2 - для передачи специфичных для конкретной операции параметров. В частности, передаются 2 указателя. Их семантика отличается от команды к команде, а некоторые команды используют только часть, либо не используют эти параметры вообще, поэтому для каждой команды надо смотреть отдельно.

Для примера, если `rax` равен 0, то записать число 1 (4 байтное число), по адресу из регистра `rbx`. Реализовать это можно следующим образом:

TODO: проверить

```cpp
struct user_regs_struct regs;
ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
if (regs.rax == 0)
{
    void *addr = (void *)regs.rbx;
    long data = ptrace(PTRACE_PEEKTEXT, child_pid, addr, NULL);
    *((int *)&data) = 1;
    ptrace(PTRACE_POKETEXT, child_pid, addr, (void*)data);
}
```

Обратите внимание на то, как записывается число 1.
Загвоздка в том, что команды `PEEKTEXT` и `POKETEXT` работают с машинным словом, грубо говоря, оперируют размером указателя.
У меня 64-битная машина, поэтому его размер 8 байтов, а записываю я 4-х байтное.
Если бы я хотел записать 8 байтное (`long`), то мог бы сделать это проще, без read-modify-write.

```cpp
struct user_regs_struct regs;
ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
if (regs.rax == 0)
{
    void *addr = (void *)regs.rbx;
    long data = 1L;
    ptrace(PTRACE_POKETEXT, child_pid, addr, (void*)data);
}
```

Ну и вообще, вся работа с памятью (чтение и запись) ведется подобным образом - читаем необходимый диапазон памяти по машинному слову и после записываем также по машинному слову.

## Продолжение работы

Когда все необходимые действия выполнили, то надо продолжить работу процесса.
Сделать это можно 2 способами:

- `PTRACE_SINGLESTEP` - Выполнить только 1 инструкцию
- `PTRACE_CONT` - Продолжить выполнение

Логично, что следующая остановка у первой команды будет у начала следующей инструкции, а у второй - при следующем сигнале.

## Изначальный запуск

Последнее, что мы не покрыли - как начинается процесс отладки.
Тут также есть 2 варианта:

- Сами запускаем процесс для отладки
- Присоединяемся к уже работающему процессу

### Самостоятельный запуск

Для самостоятельного запуска есть следующий паттерн:
1. Форкаемся
2. Потомок вызывает `ptrace(PTRACE_TRACEME, 0, NULL, NULL)` и запускает `exec**` с нужной программой
3. Родитель постоянно вызывает `waitpid` с пидом потомка и ждет, пока не сработает очередная точка останова

Т.е. примерно так

```c++
void child_main()
{
    /* 
     * Позволяем родителю отслеживать себя
     */
    ptrace(PTRACE_TRACEME, 0, NULL, NULL);
    /* 
     * Запускаем отлаживаемую программу
     */
    execlp("executable", "arg1");
}

void parent_main(pid_t child)
{
    int wstatus;
    while (1)
    {
        /* 
         * Ждем остановки потомка
         */
        waitpid(child_pid, &wstatus, 0);
        if (!WIFSTOPPED(wstatus))
        {
            /*
             * Потомок завершил работу
             */
            break;
        }
        /*
         * Выполняем необходимые действия над потомком
         */
        perform_actions(child_pid);
        /* 
         * Продолжаем его работу
         */
        ptrace(PTRACE_CONT, child_pid, NULL, NULL);
    }
}

int main()
{
    pid_t child_pid;
    if ((child_pid = fork()) == 0)
    {
        child_main();   
    }
    else
    {
        parent_main(child_pid);
    }
}
```

### Присоединяемся к запущенному процессу

Если какой-то процесс уже запущен и мы хотим его отладить, то для этого используется уже другой вызов - `PTRACE_ATTACH`.


При присоединении к другому процессу через `PTRACE_ATTACH` отлаживаемому процессу посылается `SIGSTOP` - это нужно, чтобы мы могли остановить процесс и поработать с ним.
Системные вызовы могут вернуть `EINTR`, когда они прерываются сигналом.
Поэтому, можно сказать, что `PTRACE_ATTACH` создает этот `errno`.

Пример такой:

```c++

int main()
{
    int wstatus;
    pid_t child_pid = obtain_pid();
    ptrace(PTRACE_ATTACH, child_pid, NULL, NULL);
    while (1)
    {
        waitpid(child_pid, &wstatus, 0);
        if (!WIFSTOPPED(wstatus))
        {
            /*
             * Потомок завершил работу
             */
            break;
        }
        /*
         * Выполняем необходимые действия над потомком
         */
        perform_actions(child_pid);

        /* 
         * Продолжаем его работу
         */
        ptrace(PTRACE_CONT, child_pid, NULL, NULL);
    }
}
```


Если нам НЕ нужно останавливать процесс после присоединения, то для этого используется `PTRACE_SEIZE`.
В этом случае, нам становится доступна еще одна команда - `PTRACE_INTERRUPT`. 
Как понятно из имени, он нужен для прерывания потока.
В man'е описано 4 варианта развития событий при выполнении этой команды: 
- При выполняющемся системном вызове этот вызов вернет `EINTR`
- Уже остановленный, но при применении `PTRACE_LISTEN`
- При конкурентном событии остановки
- Все остальные случаи
  
TODO: может добавить этот пример?
Пример для `PTRACE_SEIZE` оставляю на читателя.

## Собирая детали вместе

На этом моменте, в голове уже имеется общая картина, того как работают отладчики: процесс останавливается сигналом, мы его препарируем и продолжаем его работу.

Давайте сделаем свой небольшой пример использования.
Я придумал такой: приложение для складывания 2 чисел.
Ему через аргументы передаются эти 2 числа, он их складывает и печатает ответ.
Наша задача заключается в том, чтобы поменять одно из слагаемых таким образом, чтобы сумма осталась корректной, но одно из слагаемых (я возьму правое) поменялось.
Грубо говоря, прямо перед выводом результата присоединиться и изменить значение переменой слагаемой.
Звучит просто, давайте напишем.

Вначале бизнес-логика. 
Здесь все просто:

- Через argc/argv передаются аргументы
- С помощью `atol` парсим второй и третий аргументы (первый - название программы)
- Складываем 
- Выводим с помощью `printf`

Тут даже особо думать не надо. 
Можно набросать так:

```c++
int main(int argc, const char **argv)
{
    if (argc != 3)
    {
        return 1;
    }

    int left = atol(argv[1]);
    int right = atol(argv[2]);
    int sum = left + right;
    printf("%ld + %ld = %ld\n", left, right, sum);
    return 0;
}
```

Теперь надо подумать над тем, как сделать так, чтобы `right` изменился между суммой и вызовом `printf`.
Вспомним, что потомок замораживается, когда получает сигнал, причем любой.
Это сделать можно вызовом `raise` - просто передаем ему нужный сигнал и все.
Я использую `SIGCHLD`, т.к. по умолчанию он игнорируется и процесс не упадет, если его (сигнал) не обработать.
Как-то так:

```c++
int sum = left + right;
raise(SIGCHLD);
printf("%ld + %ld = %ld\n", left, right, sum);
```

Но не тут-то было.
Проблема в данном случае - определить где значение эта переменная хранится.
Я запускаю этот код на Linux, на нем используется System V ABI.
То есть, я знаю в каких регистрах должны хранится аргументы для `printf`, но опять проблема - в процессе вызова самого `raise` эти регистры затрутся аргументами для внутренних функций.
Короче говоря, это проблема.


Я не придумал ничего лучше, чем переписать все на ассемблере и сделать следующие ходы:

- Переменные `left`, `right` и `sum` теперь хранятся на стеке
- Так как этим стеком управляю я, то знаю на каком смещении от `rbp` какая переменная хранится
- Сам адрес `rbp` я сохраняю во внешнем файле, который читает отладчик

Честно говоря, это моя первая программа на ассемблере, поэтому ее качество оставляет желать лучшего:

<spoiler title="Код tracee на ассемблере">

Я использовал ассемблер GAS и синтаксис AT&T

```assembler
TODO: код
```

</spoiler>

Также имеется и отладчик.
Он делает то, что нужно - дожидается остановки tracee, читает файл с адресом и изменяет переменную.
Тут ассемблер уже не нужен.

<spoiler title="Код tracer">

```c++
TODO: код
```

</spoiler>

Да, это все было сложно и муторно - сколько всего пришлось сделать, чтобы просто поменять значение переменной.
Но есть хорошие новости - этот процесс можно очень легко упростить.
Помните, что мы останавливаемся на каждом сигнале. 
Вот была бы такая вещь, которая просто создаст сигнал и все.

Хорошая новость - она есть!

<spoiler title="Другие попытки этой реализации">

- через SIGFPE и деление
- простой вызов `raise`

</spoiler>

## int 0x3

`int 0x3` - это инструкция, которая создает нужный нам сигнал:

- `int` - это ассемблерная инструкция, генерирующая программное прерывание. Она принимает на вход аргумент
- `0x3` - номер прерывания для точки останова

Сейчас я говорю про архитектуру x86.
Она определяет [таблицу (вектор) прерываний](https://wiki.osdev.org/Interrupt_Vector_Table#:~:text=On%20the%20x86%20architecture%2C%20the,older%20software%20(e.g.%20MS-DOS%20programs)).

Когда процесс доходит до этой инструкции, то генерируется программное прерывание, которое приводит к получению `SIGTRAP`.
И вот в момент его получения мы можем получить контроль над процессом.

Давайте перепишем предыдущий код, но теперь уже с этой инструкцией.





# Пишем свой отладчик

- Тут попробовать PEEKUSER/POKEUSER
- Откат истории реализовать
- Запустить свой отладчик под отладкой

# Особенности управляемых языков

Тут про C#, java, javascript, python и другие яп.
Как в них работает отладка, какие особенности, м.б. покопаться в исходниках

# Другие платформы

Windows, FreeBSD, ColibriOS (???)

# Среды разработки

VS Code, CodeBlocks
Как различные IDE взаимодействуют с отладчиками - м.б. есть общий протокол работы с ними


TODO: jit реализован через ptrace ?
