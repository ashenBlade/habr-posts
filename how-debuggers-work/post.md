# Как работают дебаггеры

О чем написать:

1. Ядро работы дебагера: `ptrace` + `INT 3`
2. Попробовать написать свой дебаггер
   - Простой интерфейс
   - DWARF формат попробовать распарсить (и дебажиться по строчкам)
   - Фича - откат истории
3. Как работают в управляемых ЯП (байт-код, jit, C#, java, python)
4. Особенности различных платформ
   - Windows
   - FreeBSD
   - М.б. другие платформы
5. Как это работает в VS Code (про этот интерфейс рассказать на примере gdb)
6. Фичи некоторые:
   1. GDB вызывает функции как
   2. Развертка стека
7. Некоторые ответы на вопросы
   1. При attach есть настоящий родитель, а есть приаттачившийся - как получать уведомления (waitpid)?
   2. Цикл при отладке - один другого и наоборот отлаживает (https://habr.com/ru/articles/439882/)?
   3. Профилировщики используют `ptrace`?


# Ядро

Поинты:
- Все вокруг ptrace и int 3
- Сказать что буду на x86 рассказывать + в конце то как на других архитектурах это реализуется (м.б. есть особенности хз)
- ptrace - это системный вызов
- int 3 - это инструкция для генерации прерывания
- брейкпоинт - это по факту прерывание
- он специально сделан однобайтовым + пример где это может выстрелить если не однобайтовый
- PEEK and POKE рассказать
- БП только для инструкций - для строк и т.д. нужны отладочные символы
- Что если к завершенному потомку чужому приаттачиться? Все получат результат или только кто-то один (exit code потомка) 
- `strace` использует `PTRACE_SYSCALL` (найти код)

Весь процесс дебагинга крутится вокруг 2 вещей:
- `ptrace`
- `INT 3`

`ptrace` - это системный вызов, который используется для отслеживания процесса (**p**rocess **trace**). 
Интерфейс следующий:

`long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);`

Можно заметить сходство с другими вызовами по типу `ioctl` или `fcntl` - код запроса (перечисление `__ptrace_request`), идентификатор объекта (`pid`) и вспомогательные данные (`addr`, `data`).

> Понимаю, что на этом вызове много обязанностей и трудно придумать более тонкий вариант, но это как-то контрастирует с философией Unix - `делают что-то одно`. 
> Может я прикапываюсь.

Благодаря этому системному вызову можно:
- `PTRACE_CONT`/`PTRACE_SINGLESTEP` - Получить контроль над выполнением
- Прочитать и изменять:
  - `PTRACE_GETREGS`/`PTRACE_SETREGS` - Регистры
  - `PTRACE_PEEKDATA`/`PTRACE_POKEDATA` - Память и код
  - `PTRACE_PEEKUSER`/`PTRACE_POKEUSER` - TODO: придумать как назвать
  - `PTRACE_SET_THREAD_AREA` - Локальные данные потока (TLS)
- `PTRACE_SET_SYSCALL` - Подменять вызываемые системные вызовы
- `PTRACE_SECCOMP_GET_FILTER` - Получать информацию о [seccomp](https://man.archlinux.org/man/seccomp.2.en)

<spoiler title="PEEK & POKE">

TODO: тут про peek & poke написать

</spoiler>

Для начала рассмотрим общий взгляд на процесс отладки. Грубо говоря, процесс отладки итеративный и каждую итерацию можно представить в виде 3 шагов:

1. Ждем точку останова
2. Выполняем необходимые действия 
3. Продолжаем работы

Рассмотрим каждый шаг.

> Далее буду использовать терминологию из man: `tracer` - отладчик, `tracee` - процесс, который отлаживаем

## Ждем точку останова

Первое - нам необходимо дождаться остановки tracee. 
Пока представим, что она есть и рано или поздно tracee до нее дойдет.

Главный принцип работы `ptrace` можно описать так: tracee получает сигнал и останавливается, а tracer в этот момент получает контроль, что-то делает и продолжает работу tracee.
Для ожидания этого сигнала tracer использует `waitpid`.

TODO: надо ли оставлять?
> Раньше я думал, что этот системный вызов нужен для ожидания завершения дочернего процесса, но, в общем случае, он используется для отслеживания изменения статуса потомка (wait for state changes in child of the calling process, как написано в man'е).

И сам смысл точки останова в следующем:

> tracee останавливается каждый раз, когда *получает сигнал* (любой), а tracer в это время пробуждается и *`WIFSTOPPED`*, вызванный на полученном статусе, возвращает `true`. 

То есть, отслеживаемый процесс получает любой сигнал, в этот момент останавливается и `waitpid` возвращается с соответствующим статусом. 

Ждать остановки tracee требуется обязательно - практически все `ptrace` вызовы, которые изменяют состояние tracee, вернут `ESRCH`, если будут вызваны над работающим процессом. С одной стороны, ограничение - нельзя вставить палку в колеса едущему велосипеду, но, с другой, интересно было бы посмотреть что случиться. Если кратко, то только 5 команд не требуют остановленного состояния, но и они используются для начала и окончания процесса отладки. Об этих командах можно посмотреть в секции Informational and restarting ptrace commands в `man 2 ptrace`.

<spoiler title="Разные статусы остановки">

TODO: описать


тут про то, что 
- всего есть running и stopped состояния, причем заблокирован сисколом = running
- ptrace-stop имеет множество подклассов
- 


</spoiler>

Когда `waitpid` вернулся, то необходимо проверить его статус. Грубо говоря, статус можно разделить 2 случая - останов и конец работы процесса. Определить это можно по упомянутому выше `WIFSTOPPED`. С учетом того, что останавливаться будем множество раз, то код отладчика в общем случае можно представить следующим образом:

```cpp
pid_t pid;
int wstatus;
while (1)
{
    /* 
     * Ждем остановки tracee 
     */
    pid_t ret_pid = waitpid(pid, &wstatus, 0);
    if (!WIFSTOPPED(wstatus))
    {
        /* 
         * Процесс завершил работу
         */
        break;
    }

    /* 
     * Выполняем необходимые действия
     * ...
     */

    /* 
     * И продолжаем работу
     * ...
     */
}
```

## Основные манипуляции

На этом моменте, tracee остановлен, а нам (дебаггеру) вернули управление из `waitpid`. 
Представим, что точка останова сработала и процесс не завершил свою работу. 
Теперь начинается самое интересное - процесс отладки: просмотр и изменение состояния tracee.

Команды, которые призваны получать и изменять состояние tracee, в документации называются информационными (informational). Есть множество аспектов процесса, которыми мы можем управлять и для них есть по 2 команды (`PTRACE_*`) - для чтения и записи. 

Сейчас нас будут интересовать только `PTRACE_PEEKTEXT`/`PTRACE_POKETEXT` и `PTRACE_GETREGS`/`PTRACE_SETREGS`. Первая команда используется для получения и изменения данных и кода процесса, а вторая - для регистров.

> Дополнительно есть `PTRACE_PEEKDATA`/`PTRACE_POKEDATA`.
> Эта команда должна работать с данными процесса (областью памяти), а `PTRACE_PEEKTEXT`/`PTRACE_POKETEXT` - с секцией кода (`.text`).
> Но, как описано в man, у линукса адресное пространство данных и кода единое, поэтому обе команды выполняют одно и то же.

В сигнатуре `ptrace` используется 4 аргумента: первые 2 для идентификации процесса и операции, а вторые 2 - для передачи специфичных для конкретной операции параметров. В частности, передаются 2 указателя. Их семантика отличается от команды к команде, а некоторые команды используют только часть, либо не используют эти параметры вообще, поэтому для каждой команды надо смотреть отдельно.

Для примера, если `rax` равен 0, то записать число 1 (4 байтное число), по адресу из регистра `rbx`. Реализовать это можно следующим образом:

TODO: проверить

```cpp
struct user_regs_struct regs;
ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
if (regs.rax == 0)
{
    void *addr = (void *)regs.rbx;
    long data = ptrace(PTRACE_PEEKTEXT, child_pid, addr, NULL);
    *((int *)&data) = 1;
    ptrace(PTRACE_POKETEXT, child_pid, addr, (void*)data);
}
```

Обратите внимание на то, как записывается число 1.
Загвоздка в том, что команды `PEEKTEXT` и `POKETEXT` работают с машинным словом, грубо говоря, оперируют размером указателя.
У меня 64-битная машина, поэтому его размер 8 байтов, а записываю я 4-х байтное.
Если бы я хотел записать 8 байтное (`long`), то мог бы сделать это проще, без read-modify-write.

```cpp
struct user_regs_struct regs;
ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
if (regs.rax == 0)
{
    void *addr = (void *)regs.rbx;
    long data = 1L;
    ptrace(PTRACE_POKETEXT, child_pid, addr, (void*)data);
}
```

Ну и вообще, вся работа с памятью (чтение и запись) ведется подобным образом - читаем необходимый диапазон памяти по машинному слову и после записываем также по машинному слову.

## Продолжение работы

Когда все необходимые действия выполнили, то надо продолжить работу процесса.
Сделать это можно 2 способами:

- `PTRACE_SINGLESTEP` - Выполнить только 1 инструкцию
- `PTRACE_CONT` - Продолжить выполнение

Логично, что следующая остановка у первой команды будет у начала следующей инструкции, а у второй - при следующем сигнале.

## Изначальный запуск

Последнее, что мы не покрыли - как начинается процесс отладки.
Тут также есть 2 варианта:

- Сами запускаем процесс для отладки
- Присоединяемся к уже работающему процессу

### Самостоятельный запуск

Для самостоятельного запуска есть следующий паттерн:
1. Форкаемся
2. Потомок вызывает `ptrace(PTRACE_TRACEME, 0, NULL, NULL)` и запускает `exec**` с нужной программой
3. Родитель постоянно вызывает `waitpid` с пидом потомка и ждет, пока не сработает очередная точка останова

Т.е. примерно так

```c++
void child_main()
{
    /* 
     * Позволяем родителю отслеживать себя
     */
    ptrace(PTRACE_TRACEME, 0, NULL, NULL);
    /* 
     * Запускаем отлаживаемую программу
     */
    execlp("executable", "arg1");
}

void parent_main(pid_t child)
{
    int wstatus;
    while (1)
    {
        /* 
         * Ждем остановки потомка
         */
        waitpid(child_pid, &wstatus, 0);
        if (!WIFSTOPPED(wstatus))
        {
            /*
             * Потомок завершил работу
             */
            break;
        }
        /*
         * Выполняем необходимые действия над потомком
         */
        perform_actions(child_pid);
        /* 
         * Продолжаем его работу
         */
        ptrace(PTRACE_CONT, child_pid, NULL, NULL);
    }
}

int main()
{
    pid_t child_pid;
    if ((child_pid = fork()) == 0)
    {
        child_main();   
    }
    else
    {
        parent_main(child_pid);
    }
}
```

### Присоединяемся к запущенному процессу

Если какой-то процесс уже запущен и мы хотим его отладить, то для этого используется уже другой вызов - `PTRACE_ATTACH`.


При присоединении к другому процессу через `PTRACE_ATTACH` отлаживаемому процессу посылается `SIGSTOP` - это нужно, чтобы мы могли остановить процесс и поработать с ним.
Системные вызовы могут вернуть `EINTR`, когда они прерываются сигналом.
Поэтому, можно сказать, что `PTRACE_ATTACH` создает этот `errno`.

Пример такой:

```c++

int main()
{
    int wstatus;
    pid_t child_pid = obtain_pid();
    ptrace(PTRACE_ATTACH, child_pid, NULL, NULL);
    while (1)
    {
        waitpid(child_pid, &wstatus, 0);
        if (!WIFSTOPPED(wstatus))
        {
            /*
             * Потомок завершил работу
             */
            break;
        }
        /*
         * Выполняем необходимые действия над потомком
         */
        perform_actions(child_pid);

        /* 
         * Продолжаем его работу
         */
        ptrace(PTRACE_CONT, child_pid, NULL, NULL);
    }
}
```


Если нам НЕ нужно останавливать процесс после присоединения, то для этого используется `PTRACE_SEIZE`.
В этом случае, нам становится доступна еще одна команда - `PTRACE_INTERRUPT`. 
Как понятно из имени, он нужен для прерывания потока.
В man'е описано 4 варианта развития событий при выполнении этой команды: 
- При выполняющемся системном вызове этот вызов вернет `EINTR`
- Уже остановленный, но при применении `PTRACE_LISTEN`
- При конкурентном событии остановки
- Все остальные случаи
  
TODO: может добавить этот пример?
Пример для `PTRACE_SEIZE` оставляю на читателя.

## Собирая детали вместе

На этом моменте, в голове уже имеется общая картина, того как работают отладчики: процесс останавливается сигналом, мы его препарируем и продолжаем его работу.

Давайте сделаем свой небольшой пример использования.
Я придумал такой: приложение для складывания 2 чисел.
Ему через аргументы передаются эти 2 числа, он их складывает и печатает ответ.
Наша задача заключается в том, чтобы поменять одно из слагаемых таким образом, чтобы сумма осталась корректной, но одно из слагаемых (я возьму правое) поменялось.
Грубо говоря, прямо перед выводом результата присоединиться и изменить значение переменой слагаемой.
Звучит просто, давайте напишем.

Вначале бизнес-логика. 
Здесь все просто:

- Через argc/argv передаются аргументы
- С помощью `atol` парсим второй и третий аргументы (первый - название программы)
- Складываем 
- Выводим с помощью `printf`

Тут даже особо думать не надо. 
Можно набросать так:

```c++
int main(int argc, const char **argv)
{
    if (argc != 3)
    {
        return 1;
    }

    int left = atol(argv[1]);
    int right = atol(argv[2]);
    int sum = left + right;
    printf("%ld + %ld = %ld\n", left, right, sum);
    return 0;
}
```

Теперь надо подумать над тем, как сделать так, чтобы `right` изменился между суммой и вызовом `printf`.
Вспомним, что потомок замораживается, когда получает сигнал, причем любой.
Это сделать можно вызовом `raise` - просто передаем ему нужный сигнал и все.
Я использую `SIGCHLD`, т.к. по умолчанию он игнорируется и процесс не упадет, если его (сигнал) не обработать.
Как-то так:

```c++
int sum = left + right;
raise(SIGCHLD);
printf("%ld + %ld = %ld\n", left, right, sum);
```

Но не тут-то было.
Проблема в данном случае - определить где значение эта переменная хранится.
Я запускаю этот код на Linux, на нем используется System V ABI.
То есть, я знаю в каких регистрах должны хранится аргументы для `printf`, но опять проблема - в процессе вызова самого `raise` эти регистры затрутся аргументами для внутренних функций.
Короче говоря, это проблема.


Я не придумал ничего лучше, чем переписать все на ассемблере и сделать следующие ходы:

- Переменные `left`, `right` и `sum` теперь хранятся на стеке
- Так как этим стеком управляю я, то знаю на каком смещении от `rbp` какая переменная хранится
- Сам адрес `rbp` я сохраняю во внешнем файле, который читает отладчик

Честно говоря, это моя первая программа на ассемблере, поэтому ее качество оставляет желать лучшего:

<spoiler title="Код tracee на ассемблере">

Я использовал ассемблер GAS и синтаксис AT&T

```assembler
TODO: код
```

</spoiler>

Также имеется и отладчик.
Он делает то, что нужно - дожидается остановки tracee, читает файл с адресом и изменяет переменную.
Тут ассемблер уже не нужен.

<spoiler title="Код tracer">

```c++
TODO: код
```

</spoiler>

Да, это все было сложно и муторно - сколько всего пришлось сделать, чтобы просто поменять значение переменной.
Но есть хорошие новости - этот процесс можно очень легко упростить.
Помните, что мы останавливаемся на каждом сигнале. 
Вот была бы такая вещь, которая просто создаст сигнал и все.

Хорошая новость - она есть!

<spoiler title="Другие попытки этой реализации">

- через SIGFPE и деление
- простой вызов `raise`

</spoiler>

## int 0x3

`int 0x3` - это инструкция, которая создает нужный нам сигнал:

- `int` - это ассемблерная инструкция, генерирующая программное прерывание. Она принимает на вход аргумент
- `0x3` - номер прерывания для точки останова

Сейчас я говорю про архитектуру x86.
Она определяет [таблицу (вектор) прерываний](https://wiki.osdev.org/Interrupt_Vector_Table#:~:text=On%20the%20x86%20architecture%2C%20the,older%20software%20(e.g.%20MS-DOS%20programs)).

Когда процесс доходит до этой инструкции, то генерируется программное прерывание, которое приводит к получению `SIGTRAP`.
И вот в момент его получения мы можем получить контроль над процессом.

Давайте перепишем предыдущий код, но теперь уже с этой инструкцией.

<spoiler title="Код tracee на ассемблере">

```assembler
TODO: код
```

Заметьте, что в начале регистрируется обработчик `SIGTRAP`.
Я преследовал такую логику, чтобы этот сигнал не влиял на работу без отладчика. 
Грубо говоря, если нет отладчика (нашего), то все работает, но если запуск под ним, то логика меняется как хотим.



</spoiler>

Код tracer'а изменится соответственно

<spoiler title="Код tracer'а">

```c++
TODO: код
```

</spoiler>

<spoiler title="SIGTRAP особенный">

Тут рассказать про то, что некоторые сигналы игнорировать нельзя и если это сделать, то по умолчанию они станут в SIG_DFL

Табличку построить, что и когда происходит (hard, soft / int3, raise)

man 7 signals -> BUGS -> Сигналы которые перечислены будут доставляться всегда, если вызваны hardware (грубо говоря), SIGTRAP там тоже есть

Показать список сигналов, которые просто сбросят SIG_IGN/block (взять из force_sig)

Запись в interrupt descriptor table для int3 - https://github.com/torvalds/linux/blob/ec9eeb89e60d86fcc0243f47c2383399ce0de8f8/arch/x86/kernel/traps.c#L735

Сам обработчик, который выставляет SIG_IGN в SIG_DFL - https://github.com/torvalds/linux/blob/master/kernel/signal.c#L1326

</spoiler>

В общем, можно сказать что все готово - брейкпоинты реализуются через `int 0x3` инструкцию, можно заканчивать.
Но есть последний момент, который надо обсудить - где и как эту инструкцию вставлять.

Сейчас я написал все на ассемблере и у меня был полный контроль над исходным кодом.
Но 1) почти все пишут на более высокоуровневых ЯП и машинные инструкции там использовать нельзя, 2) не всегда есть доступ к исходному коду.
То есть просто так вставить `int 0x3` и вызвать нужное прерывание в готовом бинарнике мы не можем.
Как быть в этой ситуации?

Ответ прост - затереть инструкции.

## Как ставятся точки останова

В реализации точек останова, грубо говоря, 2 основных алгоритма: ее выставление и момент захода в нее.

Выставление точки останова:

1. Получаем адрес нужной нам инструкции
2. Пишем поверх нее инструкцию `int 0x3` (запоминаем что затерли!)

Заход в точку останова:

1. Точка останова срабатывает
2. Tracer подготавливает окружение:
   1. Получает управление
   2. Восстанавливает затертую инструкцию
   3. Переходит к предыдущей инструкции
3. Tracer выполняет необходимые манипуляции
4. Tracer продолжает выполнение tracee

Для tracee это все происходит прозрачно - кроме сигнала практически нет внешних эффектов.

Кто-то может спрость "как так? секция `.text` недоступна для записи!".
Да, но только для пользовательского пространства, а в случае с `ptrace` - 1) часть ядра, 2) может выполняться только если выполняется с полученными привилегиями.
Короче говоря, с помощью `ptrace` можно изменять и секцию `.text`.
Вы могли заметить команду `PTRACE_POKETEXT` - как можно догадаться это она изменяет код программы (то что по переданному адресу находится).

Но и тут не все, есть еще один важный момент.
Не забываем, что `int 0x3` - это всего лишь инструкция ассемблера, а ассемблер != машинные инструкции, то есть отображение не всегда однозначное.
И тут мы приходим к последнему аспекту.

## Однобайтная инструкция `int 0x3`

Может показаться что `int 0x3` - 2 байтная инструкция (команда + аргумент), но на практике она занимает *1 байт* - `0xCC`.

TODO: проверить
> Можно использовать и 2 байтную инструкцию - `0xCD 0x03`. Она тоже сработает.

Почему это важно?
Достаточно рассмотреть такой частный случай: проверка аргументов в начале функции.

На C это можно реализовать так:

```c++
/* 
 * Пользователь обновил свой интервал бронирования номера - нам нужно уведомить об этом других
 */
void notify_user_rest_interval(long start, long end)
{
    if (start == end)
    {
        /* 
         * Однодневный интервал пропускаем для оптимизации
         */
        return;
    }

    /* 
     * Уведомляем по телеге
     */
    notify_telegram();
}
```

После компиляции, мы можем получить такой ассемблерный код (справа машинный код):

```assembler
notify_user_rest_interval:
    cmpq %rdi, %rsi         # 48 39 FE
    jnz pass                # 75 01
    ret                     # C3
pass:
    call notify_telegram    # e8 00 00 00 00                   
```

Теперь представим, что `int 0x3` занимает 2 байта и мы хотим поставить точку останова прямо на `return`/`ret`.
То есть отловить все моменты, когда вызов "не совсем оптимальный".
Что произойдет?
Заметим, что `ret` - однобайтная и если ее перетереть нашим 2-х байтным `int 0x3`, то это затронет следущую инструкцию - `call`.
TODO: как правильно назвать первый байт инструкции
Учитывая что первый байт инструкции - ее `opcode` (тип команды), то будет 

Если обобщить, то 2-х байтный код для точки останова для 1 байтной команды может переписать следущую инструкцию и сделать ее невалидной, что приведет к проблемам при переходах (семейство инструкций `jmp`, `call` и т.п.).
Поэтому 1 байт для инструкции точки останова всегда затронет, только необходимую инструкцию и не повлияет на последующую функциональность.

TODO: по другому оформить
Замечания:
- Хотел адаптировать пример из Eli, но стр. 14 [AMD Reference](https://tc.gtisc.gatech.edu/cs6265/2016/refs/amd64-vol3-inst.pdf) указывает, что 1-байтных инструкций для INC/DEC больше нет (только режим совместимости)


Но для наглядность посмотрим, что будет при 2 байтной инструкции.

```assembler
    notify_user_rest_interval:
    cmpq %rdi, %rsi         # 48 39 FE
    jnz pass                # 75 01
    int $3                  # CD
pass:
    addl (%rax), %eax       # 03 00 
    addb %al, (%rax)        # 00 00  
    n/a                     # 00
```

Здесь важно заметить, что для `call` я ранее передавал нули, так как реальный адрес появится только во время выполнения.
Поэтому для примера я также использую нули.

И уже тут можно заметить, что:

1. Вызов функции `notify_telegram` исчез
2. Добавились новые инструкции, которые изменяют содержимое регистров (наше состояние), причем скорее всего мусором, так как используется `rax` - регистр для результата функции (не инициализирован)
3. В конце вообще появилась некорректная инструкция `00` - обозначил n/a


В данном случае, мы хотябы словим `SIGILL` за счет последней некорректной инструкции и ничего плохого не сделаем.
Но с учетом того, что адрес будет случайным (спасибо ASLR), то на месте мной указанных появятся случайные инструкции и тогда будь что будет.

---

Вот теперь, можно сказать, что тему ядра отладчиков покрыли.
Суммируя:

1. Вся магия заключена в комбинации системного вызова `ptrace` и инструкции `int 0x3`
2. Отладчик просто ждет пока потомок не остановится при возникновении очередного сигнала
3. Для создания этого сигнала используется `int 0x3`, которая создает `SIGTRAP` сигнал
4. Точка останова - это `int 0x3` записанная поверх исходных инструкций и, когда до нее доходим, восстанавливаем исходные инструкции и ступаем на 1 инструкцию назад

Надеюсь, объяснил понятно.
Но это только вершина айсберга - я хочу копнуть немного глубже.

# Детали работы отладчиков

Ранее мы работали только с инструкциями, но обычно мы работаем с исходным кодом.
Мост, соединяющий эти 2 мира - отладочные символы.

## Отладочные символы

Скорее всего, вы и так уже знаете что такое отладочные символы.
Это специальные символы (symbols), которые добавляют некоторую полезную информацию, относительно исходного кода.
Например, переменные и их типы, разметка структур, отображение инструкций на строки исходного кода и т.д.

Существует множество форматов. Я чаще всего слышал про DWARF (в контексте *nix) и PE-COFF (в контексте Windows):

TODO: написать что-нибудь про них
- DWARF - Debugging With Arbitrary Record Formats
- PE-COFF - Portable Executable COFF)

TODO: Про BPF - https://habr.com/ru/articles/514736/ 

Кроме них я нашел и другие:

TODO: полезно - https://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf

TODO: все тезисы проверить

### STABS

[STABS](https://sourceware.org/gdb/current/onlinedocs/stabs.html) (Symbol TABle Strings) - один из первых форматов отладочных символов (1980-е). Название исходит из того, что все данные для отладки хранились в виде простых строк в таблице символов объектного файла (тогда еще `a.out` - не ELF).

Изначально создавался для pdx - дебаггера Pascal. Сейчас поддерживается и для других языков.

Вся отладочная информация хранится в специальных таблицах символов - stab. Для разной информации имеются разные директивы ассемблера:

- `.stabs` - строковая информация: функции, структуры, строки исходного кода, глобальные переменные (используется чаще всего)
- `.stabn` - числовая информация (скорее та, для которой не нужны строки): общее количество символов, адрес `catch` для GNU C++ (`N_CATCH`)
- `.stabd` - то же, что и `stabn`, но значение - текущая строка (явно не указывается значение): (примеров не нашел)

TODO: где использовался/кто поддерживает

### OMF

[OMF](https://refspecs.linuxfoundation.org/elf/TIS1.1.pdf)(\[Relocatable\] Object Module Format) - это на самом деле формат объектных файлов, а не отладочной информации. 
Но поддержка отладочной информации в нем явная - отдельные, "well-known" записи.


Объектный файл представляется в виде последовательности записей, каждая из которых состоит из 4 "полей":

|               | Тип                                     | Длина                                       | Данные                                             | Чек-сумма                      |
| ------------- | --------------------------------------- | ------------------------------------------- | -------------------------------------------------- | ------------------------------ |
| Размер (байт) | 1                                       | 2                                           | N                                                  | 1                              |
| Описание      | Определяет какие данные содержит запись | Длина оставшейся части (Данные и Чек-сумма) | Сама полезная нагрузка. Содержимое зависит от Типа | Чек-сумма всех остальных полей |

Как можно заметить, поле тип определяет содержимое записи.
В TIS определили 28 типов записи. Например, запись PUBDEF (PUBlic DEFinitions) определяет список экспортируемых (глобальных) символов.
Но пока сфокусируемся на отладке.

Для отладки можно использовать следующие записи:

- LINNUM - Отображение строк исходного кода, на адреса машинных инструкций
- LINSYM - Отображение функций на строки исходного кода (вместе с LINNUM позволяет понять адрес начала функции)
- PUBDEF, LPUBDEF - Функции и переменные - глобальные и локальные (в зависимости от префикса L). Можно сказать, что разница в том указывается ли `static` или нет
- COMDEF, LCOMDEF - Общие (communal) переменные - неинициализированные статические или те, что могут соответствовать инициализированным, но в другой единице компиляции

> У PUBDEF и COMDEF есть свои братья LPUBDEF и LCOMDEF соответственно. Первые экспортируют свои символы, а вторые имеют видимость только в пределах своего модуля.

Перечисленные записи указываются в TIS как актуальные. Но в расширениях были определены и другие (в документе помечены как устаревшие):

- DEBSYM - Дополнительная отладочная информация
- TYPDEF - Информация о типе
- LOCSYM - Информация о локальных символах
- BLKDEF - Информация о блоке программы, которая содержит свою видимость, локальные переменные

Это довольно старый формат: последняя версия V5.0 была издана Intel в 1985. За все время существования многие компании создали свои ответвления/надстройки: в документе (ссылка сверху) дана спецификация для OMF, созданная из компиляции 6 различных источников.
После 5 версии выкладывались и другие версии, но они были специфичны для разлиных платформ, например, IBM в 1993 выложил свою [спецификацию IBM-OMF](http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/pc/os2/OS2_OMF_and_LX_Object_Formats_Revision_8_199406.pdf).

P.S. Не думаю, что этот формат мертв. Как минимум, автор [этой статьи](https://habr.com/ru/articles/576770/) приложил усилия и перевел свою систему программирования на PL/1-KT с 16 на 64 бит.

<spoiler title="Сегментная организация 8086">

TODO: здесь про far указатели - https://en.wikipedia.org/wiki/Far_pointer

</spoiler>

### BTF
TODO: не забыть связь с CTF (или как он там)
[BTF](https://docs.kernel.org/bpf/btf.html) (BPF Type Format) - это формат метаданных, разработанный специально для BPF программ.
Сегодня, на замену BPF пришел eBPF, но я буду использовать BPF - так короче.
Изначально он поддерживал только информацию о типах (что отражается в самом названии), но после была добавлена поддержка функций, данных исходного кода (строки), переменных и др.

Сам по себе BPF это последовательно 64-битных инструкций, которые JIT-компилируются ядром.
Но для разработки этот ассемблер не очень удобен, поэтому разработали libbpf и формат ELF специально для BPF.
libbpf читает этот ELF файл, выполняет необходимые манипуляции и сам уже вызывает необходимые системные вызовы.
А для создания этого объектника можно использовать понятные нам языки по типу C или Rust.

Отладка возможна благодаря отладочным секциям, которые содержат нужную информацию.

- `.BTF` - Различная полезная информация - типы, переменные, квалификаторы, функции и т.д.
- `.BTF.ext` - Данные, необходимые загрузчику для манипуляций перед загрузкой в ядро.
- `.BTF_ids` - Содержит BTF ID - идентификаторы, которые использует ядро.

Как можно понять, именно в секции `.BTF` содержится вся необходимая для нас информация.
Она состоит из 2 частей: таблица строк (string table) и массив отладочной информации, далее МОИ
(в документации говорится `type data`, но мне кажется "массив отладочной информации" более говорящее название).
Таблица строк - это просто массив C-style строк, к которой обращается каждый элемент МОИ.

Каждый элемент МОИ имеет общую структуру, но далее каждый конкретный тип расширяет эту структуру, добавляет свои специфичные данные.
Под типом имеется ввиду не только `type`, но разные синтаксические конструкции и другая информация.
В исходном коде, это называют `KIND`, но другого перевода я не нашел.

На данный момент, поддерживаются следующие типы.

```cpp
/* https://github.com/torvalds/linux/blob/1722389b0d863056d78287a120a1d6cadb8d4f7b/include/uapi/linux/btf.h#L59 */
enum {
	BTF_KIND_UNKN		= 0,	/* Unknown	*/
	BTF_KIND_INT		= 1,	/* Integer	*/
	BTF_KIND_PTR		= 2,	/* Pointer	*/
	BTF_KIND_ARRAY		= 3,	/* Array	*/
	BTF_KIND_STRUCT		= 4,	/* Struct	*/
	BTF_KIND_UNION		= 5,	/* Union	*/
	BTF_KIND_ENUM		= 6,	/* Enumeration up to 32-bit values */
	BTF_KIND_FWD		= 7,	/* Forward	*/
	BTF_KIND_TYPEDEF	= 8,	/* Typedef	*/
	BTF_KIND_VOLATILE	= 9,	/* Volatile	*/
	BTF_KIND_CONST		= 10,	/* Const	*/
	BTF_KIND_RESTRICT	= 11,	/* Restrict	*/
	BTF_KIND_FUNC		= 12,	/* Function	*/
	BTF_KIND_FUNC_PROTO	= 13,	/* Function Proto	*/
	BTF_KIND_VAR		= 14,	/* Variable	*/
	BTF_KIND_DATASEC	= 15,	/* Section	*/
	BTF_KIND_FLOAT		= 16,	/* Floating point	*/
	BTF_KIND_DECL_TAG	= 17,	/* Decl Tag */
	BTF_KIND_TYPE_TAG	= 18,	/* Type Tag */
	BTF_KIND_ENUM64		= 19,	/* Enumeration up to 64-bit values */

	NR_BTF_KINDS,
	BTF_KIND_MAX		= NR_BTF_KINDS - 1,
};
```

Можно заметить, что все элементы имеют свой эквивалент в языке C, хотя сейчас не только из него можно скомпилировать BPF программу.
Например, Rust поддерживается тоже.
Причина в том, что этот формат изначально разрабатывался именно для C.
BTF был добавлен в [этом патче](https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=69b693f0aefa0ed521e8bd02260523b5ae446ad7)
и вот отрывок из него:

> Hence, it basically focus on the C programming language which the modern BPF is primary using.

### COFF



- COFF
  - XCOFF
  - ECOFF
- VMS
- CTF (Compact C Type Format)
- CodeView (CV4)
- HLASM
- IEEE-695
- IMB 360 object format


> TODO: тут про разницу между -g и -ggdb (что делают, когда разница заметна)

> TODO: замедляет ли скорость отладочные символы (тут еще что устанавливаемые пакеты содержат отладочные символы)

[ ] Форматы символов (обзор)
[ ] Общие поля для отладочных символов (строки, исходный код, типы и т.д.)
[ ] Небольшой обзор DWARF


## Шагаем по коду

- По инструкциям
- По исходному коду (step in, step out, step over) - как каждый можно реализовать

## Исследуем gdb

- Обзор архитектуры
- Как step in/out/over реализованы
- Замечание по поводу отступов (не соблюдаются)
- Детали реализации интересные

# Особенности управляемых языков

Тут про C#, java, javascript, python и другие яп.
Как в них работает отладка, какие особенности, м.б. покопаться в исходниках

# Другие платформы

Windows, FreeBSD, ColibriOS (???)

# Среды разработки

VS Code, CodeBlocks
Как различные IDE взаимодействуют с отладчиками - м.б. есть общий протокол работы с ними


TODO: jit реализован через ptrace ?
