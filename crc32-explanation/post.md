# Объяснение работы CRC32


План:

# Мотивация (введение)

Целостность - это важное свойство системы. 
Будет плохо, если пользовательские данные будут искажены, а мы и глазом не моргнем.

Существуют различные способы достижения этого. Как например, коды коррекции или обнаружения ошибок.
Собственно задача следующая: нам поступают пакеты данных и в процессе передачи данные могут быть искажены, 
поэтому принимающая сторона должна уметь обнаруживать подобные ситуации.

Одним из таких механизмов является CRC (Cyclic Redundancy Check) - циклический избыточный код.
Именно его я решил использовать для проверки целостности в приложении. 
Его реализаций в интернете полно - Ctrl + C, Ctrl + V не хочу.
Но я не я, если бы не ~~сделал свой велосипед~~ разобрался как этот алгоритм работает.

TODO: ссылки на статьи и т.д.

# Обзор алгоритма
   - Двоичная математика без учета переноса 
   - Показать как деление столбиком реализуется
   - Сложение и разница - одно и то же = XOR

Грубо говоря, CRC - это просто остаток от деления.

## Деление чисел с остатком

По факту, основное требование - обнаружение изменения даже одного байта. 
Т.е. все биты данных должны учитываться. 
Но неплохо было бы иметь и "лавинность" как у криптографических хэш-функций.
На ум приходит деление, а точнее остаток от деления.

Например, поделим `645372` на `436521` и получим в остатке `208851`. 
Поменяем только 1 цифру в делимом и попробуем снова: `644372 % 436521 = 207851`.
Результат изменился - `208851` и `207851` не равны.

Что если представить поток байт, для которого нужно подсчитать чек-сумму, в виде очень большого числа?
Тогда нам остается только найти остаток от деления этого большого числа на делитель.
Уже неплохо. Но как этот делитель найти?
Тут надо вспомнить важное свойство остатка - он всегда меньше делителя.
Прекрасно! Тогда возьмем такой делитель, чтобы остаток укладывался в определенное число байт.
Например, если чек-сумма должна быть 4 байтной, то и максимальное значение делителя должно быть меньше 2^33.

Основу заложили - представляем байты в виде большого числа и находим его остаток от деления на число меньше 2^33.

Посмотрим, как реализуется деление с остатком в двоичном виде:

### TODO: картинка с визуализацией деления.

## Деление многочлена с остатком

Те, кто уже знаком с CRC, знает, что там разговор идет о полиномах, а не числах.
Тут мы подходим к другой важной концепции: остаток от деления многочлена. 

Получить остаток от деления можно не только от числа, но и от многочлена. 
Определяется остаток так же как и для обычных чисел. 
Разница только в том, что результатом будет не число, а многочлен.

Например, поделим многочлен `x^6 + 8x^4` на `x^5 + 1`, тогда в результате получим:
- Частное: `x`
- Остаток: `8x^4 - x`

TODO: нарисовать визуализацию

Но при чем тут многочлены? 
Дело в том, что многочлен можно закодировать в последовательность чисел - каждое отражает коэффициент при соответствующей степени.

| Число        | x^6 | x^5 | x^4 | x^3 | x^2 | x^1 | x^0 |
|--------------|-----|-----|-----|-----|-----|-----|-----|
| `x^6 + 8x^4` | 1   | 0   | 8   | 0   | 0   | 0   | 0   |
| `x^5 + 1`    | 0   | 1   | 0   | 0   | 0   | 0   | 1   |
| `x`          | 0   | 0   | 0   | 0   | 0   | 1   | 0   |
| `8x^4 - x`   | 0   | 0   | 8   | 0   | 0   | -1  | 0   |
 
Можно подметить, что двоичные числа - это закодированные многочлены.
Их коэффициенты могут принимать только 0 или 1.
Но как быть с умножениями в таком случае, ведь может получиться больше 1?

Здесь на арену приходит "полиномиальная арифметика по модулю 2".
Вкратце, она говорит, что все коэффициенты при каждой степени независимы друг от друга ("полиномиальная арифметика"), 
а результирующий коэффициент - это остаток от деления полученной суммы коэффициентов на 2 ("по модулю 2").

Пример: `(x^4 + x^2 + 1) * (x^3 + x^2 + x) = 
(x^7 + x^6 + x^5) + (x^5 + x^4 + x^3) + (x^3 + x^2 + x) =
x^7 + x^6 + 2x^5 + x^4 + 2x^3 + x^2 + x =
x^7 + x^6 +        x^4 +        x^2 + x`

## Двоичная арифметика без учета переносов

Можно заметить, что операция сложения и деления - XOR.
Единственное, надо понять, как в такой арифметике делить.
Деление можно реализовать с помощью вычитания. 
Проблема в том, как понять что одно число больше другого, ведь вычитание и сложение - это одна и та же операция (XOR).
Для этого вводится понятие слабой размерности (weak definition of magnitude) - сравнение происходит по позиции наибольшего значащего бита: 
одно число больше другого, только если позиция его MSB больше позиции MSB другого числа.

Вот теперь и можем выполнить деление:

### TODO: визуализация деления

## Складываем все вместе

Можно заметить, что алгоритм деления числа на число (в двоичном представлении) 
использует те же самые правила, что и полиномиальная арифметика по модулю 2.

Все рассуждения об алгоритме CRC ведутся именно в таком ключе:
- Все операции происходят над многочленами в конечном поле по модулю 2 (GF(2))
- На вход подается многочлен - байты для высчитывания чек-суммы
- Делитель - другой многочлен (его называют порождающим)
- Задача CRC - найти остаток от деления переданного многочлена на порождающий

# Реализация в лоб

Реализация у нас уже на руках.
Осталось только несколько моментов:
- Добавим регистр - переменную, в которой будем хранить результат. 
  Его размер должен быть таким же как и у результата. 
  Здесь и дальше будем предполагать, что вычисляемая чек-сумма 32 бита (4 байта).
- Сообщение нужно дополнять в конце нулевыми байтами, чтобы регистр смог правильно обработать сообщение.
  Дополнять нужно столько-же, сколько занимает регистр (4 байта).

### TODO: реализация в лоб

# Реализация на практике
   
Предыдущая реализация в лоб режет глаз. 
Она неоптимальна, как минимум, потому что компьютер работает с байтами, а не потоком бит.
Перепишем так, чтобы работа велась с минимальным куском (byte) данных - байтом.

### TODO: побайтовая реализация

5. Оптимизация - таблица
   - Заметим, что дальнейшие шаги зависят от предыдущих - в будущее не смотрим
   - Что если построить таблицу + код создания таблицы
   - А если больше таблицу сделаем?  (м.б код тоже написать)

Уже неплохо. 
Но есть один момент, который стоит заметить, - зависимость операций.
Каждая операция зависит только от текущего бита и предыдущих операций - в будущее мы не смотрим.

Так как мы работаем с байтами, то это значит, что имея текущий байт, мы уже знаем значение на которое нужно XOR'ить.
Например:
- Значение регистра: xxx
- Полином: yyy

Сейчас мы можем вычислить значение, которое будет применено ко всему регистру:
### TODO: картинка как вычисляем это значение

А к чему будет это значение применяться? К оставшимся байтам регистра + следующий байт!
Т.е. будет так:
### TODO: картинка как это значение применяется

Компьютер всегда работает с байтами - отдельных битов быть не может. 
Давайте вычислим значения, которые нужно применять, в зависимости от старшего байта!

В этом и заключается оптимизация - создание подобной таблицы.

### TODO: код с табличной реализацией

# Проблемка...
   - Сообщение должно быть дополнено нулевыми байтами - столько, сколько в регистре
   - 2 варианта: пользователь дополняет либо циклы в конце
   - Заметим 2 вещи (как в статье изначальной)
     
Не забыли, что мы работаем с дополненным нулями сообщением? 
Вроде 4 байта, но не всегда удобно следить за таким. 
Тут есть 2 решения:
1. Вставлять дополнительный цикл в конце, чтобы пропустить последние байты

Это потребует от нас вставлять после основного цикла завершающий:
### TODO: код этого цикла

2. Всегда передавать дополненное нулями сообщение

Хоть код и останется лаконичным, это чревато ошибками. 

На самом деле, эту проблему уже решили. Причем, на мой взгляд, кардинальным способом - изменили сам алгоритм.
Чтобы понять, что имеется ввиду, посмотрим на следующие наблюдения:
1. Нулевые байты нужны только для того, чтобы были корректно обработаны все байты исходного сообщения.
   Причем сами нули ни на что не влияют (`x XOR 0 = x`).
   Т.е. по факту, можно их не добавлять - главное провести все байты сообщения через алгоритм. 
2. Первые 4 цикла - загрузка первых 4 байт сообщения.
   Причем независимо от того, что в регистре было изначально, этот этап можно опустить/сократить и сразу загружать сообщение.

<spoiler title="Почему первые 4 цикла можно опустить">
В зависимости от значения регистра может быть 2 случая:

1. Изначально был 0

Все просто - первые 4 цикла загрузят первые 4 байта сообщения и никаким образом их не изменят.
Изменений не будет, так как табличное значение для 0 - это 0, а `x XOR 0 = x`.

### TODO: не "дополненное", а выровненное

### TODO: визуализация этого варианта

2. Изначально был НЕ 0

Этот случай не отличается от того, что если бы мы выполнили XOR между первыми 4 байтами сообщения и какой-то другим числом.
Только это число не случайное, а вычислено из изначального значения регистра (об этом дальше).

</spoiler>

Модифицируем алгоритм следующим образом:
### TODO: текстовое описание алгоритма как в PDF

### TODO: написать новый алгоритм

Единственное, что пока непонятно - как рассчитывать новое начальное значение регистра.
Чтобы вычислить новое значение регистра, нужно пропустить старое значение через цикл 4 раза (только начальное значение, без байтов сообщения).

Например, если в старом алгоритме начальное значение было `0xFFFFFFFF`, то новое будет равно `0xC704DD7B` (полином равен `0x04C11DB7`).
В результате, эти 2 реализации будут давать одно и то же значение - `0xAE006622`.

Подобная оптимизация возможна так как операция XOR - ассоциативна. 
Это используется как раз в моменте XOR'а байта сообщения и старшего байта регистра:
- Раньше, мы сначала клали байт сообщения, а потом постепенно применяли к нему операции из таблицы - `message_byte XOR op1 XOR op2 XOR op3`
- Теперь, наоборот, мы сначала применяем операции из таблицы и только в конце байт сообщения - `op1 XOR op2 XOR op3 XOR message_byte`
  
Теперь вся задача свелась к одной единственной - для уже существующего регистра подсчитать регистр, к которому будет применен очередной байт.

<spoiler title="Сравниваем выполнение по шагам">

Рассмотрим выполнение старого и нового алгоритма по шагам.
Используем полином
### TODO: надо 

</spoiler>

# Параметризация
   - Вот мы и дошли до этой реализации
   - Есть различные параметры, как можно характеризовать алгоритмы

Вот мы и дошли до конца.
За все время мы видели 3 места, которые могут быть настроены: полином - значение и размер, исходное значение регистра.
Но на самом деле их больше. Можно добавить еще 2 параметра:
- XOR конечного результата с каким-то числом - перед возвращением результата он XOR'ится с каким-то числом
- Порядок байтов - можно указать, что при работе все биты должны быть отзеркалены (UART отправляет биты в обратном порядке) 

Росс Уильямс делает такую параметризацию:
- Width - Степень полинома, число битов в регистре
- Poly - Значение полинома
- Init - Стартовое значение (указывается для табличного варианта)
- RefIn (Reflect In) - Изменить порядок бит перед началом обработки  
- RefOut (Reflect Out) - Изменить порядок бит перед передачей на XorOut этап 
- XorOut - Значение с которым нужно XOR'ить результирующее значение перед возвращением

Также есть 2 дополнительных поля. Я отношу их больше к метаданным:
- Name - Название алгоритма (этого сборника параметров)
- Check - Результирующее значение при обработке строки "123456789" (в ASCII кодировке)

Некоторые варианты реализации представлены в таблице ниже

| Name          | Width | Poly       | Init       | RefIn | RefOut | XorOut | Check     |
|---------------|-------|------------|------------|-------|--------|--------|-----------|
| CRC-5/ITU     | 5     | 0x15       | 0x0        | true  | true   | 0x0    | 0x7       |
| CRC-8         | 8     | 0x7        | 0x0        | false | false  | 0x0    | 0xF4      |
| CRC-16/USB    | 16    | 0x8005     | 0xFFFF     | true  | true   | 0xFFFF | 0xB4C8    |
| CRC-32/MPEG-2 | 32    | 0x04C11DB7 | 0xFFFFFFFF | false | false  | 0x0    | 0x376E6E7 |

# Заключение

Ну вот мы и прошли этот эволюционный путь от обработки потоков битов, до оптимизированного табличного алгоритма.

Но есть еще несколько тем, которые не были раскрыты:

- Выбор полинома 

От его выбора зависит вероятность обнаружения ошибки.
Филлип Купман сделал исследование влияния различных полиномов за нас ([сайт](https://users.ece.cmu.edu/~koopman/crc/index.html)).
Он исследовал зависимость расстояния Хэмминга от полинома (и его длины соответственно). 
Исследования выявили оптимальные полиномы для расстояний Хэмминга от 2 до 6 (т.е. может заметить от 1 до 5 ошибок).
Ниже представлена часть таблицы с лучшими найденными полиномами:

| HD / Размер полинома | 8    | 16     | 32         |
|----------------------|------|--------|------------|
| 2                    | 0xE7 | 0x8D95 | 0xAD0424F3 |
| 3                    | 0xE7 | 0x8D95 | 0xAD0424F3 |
| 4                    | 0x83 | 0xD175 | 0xC9D204F5 |
| 5                    | 0xEB | 0xAC9A | 0xD419CC15 |
| 6                    | 0x9B | 0x9EB2 | 0x9960034C |


- Аппаратная реализация

Вычисление CRC на столько популярна, что специальные операции были добавлены машинные инструкции:
- SSE4.2 ([вики](https://ru.wikipedia.org/wiki/SSE4#Подсчет_CRC32))
- ARM ([спецификация, 203с](http://www.heenes.de/ro/material/arm/arm_instruction_set_reference_guide.pdf))

Полезные ссылки:
- A painless guide to CRC error detection algorithms ([оригинал](https://ceng2.ktu.edu.tr/~cevhers/ders_materyal/bil311_bilgisayar_mimarisi/supplementary_docs/crc_algorithms.pdf), [русский перевод](https://electronics-components.ru/files/2011/crcguide_168.pdf))
- Реализация CRC на C/Java ([GitHub](https://github.com/Michaelangel007/crc32))
- Каталог полиномов ([сайт](https://users.ece.cmu.edu/~koopman/crc/index.html))
