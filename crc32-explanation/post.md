# Мотивация (введение)

Целостность - это важное свойство системы. 
Будет плохо, если пользовательские данные будут искажены, а мы и глазом не моргнем.

Существуют различные способы достижения этого. Как например, коды коррекции или обнаружения ошибок.
Собственно задача следующая: нам поступают пакеты данных и в процессе передачи данные могут быть искажены, 
поэтому принимающая сторона должна уметь обнаруживать подобные ситуации.

Одним из таких механизмов является CRC (Cyclic Redundancy Check) - циклический избыточный код.
Именно его я решил использовать для проверки целостности в приложении. 
Его реализаций в интернете полно - Ctrl + C, Ctrl + V не хочу.
Но я не я, если бы не ~~сделал свой велосипед~~ разобрался как этот алгоритм работает.

# Обзор алгоритма

Грубо говоря, CRC - это просто остаток от деления. Но до этого мы еще дойдем.

## Деление чисел с остатком

Что мы хотим - обнаружение изменения даже одного байта сообщения. 
Т.е. все биты данных должны учитываться. 
Но неплохо было бы иметь и "лавинность" как у криптографических хэш-функций.
На ум приходит деление, а точнее остаток от деления.

Например, поделим `645372` на `43621` и получим в остатке `34678`.

![Визуализация деления](img/division-decimal-original.png)

Поменяем только 1 цифру в делимом и попробуем снова: `644372 % 43621 = 33678`.

![Визуализация деления](img/division-decimal-changed.png)

Результат изменился - `34678` и `33678` не равны.

Что если представить поток байт, для которого нужно подсчитать чек-сумму, в виде очень большого числа?
Тогда нам остается только найти остаток от деления этого большого числа на делитель.
Уже неплохо. Но как этот делитель найти?
Тут надо вспомнить важное свойство остатка - он всегда меньше делителя.
Прекрасно! Тогда возьмем такой делитель, чтобы остаток укладывался в определенное число байт.
Например, если чек-сумма должна быть 4 байтной, то и максимальное значение делителя должно быть меньше 2^33.

Основу заложили - представляем байты в виде большого числа и находим его остаток от деления на число меньше 2^33.

Посмотрим, как реализуется деление с остатком в двоичном виде:

![Деление двоичных чисел](img/division-binary.png)

Как можно заметить алгоритм следующий:
1. Сравниваем старшие рязряды делимого и делителя
2. Запоминаем текущий бит
3. Переходим к следующему разряду
4. Если запомненный бит выставлен:
   1. Вычитаем из текущей позиции делитель (XOR)
5. Если длина оставшейся части меньше делителя:
   1. Оставшееся число - остаток
   2. Конец
6. Переходим к первому этапу

## Деление многочлена с остатком

Те, кто уже знаком с CRC, знает, что там разговор идет о полиномах, а не числах.
Тут мы подходим к другой важной концепции: остаток от деления многочлена. 

Получить остаток от деления можно не только от числа, но и от многочлена. 
Определяется остаток так же как и для обычных чисел. 
Разница только в том, что результатом будет не число, а многочлен.

Например, поделим многочлен `x^6 + 8x^4` на `x^5 + 1`, тогда в результате получим:
- Частное: `x`
- Остаток: `8x^4 - x`

![Деление многочлена](img/division-polynomial.png)

Но при чем тут многочлены? 
Дело в том, что многочлен можно закодировать в последовательность чисел, где каждое отражает коэффициент при соответствующей степени.

| Число        | x^6 | x^5 | x^4 | x^3 | x^2 | x^1 | x^0 |
|--------------|-----|-----|-----|-----|-----|-----|-----|
| `x^6 + 8x^4` | 1   |     | 8   |     |     |     |     |
| `x^5 + 1`    |     | 1   |     |     |     |     | 1   |
| `x`          |     |     |     |     |     | 1   |     |
| `8x^4 - x`   |     |     | 8   |     |     | -1  |     |
 
Можно подметить, что двоичные числа - это закодированные многочлены.
Их коэффициенты могут принимать только 0 или 1.
Но как быть с умножениями в таком случае, ведь может получиться больше 1?

Здесь на арену приходит "полиномиальная арифметика по модулю 2".
Вкратце, она говорит, что все коэффициенты при каждой степени независимы друг от друга ("полиномиальная арифметика"), 
а результирующий коэффициент - это остаток от деления полученной суммы коэффициентов на 2 ("по модулю 2").

Пример умножения: 
`(x^4 + x^2 + 1) * (x^3 + x^2 + x) = 
(x^7 + x^6 + x^5) + (x^5 + x^4 + x^3) + (x^3 + x^2 + x) =
x^7 + x^6 + 2x^5 + x^4 + 2x^3 + x^2 + x =
x^7 + x^6 +        x^4 +        x^2 + x`

## Двоичная арифметика без учета переносов

Можно заметить, что операция сложения и деления - XOR (единственная операция).
Единственное, надо понять, как в такой арифметике делить.
Деление можно реализовать с помощью вычитания. 
Проблема в том, как понять что одно число больше другого, ведь вычитание и сложение - это одна и та же операция (XOR).
Для этого вводится понятие слабой размерности (weak definition of magnitude) - сравнение происходит по позиции наибольшего значащего бита: 
одно число больше другого, только если позиция его MSB больше позиции MSB другого числа.

## Складываем все вместе

Можно заметить, что алгоритм деления числа на число (в двоичном представлении) 
использует те же самые правила, что и полиномиальная арифметика по модулю 2.

Все рассуждения об алгоритме CRC ведутся именно в таком ключе:
- Все операции происходят над многочленами в конечном поле по модулю 2 (GF(2))
- На вход подается многочлен - байты для высчитывания чек-суммы
- Делитель - другой многочлен (его называют порождающим)
- Задача CRC - найти остаток от деления переданного многочлена на порождающий

> Дальше будем говорить о делителе как о числе, а не полиноме

# Реализация в лоб

Реализация у нас уже на руках.
Осталось только несколько моментов:
- Добавим регистр - переменную, в которой будем хранить промежуточный результат после каждого шага вычитания. 
  Его размер должен быть таким же как и у результата. 
  Здесь и дальше будем предполагать, что вычисляемый остаток размера 32 бита (4 байта).
- Сообщение нужно дополнять в конце нулевыми байтами, чтобы регистр смог правильно обработать сообщение.
  Дополнять нужно столько-же, сколько занимает регистр (32 бита/нуля).

### TODO: реализация в лоб

```cs
uint InitialSimpleRegister = 0xFFFFFFFF;
uint Polynomial = 0x04C11DB7;

uint ComputePerBit(byte[] payload)
{
    var register = InitialSimpleRegister;
    
    foreach (var bit in IterateBits())
    {
        var bitSet = ( register & 0x80000000 ) != 0;
        register <<= 1;
        register |= bit;
        if (bitSet)
        {
            register ^= Polynomial;
        }
    }
    
    // Обрабатываем нулевые биты сообщения (дополненные)
    for (var i = 0; i < 32; i++)
    {
        var bitSet = ( register & 0x80000000 ) != 0;
        register <<= 1;
        // Дальше идут только 0
        // register |= bitSet;
        if (bitSet)
        {
            register ^= Polynomial;
        }
    }
    
    return register;

    IEnumerable<uint> IterateBits()
    {
        foreach (var b in payload)
        {
            for (byte byteMask = 0b10000000; byteMask != 0; byteMask >>= 1)
            {
                yield return ( b & byteMask ) == 0 
                                 ? 0u
                                 : 1u;
            }
        }
    }
}
```

# Оптимизируем работу с байтами (табличная реализация)
   
Предыдущая реализация в лоб режет глаз. 
Она не оптимальна, как минимум, потому что компьютер работает с байтами, а не потоком бит.
Хотелось бы, чтобы работа велась с минимальным куском (byte) данных - байтом.

Есть один момент, который стоит заметить, - зависимость операций.
Каждая операция зависит только от текущего бита и предыдущих операций - в будущее мы не смотрим.

### TODO: значения регистров конкретные поставить
Так как мы работаем с байтами, то это значит, что имея текущий байт, мы уже знаем значение на которое нужно XOR'ить.
Например:
- Значение регистра: xxx
- Полином: yyy

Сейчас мы можем вычислить значение, которое будет применено ко всему регистру:
### TODO: картинка как вычисляем это значение

А к чему будет это значение применяться? К оставшимся байтам регистра + следующий байт!
Т.е. будет так:
### TODO: картинка как это значение применяется

Компьютер всегда работает с байтами - отдельных битов быть не может. 
Давайте вычислим значения, которые нужно применять, в зависимости от старшего байта!

В этом и заключается оптимизация - создание подобной таблицы.

```cs
uint[] ComputeCrcTable()
{
    var table = new uint[256];
    
    for (int i = 0; i < 256; i++)
    {
        var crc = ( uint )( i << 24 );
        for (int bit = 0; bit < 8; bit++)
        {
            var bitSet = ( crc & 0x80000000 ) != 0;
            crc <<= 1;
            if (bitSet)
            {
                crc ^= Polynomial;
            }
        }
    
        table[i] = crc;
    }
    
    return table;
}

uint ComputeTableSimple(byte[] payload)
{
    var table = ComputeCrcTable();
    var register = InitialSimpleRegister;

    foreach (var b in payload)
    {
        register = ( ( register << 8 ) | b ) ^ table[register >> 24];
    }

    for (int i = 0; i < 4; i++)
    {
        register = ( register << 8 ) ^ table[register >> 24];
    }
    
    return register;
}
```

# Дальнейшие оптимизации

Заметили дополнительный цикл, который идет после обработки самого сообщения?
Это дополняющие биты, о которых было сказано ранее.
Вроде 4 байта, но не всегда удобно следить за таким (да и не совсем красиво). 

Можно, конечно, заставить самого пользователя добавлять нулевые биты в конце, но тогда может нарушиться логика, если внезапно забудешь это сделать.

На самом деле, эту проблему уже решили. 
Причем, на мой взгляд, кардинальным способом - изменили сам алгоритм (взгляд на него).

Чтобы понять, что имеется ввиду, обратим внимание на следующие факты:
1. Нулевые байты нужны только для того, чтобы были корректно обработаны все байты исходного сообщения.
   Причем сами нули ни на что не влияют (`x XOR 0 = x`).
   Т.е. по факту, можно их не добавлять - главное провести все байты сообщения через алгоритм. 
2. Первые 4 цикла - загрузка первых 4 байт сообщения.
   Причем независимо от того, что в регистре было изначально, этот этап можно опустить/сократить и сразу начать загружать байты сообщения.

<spoiler title="Почему первые 4 цикла можно опустить">

В зависимости от значения регистра может быть 2 случая:
1. Изначально был 0

    Все просто - первые 4 цикла загрузят первые 4 байта сообщения и никаким образом их не изменят.
    Изменений не будет, так как табличное значение для 0 - это 0, а `x XOR 0 = x`.

    ### TODO: визуализация этого варианта
2. Изначально был НЕ 0

    Этот случай не отличается от того, что если бы мы выполнили XOR между первыми 4 байтами сообщения и другим начальным значением регистра.
    Только это новое значение регистра не случайное, а вычисляется из изначального значения регистра старого алгоритма (об этом дальше).

</spoiler>

После небольшой модификации, алгоритм становится следующим:

1. Инициализируем регистр `register` (уже новым значением)
2. Для каждого байта `b` из сообщения:
   1. Берем старший байт из регистра `top_byte`
   2. Сдвигаем регистр на байт влево
   3. Вычисляем индекс для таблицы: `b XOR top_byte`
   4. Получаем значение из таблицы по полученному индексу
   5. XOR'им регистр с полученным значением из таблицы

### TODO: визуализация работы алгоритма

Единственное, что пока непонятно - как рассчитывать новое начальное значение регистра.
Чтобы вычислить новое значение регистра, нужно пропустить старое через цикл 4 раза (только начальное значение, без байтов сообщения).

```cs
uint ComputeNewInitialValue()
{
    var register = InitialSimpleRegister;
    
    for (var i = 0; i < 32; i++)
    {
        var bitSet = ( register & 0x80000000 ) != 0;
        register <<= 1;
        if (bitSet)
        {
            register ^= Polynomial;
        }
    }
    
    return register;
}
```

Например, если в старом алгоритме начальное значение было `0xFFFFFFFF`, то новое будет равно `0xC704DD7B` (полином равен `0x04C11DB7`).
В результате, эти 2 реализации будут давать одно и то же значение - `0xAE006622` (можете проверить).

### TODO: как это происходит ?? (визуализация)

Подобная оптимизация возможна так как операция XOR - ассоциативна. 
Это используется как раз в моменте XOR'а байта сообщения и старшего байта регистра:
- Раньше: кладем байт сообщения, а потом постепенно применяем к нему операции из таблицы - `message_byte XOR op1 XOR op2 XOR op3`
- Теперь: применяем операции из таблицы и только в конце байт сообщения - `op1 XOR op2 XOR op3 XOR message_byte`

P.S. старший байт регистра теперь можно рассматривать как аккумулятор всех предыдущих операций из таблицы.

Теперь вся задача свелась к одной единственной - для уже существующего регистра подсчитать регистр, к которому будет применен очередной байт сообщения.

<spoiler title="Сравниваем выполнение по шагам">

Рассмотрим выполнение старого и нового алгоритма по шагам.
Используем полином
### TODO: покажем 

### TODO: добавить визуализации работы как в статье (с +----+ и т.д.)

</spoiler>

Собственно сам код оптимизированного табличного алгоритма:
```cs
uint InitialOptimizedRegister = 0xC704DD7B;

uint ComputeTableOptimized(byte[] payload)
{
    var register = InitialOptimizedRegister;

    foreach (var b in payload)
    {
        register = ( register << 8 ) ^ Table[( register >> 24 ) ^ b];
    }
    
    return register;
}
```

# Параметризация

Вот мы и дошли до конца.
На текущий момент, мы увидели 3 места, которые могут быть настроены: 
1. Размер полинома
2. Значение полинома
3. Исходное значение регистра.

Но на самом деле их больше. Можно добавить еще 2 параметра:
- XOR конечного результата с каким-то числом - перед возвращением результата он XOR'ится с каким-то числом
- Порядок байтов - можно указать, что при работе все биты должны быть отзеркалены (UART отправляет биты в обратном порядке) 

Росс Уильямс выделяет такую параметризацию:
- Width - Степень полинома, число битов в регистре
- Poly - Значение полинома
- Init - Стартовое значение (указывается именно для табличного варианта)
- RefIn (Reflect In) - Изменить порядок бит перед началом обработки  
- RefOut (Reflect Out) - Изменить порядок бит перед передачей на XorOut этап 
- XorOut - Значение с которым нужно XOR'ить результирующее значение перед возвращением

Также есть 2 дополнительных поля. Лично я отношу их больше к метаданным:
- Name - Название алгоритма (этого сборника параметров)
- Check - Результирующее значение при обработке строки "123456789" (в ASCII кодировке)

Некоторые варианты реализации представлены в таблице ниже

| Name          | Width | Poly       | Init       | RefIn | RefOut | XorOut | Check     |
|---------------|-------|------------|------------|-------|--------|--------|-----------|
| CRC-5/ITU     | 5     | 0x15       | 0x0        | true  | true   | 0x0    | 0x7       |
| CRC-8         | 8     | 0x7        | 0x0        | false | false  | 0x0    | 0xF4      |
| CRC-16/USB    | 16    | 0x8005     | 0xFFFF     | true  | true   | 0xFFFF | 0xB4C8    |
| CRC-32/MPEG-2 | 32    | 0x04C11DB7 | 0xFFFFFFFF | false | false  | 0x0    | 0x376E6E7 |

# Заключение

Ну вот мы и прошли этот эволюционный путь от обработки потоков битов, до оптимизированного табличного алгоритма.

Но есть еще несколько тем, которые не были раскрыты:

## Выбор полинома

От выбора полинома зависит вероятность обнаружения ошибки.
Филлип Купман провел исследование влияния различных полиномов на вероятность нахождения ошибок за нас ([сайт](https://users.ece.cmu.edu/~koopman/crc/index.html)).
Он исследовал зависимость расстояния Хэмминга ошибок от полинома (и его длины соответственно). 
Исследования выявили оптимальные полиномы для расстояний Хэмминга от 2 до 6 (т.е. может заметить от 1 до 5 ошибок).
Ниже представлена часть таблицы с лучшими найденными полиномами:

| Расстояние хэмминга / Размер полинома | 8    | 16     | 32         |
|---------------------------------------|------|--------|------------|
| 2                                     | 0xE7 | 0x8D95 | 0xAD0424F3 |
| 3                                     | 0xE7 | 0x8D95 | 0xAD0424F3 |
| 4                                     | 0x83 | 0xD175 | 0xC9D204F5 |
| 5                                     | 0xEB | 0xAC9A | 0xD419CC15 |
| 6                                     | 0x9B | 0x9EB2 | 0x9960034C |


## Аппаратная реализация

Вычисление CRC на столько популярна, что специальные операции были добавлены машинные инструкции:
- SSE4.2 ([вики](https://ru.wikipedia.org/wiki/SSE4#Подсчет_CRC32))
- ARM ([спецификация, 203с](http://www.heenes.de/ro/material/arm/arm_instruction_set_reference_guide.pdf))

# Полезные ссылки:
- A painless guide to CRC error detection algorithms ([оригинал](https://ceng2.ktu.edu.tr/~cevhers/ders_materyal/bil311_bilgisayar_mimarisi/supplementary_docs/crc_algorithms.pdf), [русский перевод](https://electronics-components.ru/files/2011/crcguide_168.pdf))
- Реализация CRC на C/Java ([GitHub](https://github.com/Michaelangel007/crc32))
- Каталог полиномов ([сайт](https://users.ece.cmu.edu/~koopman/crc/index.html))
